{"meta":{"title":"Pa1r0t","subtitle":"re&crypto","description":"welcome to my bolg","author":"Pa1r0t_9e","url":"https://pa1r0t.github.io","root":"/"},"pages":[{"title":"ctf","date":"2022-11-07T10:06:36.000Z","updated":"2022-11-07T10:08:24.873Z","comments":true,"path":"categories/ctf.html","permalink":"https://pa1r0t.github.io/categories/ctf.html","excerpt":"什么是CTF?下面我们对课程进行一个内容的讲解。","text":"什么是CTF?下面我们对课程进行一个内容的讲解。 在讲解之前我们首先来对ctf进行对应讲解，ctf是当前1种非常流行的信息安全竞赛形式，其英文名可翻译为夺得flag，也可翻译为夺旗赛。其大体流程是参赛团队之间通过攻防对抗程序分析等形式，首先从主办方给出的比赛环境中获得一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而得的对应分数，为了方便称呼，我们把这样的内容称之为flag，当然在ctf比赛当中涉及内容非常繁杂，我们需要利用，所有可以利用的方，法获得对应的flag，以上就是咱们ctf这样一个比赛形式。"},{"title":"categories","date":"2022-11-06T05:27:18.000Z","updated":"2022-11-07T03:30:48.209Z","comments":true,"path":"categories/index.html","permalink":"https://pa1r0t.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-08T07:12:37.000Z","updated":"2022-11-08T07:31:53.670Z","comments":true,"path":"links/index.html","permalink":"https://pa1r0t.github.io/links/index.html","excerpt":"","text":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 30%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } Emil’s blog 这是一个分享IT技术的小站。 越行勤's Blog 努力学习的小菜鸟"},{"title":"about","date":"2022-11-07T03:32:11.000Z","updated":"2022-11-07T03:38:36.970Z","comments":true,"path":"about/index.html","permalink":"https://pa1r0t.github.io/about/index.html","excerpt":"","text":"介绍大家好，我是Pa1r0t 在下末流二本在读，喜欢吹牛睡觉发呆 当然偶尔打打ctf 专业兴趣在安卓逆向 不过以后行情不好的话可能会考虑继续深造，大家如果喜欢我的文章，请保持关注嘤"},{"title":"ctf介绍","date":"2022-11-08T08:19:16.000Z","updated":"2022-11-08T08:42:09.043Z","comments":true,"path":"ctf/ctf.html","permalink":"https://pa1r0t.github.io/ctf/ctf.html","excerpt":"CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。","text":"CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。 CTF竞赛模式具体分为以下三类： 一、解题模式（Jeopardy） 在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。 二、攻防模式（Attack-Defense） 在攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。 [1] 三、混合模式（Mix） 结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。"},{"title":"标签","date":"2022-11-06T05:26:24.000Z","updated":"2022-11-07T02:00:45.230Z","comments":true,"path":"tags/index.html","permalink":"https://pa1r0t.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"安徽省赛","slug":"安徽省赛","date":"2022-11-21T06:13:57.000Z","updated":"2022-11-21T07:21:15.522Z","comments":true,"path":"2022/11/21/安徽省赛/","link":"","permalink":"https://pa1r0t.github.io/2022/11/21/%E5%AE%89%E5%BE%BD%E7%9C%81%E8%B5%9B/","excerpt":"安徽省赛只有一个小时，我吐了，脚本都来不及写。。。。赛后才把flag搞出来","text":"安徽省赛只有一个小时，我吐了，脚本都来不及写。。。。赛后才把flag搞出来 呃， 我其实也是第一次见这么庞大的迷宫，一共4384个格~~ 这里看见一行66 代码逻辑很简单，这里不做过多介绍 &#x2F;我原先的脚本的思路是走到错的地方再返回，导致效率太低，跑了好久都没跑出来&#x2F; 赛后我还未想好该怎么优化我的深搜算法，所以就进行了一波手工画图。。。。。。。。 图1： 图二： 图三： emmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm 然后就根据这个路线，手写路线字符串 以上是我写的，本办法，太菜了，只能这么搞了 ##下面贴上EDI团队的脚本 1234567891011121314151617181920212223242526272829303132333435363738394041map = []data =[map[i*66:i*66+66] for i in range(66)]print(data)usedmap = [[0 for i in range(len(data))] for i in range(len(data)) ]flag=&quot;&quot;def DFS(x,y): global flag if x == 64 and y == 65: print(flag) if data[x+1][y] == 0 and usedmap [x+1][y] == 0: usedmap [x][y] = 1 flag += &#x27;s&#x27; DFS(x+1,y) flag = flag[:-1] usedmap [x][y] = 0 if data[x-1][y] == 0 and usedmap [x-1][y] == 0: usedmap [x][y] = 1 flag += &#x27;w&#x27; DFS(x-1,y) flag = flag[:-1] usedmap [x][y] = 0 if data[x][y+1] == 0 and usedmap [x][y+1] == 0: usedmap [x][y] = 1 flag += &#x27;d&#x27; DFS(x,y+1) flag = flag[:-1] usedmap [x][y] = 0 if data[x][y-1] == 0 and usedmap [x][y-1] == 0: usedmap [x][y] = 1 flag += &#x27;a&#x27; DFS(x,y-1) flag = flag[:-1] usedmap [x][y] = 0y=0x=1try: DFS(x,y)except: pass 他们的脚本其实就是只走对的位置，我实在没想到居然效率会快这么多！！！！！！！！！ 后来我参照他们的思路，重新优化了一下我的脚本，可以说在他们的基础上在一次优化了程序的效率 只能说算法实在太重要了！！！！！！！！！！！！！！ 我的代码：1234567891011121314151617181920212223242526272829303132def dfs(v6, v7): global flag if len(flag) &gt; 364: # 这里防止深度过深 return if v6 == 64 and v7 == 65: print(flag) tlag[66 * v6 + v7] = 1 # 标记走过了 if map1[66 * v6 + v7 + 1] == 0 and tlag[66 * v6 + v7+1] == 0: # 这个位置能不能走，有没有走过 flag += &#x27;d&#x27; dfs(v6, v7 + 1) flag = flag[:-1] if map1[66 * (v6+1) + v7] == 0 and tlag[66 * (v6+1) + v7] == 0: flag += &#x27;s&#x27; dfs(v6+1,v7) flag = flag[:-1] if map1[66 * (v6-1) + v7] == 0 and tlag[66 * (v6-1) + v7] == 0: flag += &#x27;w&#x27; dfs(v6-1, v7) flag = flag[:-1] if map1[66 * (v6) + v7 - 1] == 0 and tlag[66 * (v6) + v7-1] == 0: flag += &#x27;a&#x27; dfs(v6, v7 - 1) flag = flag[:-1] # 这里不用将标志去掉，因为这个位置所有方向都走过了都没到终点，那么其他位置到达该位置也无法到达终点，所以懂吧？if __name__ == &quot;__main__&quot;: map1 = [] tlag = [0]*len(map1) flag = &quot;&quot; try: dfs(1, 0) except: pass 至于代码的细节这里直接看注释即可，都已经写好了 总结这里个人的算法功底还有待提升，算法还是要多练，不然明明会做，但是现场做不出来，太难受了！！！","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"ctf介绍","slug":"ctf介绍","date":"2022-11-08T08:19:16.000Z","updated":"2022-11-08T08:41:07.497Z","comments":true,"path":"2022/11/08/ctf介绍/","link":"","permalink":"https://pa1r0t.github.io/2022/11/08/ctf%E4%BB%8B%E7%BB%8D/","excerpt":"CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。","text":"CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。 CTF竞赛模式具体分为以下三类： 一、解题模式（Jeopardy） 在解题模式CTF赛制中，参赛队伍可以通过互联网或者现场网络参与，这种模式的CTF竞赛与ACM编程竞赛、信息学奥赛比较类似，以解决网络安全技术挑战题目的分值和时间来排名，通常用于在线选拔赛。题目主要包含逆向、漏洞挖掘与利用、Web渗透、密码、取证、隐写、安全编程等类别。 二、攻防模式（Attack-Defense） 在攻防模式CTF赛制中，参赛队伍在网络空间互相进行攻击和防守，挖掘网络服务漏洞并攻击对手服务来得分，修补自身服务漏洞进行防御来避免丢分。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续48小时及以上），同时也比团队之间的分工配合与合作。 [1] 三、混合模式（Mix） 结合了解题模式与攻防模式的CTF赛制，比如参赛队伍通过解题可以获取一些初始分数，然后通过攻防对抗进行得分增减的零和游戏，最终以得分高低分出胜负。采用混合模式CTF赛制的典型代表如iCTF国际CTF竞赛。","categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"}],"tags":[]},{"title":"对安卓逆向的理解","slug":"对安卓逆向的理解","date":"2022-11-07T07:29:56.000Z","updated":"2022-11-08T09:01:37.693Z","comments":true,"path":"2022/11/07/对安卓逆向的理解/","link":"","permalink":"https://pa1r0t.github.io/2022/11/07/%E5%AF%B9%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"安卓逆向是什么？目前百度知道都没有收录安卓逆向这个词条，大部分能搜索到的资料都是技术人员写的偏技术类的文章，往往充斥着代码和各类工具集合，非技术人员一看就比较懵逼。","text":"安卓逆向是什么？目前百度知道都没有收录安卓逆向这个词条，大部分能搜索到的资料都是技术人员写的偏技术类的文章，往往充斥着代码和各类工具集合，非技术人员一看就比较懵逼。 简单地来说，安卓逆向是对已经打包好的APP进行反编译、源码分析了解APP实现逻辑的一门技术。我们可以把安卓安装时用到的APK文件看作一个加密后的压缩包，逆向就是要最大程序地还原出APK打包之前的源码。 逆向需要用到解密、反编译、解压缩等技术，想要100%还原APK的源码几乎是不可能的，所以在实际进行逆向分析的时候，一般都是根据想实现的目的，分析出APK的部分源码和实现逻辑，然后对这一部分源码进行修改后与原始的APK打包在一起，这样就获得了一个实现自己特定目的的APP。 安卓逆向到底能做什么？APP自动化执行程序脚本比如有这么一个场景：某APP在某天某一时刻将推广一个领代金券的活动，只要登录账号，进入领取页面即可领取一张面额100元的无门槛代金券。很显然，这是一个可以撸羊毛的活动，如果我收集了100个账号，在那天利用某些手段确保每个账号抢到一张代金券，那我就能抢到100*100&#x3D;10000元的代金券，再利用网络把这些券打7折卖出去，就能赚个7000块，是不是很爽？！通过安卓逆向分析，我就能把登录、领券的动作做成一个自动化执行的插件，我先把所有账号和密码保存起来备用，到了领券的开放时间，立即自动登录、领券，一个账号领券完，自动切换登录另一个账号，一气呵成就把所有账号的券都领到手。这就是安卓逆向的用途之一，可以自动化批量执行APP的一系列动作。类似地，如果想实现批量登录账号、点赞、评论，同样也是可以的。 修改APP的功能不知道大家有没有遇到过，有些APP经常提示要更新，有些必须强制更新才能使用，可我就是不想更新，这时候也可以用逆向技术来实现修改APP的某些功能。通过逆向分析，找到触发更新的代码，然后把它屏蔽掉，这样打开APP后就再也不会提示更新了。 安卓逆向学习路线以下是笔者自学笔记，以破解某目标apk的方式进行学习，中间辅以原理性知识，方便面试需求。 Android逆向入门流程获取目标apk确定逆向目标拖动目标文件到集成工具加固集成工具分析减少混淆干扰定位目标分析业务逻辑确定逆向方法使用apktool进行反编译得到.smali源码调试回编译app签名","categories":[{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]}],"categories":[{"name":"ctf","slug":"ctf","permalink":"https://pa1r0t.github.io/categories/ctf/"},{"name":"re","slug":"re","permalink":"https://pa1r0t.github.io/categories/re/"}],"tags":[]}